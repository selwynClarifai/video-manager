// Generated by the gRPC C++ plugin.
// If you make any local change, they will be lost.
// source: proto/lopq/lopq_service.proto
#ifndef GRPC_proto_2flopq_2flopq_5fservice_2eproto__INCLUDED
#define GRPC_proto_2flopq_2flopq_5fservice_2eproto__INCLUDED

#include "proto/lopq/lopq_service.pb.h"

#include <functional>
#include <grpc/impl/codegen/port_platform.h>
#include <grpcpp/impl/codegen/async_generic_service.h>
#include <grpcpp/impl/codegen/async_stream.h>
#include <grpcpp/impl/codegen/async_unary_call.h>
#include <grpcpp/impl/codegen/client_callback.h>
#include <grpcpp/impl/codegen/client_context.h>
#include <grpcpp/impl/codegen/completion_queue.h>
#include <grpcpp/impl/codegen/message_allocator.h>
#include <grpcpp/impl/codegen/method_handler.h>
#include <grpcpp/impl/codegen/proto_utils.h>
#include <grpcpp/impl/codegen/rpc_method.h>
#include <grpcpp/impl/codegen/server_callback.h>
#include <grpcpp/impl/codegen/server_callback_handlers.h>
#include <grpcpp/impl/codegen/server_context.h>
#include <grpcpp/impl/codegen/service_type.h>
#include <grpcpp/impl/codegen/status.h>
#include <grpcpp/impl/codegen/stub_options.h>
#include <grpcpp/impl/codegen/sync_stream.h>

// Interface exported by the server.
class LOPQService final {
 public:
  static constexpr char const* service_full_name() {
    return "LOPQService";
  }
  class StubInterface {
   public:
    virtual ~StubInterface() {}
    // Predicts the LOPQ codes for given embeddings for a LOPQ model
    virtual ::grpc::Status LOPQPredict(::grpc::ClientContext* context, const ::LOPQPredictRequest& request, ::LOPQPredictResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::LOPQPredictResponse>> AsyncLOPQPredict(::grpc::ClientContext* context, const ::LOPQPredictRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::LOPQPredictResponse>>(AsyncLOPQPredictRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::LOPQPredictResponse>> PrepareAsyncLOPQPredict(::grpc::ClientContext* context, const ::LOPQPredictRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::LOPQPredictResponse>>(PrepareAsyncLOPQPredictRaw(context, request, cq));
    }
    // Searches for embeddings given an optional SQL template to only consider a subset of assets for a LOPQ model
    virtual ::grpc::Status LOPQSearch(::grpc::ClientContext* context, const ::LOPQSearchRequest& request, ::LOPQSearchResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::LOPQSearchResponse>> AsyncLOPQSearch(::grpc::ClientContext* context, const ::LOPQSearchRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::LOPQSearchResponse>>(AsyncLOPQSearchRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::LOPQSearchResponse>> PrepareAsyncLOPQSearch(::grpc::ClientContext* context, const ::LOPQSearchRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::LOPQSearchResponse>>(PrepareAsyncLOPQSearchRaw(context, request, cq));
    }
    // Searches for embeddings and attributes given a SQL template and custom models to weight results
    virtual ::grpc::Status LOPQAttributeSearch(::grpc::ClientContext* context, const ::LOPQAttributeSearchRequest& request, ::LOPQSearchResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::LOPQSearchResponse>> AsyncLOPQAttributeSearch(::grpc::ClientContext* context, const ::LOPQAttributeSearchRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::LOPQSearchResponse>>(AsyncLOPQAttributeSearchRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::LOPQSearchResponse>> PrepareAsyncLOPQAttributeSearch(::grpc::ClientContext* context, const ::LOPQAttributeSearchRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::LOPQSearchResponse>>(PrepareAsyncLOPQAttributeSearchRaw(context, request, cq));
    }
    // Searches for embeddings given a LOPQ model returning LOPQ coarse keys and distances only
    virtual ::grpc::Status LOPQSearchForCodes(::grpc::ClientContext* context, const ::LOPQSearchForCodesRequest& request, ::LOPQSearchForCodesResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::LOPQSearchForCodesResponse>> AsyncLOPQSearchForCodes(::grpc::ClientContext* context, const ::LOPQSearchForCodesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::LOPQSearchForCodesResponse>>(AsyncLOPQSearchForCodesRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::LOPQSearchForCodesResponse>> PrepareAsyncLOPQSearchForCodes(::grpc::ClientContext* context, const ::LOPQSearchForCodesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::LOPQSearchForCodesResponse>>(PrepareAsyncLOPQSearchForCodesRaw(context, request, cq));
    }
    // Brute force search for nearest neighbors of query embeddings.
    virtual ::grpc::Status LOPQBruteForceSearch(::grpc::ClientContext* context, const ::LOPQBruteForceSearchRequest& request, ::LOPQBruteForceSearchResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::LOPQBruteForceSearchResponse>> AsyncLOPQBruteForceSearch(::grpc::ClientContext* context, const ::LOPQBruteForceSearchRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::LOPQBruteForceSearchResponse>>(AsyncLOPQBruteForceSearchRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::LOPQBruteForceSearchResponse>> PrepareAsyncLOPQBruteForceSearch(::grpc::ClientContext* context, const ::LOPQBruteForceSearchRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::LOPQBruteForceSearchResponse>>(PrepareAsyncLOPQBruteForceSearchRaw(context, request, cq));
    }
    // LOPQTrain by iterating over database and then save model to s3.
    virtual ::grpc::Status LOPQTrain(::grpc::ClientContext* context, const ::LOPQTrainRequest& request, ::LOPQTrainResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::LOPQTrainResponse>> AsyncLOPQTrain(::grpc::ClientContext* context, const ::LOPQTrainRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::LOPQTrainResponse>>(AsyncLOPQTrainRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::LOPQTrainResponse>> PrepareAsyncLOPQTrain(::grpc::ClientContext* context, const ::LOPQTrainRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::LOPQTrainResponse>>(PrepareAsyncLOPQTrainRaw(context, request, cq));
    }
    // Evaluates a LOPQ model by comparing to brute force for a set of sample query embeddings.
    virtual ::grpc::Status LOPQTrainAndEval(::grpc::ClientContext* context, const ::LOPQTrainAndEvalRequest& request, ::LOPQTrainAndEvalResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::LOPQTrainAndEvalResponse>> AsyncLOPQTrainAndEval(::grpc::ClientContext* context, const ::LOPQTrainAndEvalRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::LOPQTrainAndEvalResponse>>(AsyncLOPQTrainAndEvalRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::LOPQTrainAndEvalResponse>> PrepareAsyncLOPQTrainAndEval(::grpc::ClientContext* context, const ::LOPQTrainAndEvalRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::LOPQTrainAndEvalResponse>>(PrepareAsyncLOPQTrainAndEvalRaw(context, request, cq));
    }
    class experimental_async_interface {
     public:
      virtual ~experimental_async_interface() {}
      // Predicts the LOPQ codes for given embeddings for a LOPQ model
      virtual void LOPQPredict(::grpc::ClientContext* context, const ::LOPQPredictRequest* request, ::LOPQPredictResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void LOPQPredict(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::LOPQPredictResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void LOPQPredict(::grpc::ClientContext* context, const ::LOPQPredictRequest* request, ::LOPQPredictResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void LOPQPredict(::grpc::ClientContext* context, const ::LOPQPredictRequest* request, ::LOPQPredictResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void LOPQPredict(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::LOPQPredictResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void LOPQPredict(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::LOPQPredictResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // Searches for embeddings given an optional SQL template to only consider a subset of assets for a LOPQ model
      virtual void LOPQSearch(::grpc::ClientContext* context, const ::LOPQSearchRequest* request, ::LOPQSearchResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void LOPQSearch(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::LOPQSearchResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void LOPQSearch(::grpc::ClientContext* context, const ::LOPQSearchRequest* request, ::LOPQSearchResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void LOPQSearch(::grpc::ClientContext* context, const ::LOPQSearchRequest* request, ::LOPQSearchResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void LOPQSearch(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::LOPQSearchResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void LOPQSearch(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::LOPQSearchResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // Searches for embeddings and attributes given a SQL template and custom models to weight results
      virtual void LOPQAttributeSearch(::grpc::ClientContext* context, const ::LOPQAttributeSearchRequest* request, ::LOPQSearchResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void LOPQAttributeSearch(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::LOPQSearchResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void LOPQAttributeSearch(::grpc::ClientContext* context, const ::LOPQAttributeSearchRequest* request, ::LOPQSearchResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void LOPQAttributeSearch(::grpc::ClientContext* context, const ::LOPQAttributeSearchRequest* request, ::LOPQSearchResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void LOPQAttributeSearch(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::LOPQSearchResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void LOPQAttributeSearch(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::LOPQSearchResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // Searches for embeddings given a LOPQ model returning LOPQ coarse keys and distances only
      virtual void LOPQSearchForCodes(::grpc::ClientContext* context, const ::LOPQSearchForCodesRequest* request, ::LOPQSearchForCodesResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void LOPQSearchForCodes(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::LOPQSearchForCodesResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void LOPQSearchForCodes(::grpc::ClientContext* context, const ::LOPQSearchForCodesRequest* request, ::LOPQSearchForCodesResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void LOPQSearchForCodes(::grpc::ClientContext* context, const ::LOPQSearchForCodesRequest* request, ::LOPQSearchForCodesResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void LOPQSearchForCodes(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::LOPQSearchForCodesResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void LOPQSearchForCodes(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::LOPQSearchForCodesResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // Brute force search for nearest neighbors of query embeddings.
      virtual void LOPQBruteForceSearch(::grpc::ClientContext* context, const ::LOPQBruteForceSearchRequest* request, ::LOPQBruteForceSearchResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void LOPQBruteForceSearch(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::LOPQBruteForceSearchResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void LOPQBruteForceSearch(::grpc::ClientContext* context, const ::LOPQBruteForceSearchRequest* request, ::LOPQBruteForceSearchResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void LOPQBruteForceSearch(::grpc::ClientContext* context, const ::LOPQBruteForceSearchRequest* request, ::LOPQBruteForceSearchResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void LOPQBruteForceSearch(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::LOPQBruteForceSearchResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void LOPQBruteForceSearch(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::LOPQBruteForceSearchResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // LOPQTrain by iterating over database and then save model to s3.
      virtual void LOPQTrain(::grpc::ClientContext* context, const ::LOPQTrainRequest* request, ::LOPQTrainResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void LOPQTrain(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::LOPQTrainResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void LOPQTrain(::grpc::ClientContext* context, const ::LOPQTrainRequest* request, ::LOPQTrainResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void LOPQTrain(::grpc::ClientContext* context, const ::LOPQTrainRequest* request, ::LOPQTrainResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void LOPQTrain(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::LOPQTrainResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void LOPQTrain(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::LOPQTrainResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // Evaluates a LOPQ model by comparing to brute force for a set of sample query embeddings.
      virtual void LOPQTrainAndEval(::grpc::ClientContext* context, const ::LOPQTrainAndEvalRequest* request, ::LOPQTrainAndEvalResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void LOPQTrainAndEval(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::LOPQTrainAndEvalResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void LOPQTrainAndEval(::grpc::ClientContext* context, const ::LOPQTrainAndEvalRequest* request, ::LOPQTrainAndEvalResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void LOPQTrainAndEval(::grpc::ClientContext* context, const ::LOPQTrainAndEvalRequest* request, ::LOPQTrainAndEvalResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void LOPQTrainAndEval(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::LOPQTrainAndEvalResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void LOPQTrainAndEval(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::LOPQTrainAndEvalResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
    };
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    typedef class experimental_async_interface async_interface;
    #endif
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    async_interface* async() { return experimental_async(); }
    #endif
    virtual class experimental_async_interface* experimental_async() { return nullptr; }
  private:
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::LOPQPredictResponse>* AsyncLOPQPredictRaw(::grpc::ClientContext* context, const ::LOPQPredictRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::LOPQPredictResponse>* PrepareAsyncLOPQPredictRaw(::grpc::ClientContext* context, const ::LOPQPredictRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::LOPQSearchResponse>* AsyncLOPQSearchRaw(::grpc::ClientContext* context, const ::LOPQSearchRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::LOPQSearchResponse>* PrepareAsyncLOPQSearchRaw(::grpc::ClientContext* context, const ::LOPQSearchRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::LOPQSearchResponse>* AsyncLOPQAttributeSearchRaw(::grpc::ClientContext* context, const ::LOPQAttributeSearchRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::LOPQSearchResponse>* PrepareAsyncLOPQAttributeSearchRaw(::grpc::ClientContext* context, const ::LOPQAttributeSearchRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::LOPQSearchForCodesResponse>* AsyncLOPQSearchForCodesRaw(::grpc::ClientContext* context, const ::LOPQSearchForCodesRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::LOPQSearchForCodesResponse>* PrepareAsyncLOPQSearchForCodesRaw(::grpc::ClientContext* context, const ::LOPQSearchForCodesRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::LOPQBruteForceSearchResponse>* AsyncLOPQBruteForceSearchRaw(::grpc::ClientContext* context, const ::LOPQBruteForceSearchRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::LOPQBruteForceSearchResponse>* PrepareAsyncLOPQBruteForceSearchRaw(::grpc::ClientContext* context, const ::LOPQBruteForceSearchRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::LOPQTrainResponse>* AsyncLOPQTrainRaw(::grpc::ClientContext* context, const ::LOPQTrainRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::LOPQTrainResponse>* PrepareAsyncLOPQTrainRaw(::grpc::ClientContext* context, const ::LOPQTrainRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::LOPQTrainAndEvalResponse>* AsyncLOPQTrainAndEvalRaw(::grpc::ClientContext* context, const ::LOPQTrainAndEvalRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::LOPQTrainAndEvalResponse>* PrepareAsyncLOPQTrainAndEvalRaw(::grpc::ClientContext* context, const ::LOPQTrainAndEvalRequest& request, ::grpc::CompletionQueue* cq) = 0;
  };
  class Stub final : public StubInterface {
   public:
    Stub(const std::shared_ptr< ::grpc::ChannelInterface>& channel);
    ::grpc::Status LOPQPredict(::grpc::ClientContext* context, const ::LOPQPredictRequest& request, ::LOPQPredictResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::LOPQPredictResponse>> AsyncLOPQPredict(::grpc::ClientContext* context, const ::LOPQPredictRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::LOPQPredictResponse>>(AsyncLOPQPredictRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::LOPQPredictResponse>> PrepareAsyncLOPQPredict(::grpc::ClientContext* context, const ::LOPQPredictRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::LOPQPredictResponse>>(PrepareAsyncLOPQPredictRaw(context, request, cq));
    }
    ::grpc::Status LOPQSearch(::grpc::ClientContext* context, const ::LOPQSearchRequest& request, ::LOPQSearchResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::LOPQSearchResponse>> AsyncLOPQSearch(::grpc::ClientContext* context, const ::LOPQSearchRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::LOPQSearchResponse>>(AsyncLOPQSearchRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::LOPQSearchResponse>> PrepareAsyncLOPQSearch(::grpc::ClientContext* context, const ::LOPQSearchRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::LOPQSearchResponse>>(PrepareAsyncLOPQSearchRaw(context, request, cq));
    }
    ::grpc::Status LOPQAttributeSearch(::grpc::ClientContext* context, const ::LOPQAttributeSearchRequest& request, ::LOPQSearchResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::LOPQSearchResponse>> AsyncLOPQAttributeSearch(::grpc::ClientContext* context, const ::LOPQAttributeSearchRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::LOPQSearchResponse>>(AsyncLOPQAttributeSearchRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::LOPQSearchResponse>> PrepareAsyncLOPQAttributeSearch(::grpc::ClientContext* context, const ::LOPQAttributeSearchRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::LOPQSearchResponse>>(PrepareAsyncLOPQAttributeSearchRaw(context, request, cq));
    }
    ::grpc::Status LOPQSearchForCodes(::grpc::ClientContext* context, const ::LOPQSearchForCodesRequest& request, ::LOPQSearchForCodesResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::LOPQSearchForCodesResponse>> AsyncLOPQSearchForCodes(::grpc::ClientContext* context, const ::LOPQSearchForCodesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::LOPQSearchForCodesResponse>>(AsyncLOPQSearchForCodesRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::LOPQSearchForCodesResponse>> PrepareAsyncLOPQSearchForCodes(::grpc::ClientContext* context, const ::LOPQSearchForCodesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::LOPQSearchForCodesResponse>>(PrepareAsyncLOPQSearchForCodesRaw(context, request, cq));
    }
    ::grpc::Status LOPQBruteForceSearch(::grpc::ClientContext* context, const ::LOPQBruteForceSearchRequest& request, ::LOPQBruteForceSearchResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::LOPQBruteForceSearchResponse>> AsyncLOPQBruteForceSearch(::grpc::ClientContext* context, const ::LOPQBruteForceSearchRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::LOPQBruteForceSearchResponse>>(AsyncLOPQBruteForceSearchRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::LOPQBruteForceSearchResponse>> PrepareAsyncLOPQBruteForceSearch(::grpc::ClientContext* context, const ::LOPQBruteForceSearchRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::LOPQBruteForceSearchResponse>>(PrepareAsyncLOPQBruteForceSearchRaw(context, request, cq));
    }
    ::grpc::Status LOPQTrain(::grpc::ClientContext* context, const ::LOPQTrainRequest& request, ::LOPQTrainResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::LOPQTrainResponse>> AsyncLOPQTrain(::grpc::ClientContext* context, const ::LOPQTrainRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::LOPQTrainResponse>>(AsyncLOPQTrainRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::LOPQTrainResponse>> PrepareAsyncLOPQTrain(::grpc::ClientContext* context, const ::LOPQTrainRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::LOPQTrainResponse>>(PrepareAsyncLOPQTrainRaw(context, request, cq));
    }
    ::grpc::Status LOPQTrainAndEval(::grpc::ClientContext* context, const ::LOPQTrainAndEvalRequest& request, ::LOPQTrainAndEvalResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::LOPQTrainAndEvalResponse>> AsyncLOPQTrainAndEval(::grpc::ClientContext* context, const ::LOPQTrainAndEvalRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::LOPQTrainAndEvalResponse>>(AsyncLOPQTrainAndEvalRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::LOPQTrainAndEvalResponse>> PrepareAsyncLOPQTrainAndEval(::grpc::ClientContext* context, const ::LOPQTrainAndEvalRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::LOPQTrainAndEvalResponse>>(PrepareAsyncLOPQTrainAndEvalRaw(context, request, cq));
    }
    class experimental_async final :
      public StubInterface::experimental_async_interface {
     public:
      void LOPQPredict(::grpc::ClientContext* context, const ::LOPQPredictRequest* request, ::LOPQPredictResponse* response, std::function<void(::grpc::Status)>) override;
      void LOPQPredict(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::LOPQPredictResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void LOPQPredict(::grpc::ClientContext* context, const ::LOPQPredictRequest* request, ::LOPQPredictResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void LOPQPredict(::grpc::ClientContext* context, const ::LOPQPredictRequest* request, ::LOPQPredictResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void LOPQPredict(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::LOPQPredictResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void LOPQPredict(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::LOPQPredictResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void LOPQSearch(::grpc::ClientContext* context, const ::LOPQSearchRequest* request, ::LOPQSearchResponse* response, std::function<void(::grpc::Status)>) override;
      void LOPQSearch(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::LOPQSearchResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void LOPQSearch(::grpc::ClientContext* context, const ::LOPQSearchRequest* request, ::LOPQSearchResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void LOPQSearch(::grpc::ClientContext* context, const ::LOPQSearchRequest* request, ::LOPQSearchResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void LOPQSearch(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::LOPQSearchResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void LOPQSearch(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::LOPQSearchResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void LOPQAttributeSearch(::grpc::ClientContext* context, const ::LOPQAttributeSearchRequest* request, ::LOPQSearchResponse* response, std::function<void(::grpc::Status)>) override;
      void LOPQAttributeSearch(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::LOPQSearchResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void LOPQAttributeSearch(::grpc::ClientContext* context, const ::LOPQAttributeSearchRequest* request, ::LOPQSearchResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void LOPQAttributeSearch(::grpc::ClientContext* context, const ::LOPQAttributeSearchRequest* request, ::LOPQSearchResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void LOPQAttributeSearch(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::LOPQSearchResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void LOPQAttributeSearch(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::LOPQSearchResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void LOPQSearchForCodes(::grpc::ClientContext* context, const ::LOPQSearchForCodesRequest* request, ::LOPQSearchForCodesResponse* response, std::function<void(::grpc::Status)>) override;
      void LOPQSearchForCodes(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::LOPQSearchForCodesResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void LOPQSearchForCodes(::grpc::ClientContext* context, const ::LOPQSearchForCodesRequest* request, ::LOPQSearchForCodesResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void LOPQSearchForCodes(::grpc::ClientContext* context, const ::LOPQSearchForCodesRequest* request, ::LOPQSearchForCodesResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void LOPQSearchForCodes(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::LOPQSearchForCodesResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void LOPQSearchForCodes(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::LOPQSearchForCodesResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void LOPQBruteForceSearch(::grpc::ClientContext* context, const ::LOPQBruteForceSearchRequest* request, ::LOPQBruteForceSearchResponse* response, std::function<void(::grpc::Status)>) override;
      void LOPQBruteForceSearch(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::LOPQBruteForceSearchResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void LOPQBruteForceSearch(::grpc::ClientContext* context, const ::LOPQBruteForceSearchRequest* request, ::LOPQBruteForceSearchResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void LOPQBruteForceSearch(::grpc::ClientContext* context, const ::LOPQBruteForceSearchRequest* request, ::LOPQBruteForceSearchResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void LOPQBruteForceSearch(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::LOPQBruteForceSearchResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void LOPQBruteForceSearch(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::LOPQBruteForceSearchResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void LOPQTrain(::grpc::ClientContext* context, const ::LOPQTrainRequest* request, ::LOPQTrainResponse* response, std::function<void(::grpc::Status)>) override;
      void LOPQTrain(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::LOPQTrainResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void LOPQTrain(::grpc::ClientContext* context, const ::LOPQTrainRequest* request, ::LOPQTrainResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void LOPQTrain(::grpc::ClientContext* context, const ::LOPQTrainRequest* request, ::LOPQTrainResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void LOPQTrain(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::LOPQTrainResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void LOPQTrain(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::LOPQTrainResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void LOPQTrainAndEval(::grpc::ClientContext* context, const ::LOPQTrainAndEvalRequest* request, ::LOPQTrainAndEvalResponse* response, std::function<void(::grpc::Status)>) override;
      void LOPQTrainAndEval(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::LOPQTrainAndEvalResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void LOPQTrainAndEval(::grpc::ClientContext* context, const ::LOPQTrainAndEvalRequest* request, ::LOPQTrainAndEvalResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void LOPQTrainAndEval(::grpc::ClientContext* context, const ::LOPQTrainAndEvalRequest* request, ::LOPQTrainAndEvalResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void LOPQTrainAndEval(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::LOPQTrainAndEvalResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void LOPQTrainAndEval(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::LOPQTrainAndEvalResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
     private:
      friend class Stub;
      explicit experimental_async(Stub* stub): stub_(stub) { }
      Stub* stub() { return stub_; }
      Stub* stub_;
    };
    class experimental_async_interface* experimental_async() override { return &async_stub_; }

   private:
    std::shared_ptr< ::grpc::ChannelInterface> channel_;
    class experimental_async async_stub_{this};
    ::grpc::ClientAsyncResponseReader< ::LOPQPredictResponse>* AsyncLOPQPredictRaw(::grpc::ClientContext* context, const ::LOPQPredictRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::LOPQPredictResponse>* PrepareAsyncLOPQPredictRaw(::grpc::ClientContext* context, const ::LOPQPredictRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::LOPQSearchResponse>* AsyncLOPQSearchRaw(::grpc::ClientContext* context, const ::LOPQSearchRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::LOPQSearchResponse>* PrepareAsyncLOPQSearchRaw(::grpc::ClientContext* context, const ::LOPQSearchRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::LOPQSearchResponse>* AsyncLOPQAttributeSearchRaw(::grpc::ClientContext* context, const ::LOPQAttributeSearchRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::LOPQSearchResponse>* PrepareAsyncLOPQAttributeSearchRaw(::grpc::ClientContext* context, const ::LOPQAttributeSearchRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::LOPQSearchForCodesResponse>* AsyncLOPQSearchForCodesRaw(::grpc::ClientContext* context, const ::LOPQSearchForCodesRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::LOPQSearchForCodesResponse>* PrepareAsyncLOPQSearchForCodesRaw(::grpc::ClientContext* context, const ::LOPQSearchForCodesRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::LOPQBruteForceSearchResponse>* AsyncLOPQBruteForceSearchRaw(::grpc::ClientContext* context, const ::LOPQBruteForceSearchRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::LOPQBruteForceSearchResponse>* PrepareAsyncLOPQBruteForceSearchRaw(::grpc::ClientContext* context, const ::LOPQBruteForceSearchRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::LOPQTrainResponse>* AsyncLOPQTrainRaw(::grpc::ClientContext* context, const ::LOPQTrainRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::LOPQTrainResponse>* PrepareAsyncLOPQTrainRaw(::grpc::ClientContext* context, const ::LOPQTrainRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::LOPQTrainAndEvalResponse>* AsyncLOPQTrainAndEvalRaw(::grpc::ClientContext* context, const ::LOPQTrainAndEvalRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::LOPQTrainAndEvalResponse>* PrepareAsyncLOPQTrainAndEvalRaw(::grpc::ClientContext* context, const ::LOPQTrainAndEvalRequest& request, ::grpc::CompletionQueue* cq) override;
    const ::grpc::internal::RpcMethod rpcmethod_LOPQPredict_;
    const ::grpc::internal::RpcMethod rpcmethod_LOPQSearch_;
    const ::grpc::internal::RpcMethod rpcmethod_LOPQAttributeSearch_;
    const ::grpc::internal::RpcMethod rpcmethod_LOPQSearchForCodes_;
    const ::grpc::internal::RpcMethod rpcmethod_LOPQBruteForceSearch_;
    const ::grpc::internal::RpcMethod rpcmethod_LOPQTrain_;
    const ::grpc::internal::RpcMethod rpcmethod_LOPQTrainAndEval_;
  };
  static std::unique_ptr<Stub> NewStub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());

  class Service : public ::grpc::Service {
   public:
    Service();
    virtual ~Service();
    // Predicts the LOPQ codes for given embeddings for a LOPQ model
    virtual ::grpc::Status LOPQPredict(::grpc::ServerContext* context, const ::LOPQPredictRequest* request, ::LOPQPredictResponse* response);
    // Searches for embeddings given an optional SQL template to only consider a subset of assets for a LOPQ model
    virtual ::grpc::Status LOPQSearch(::grpc::ServerContext* context, const ::LOPQSearchRequest* request, ::LOPQSearchResponse* response);
    // Searches for embeddings and attributes given a SQL template and custom models to weight results
    virtual ::grpc::Status LOPQAttributeSearch(::grpc::ServerContext* context, const ::LOPQAttributeSearchRequest* request, ::LOPQSearchResponse* response);
    // Searches for embeddings given a LOPQ model returning LOPQ coarse keys and distances only
    virtual ::grpc::Status LOPQSearchForCodes(::grpc::ServerContext* context, const ::LOPQSearchForCodesRequest* request, ::LOPQSearchForCodesResponse* response);
    // Brute force search for nearest neighbors of query embeddings.
    virtual ::grpc::Status LOPQBruteForceSearch(::grpc::ServerContext* context, const ::LOPQBruteForceSearchRequest* request, ::LOPQBruteForceSearchResponse* response);
    // LOPQTrain by iterating over database and then save model to s3.
    virtual ::grpc::Status LOPQTrain(::grpc::ServerContext* context, const ::LOPQTrainRequest* request, ::LOPQTrainResponse* response);
    // Evaluates a LOPQ model by comparing to brute force for a set of sample query embeddings.
    virtual ::grpc::Status LOPQTrainAndEval(::grpc::ServerContext* context, const ::LOPQTrainAndEvalRequest* request, ::LOPQTrainAndEvalResponse* response);
  };
  template <class BaseClass>
  class WithAsyncMethod_LOPQPredict : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_LOPQPredict() {
      ::grpc::Service::MarkMethodAsync(0);
    }
    ~WithAsyncMethod_LOPQPredict() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status LOPQPredict(::grpc::ServerContext* /*context*/, const ::LOPQPredictRequest* /*request*/, ::LOPQPredictResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestLOPQPredict(::grpc::ServerContext* context, ::LOPQPredictRequest* request, ::grpc::ServerAsyncResponseWriter< ::LOPQPredictResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_LOPQSearch : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_LOPQSearch() {
      ::grpc::Service::MarkMethodAsync(1);
    }
    ~WithAsyncMethod_LOPQSearch() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status LOPQSearch(::grpc::ServerContext* /*context*/, const ::LOPQSearchRequest* /*request*/, ::LOPQSearchResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestLOPQSearch(::grpc::ServerContext* context, ::LOPQSearchRequest* request, ::grpc::ServerAsyncResponseWriter< ::LOPQSearchResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_LOPQAttributeSearch : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_LOPQAttributeSearch() {
      ::grpc::Service::MarkMethodAsync(2);
    }
    ~WithAsyncMethod_LOPQAttributeSearch() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status LOPQAttributeSearch(::grpc::ServerContext* /*context*/, const ::LOPQAttributeSearchRequest* /*request*/, ::LOPQSearchResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestLOPQAttributeSearch(::grpc::ServerContext* context, ::LOPQAttributeSearchRequest* request, ::grpc::ServerAsyncResponseWriter< ::LOPQSearchResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(2, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_LOPQSearchForCodes : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_LOPQSearchForCodes() {
      ::grpc::Service::MarkMethodAsync(3);
    }
    ~WithAsyncMethod_LOPQSearchForCodes() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status LOPQSearchForCodes(::grpc::ServerContext* /*context*/, const ::LOPQSearchForCodesRequest* /*request*/, ::LOPQSearchForCodesResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestLOPQSearchForCodes(::grpc::ServerContext* context, ::LOPQSearchForCodesRequest* request, ::grpc::ServerAsyncResponseWriter< ::LOPQSearchForCodesResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(3, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_LOPQBruteForceSearch : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_LOPQBruteForceSearch() {
      ::grpc::Service::MarkMethodAsync(4);
    }
    ~WithAsyncMethod_LOPQBruteForceSearch() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status LOPQBruteForceSearch(::grpc::ServerContext* /*context*/, const ::LOPQBruteForceSearchRequest* /*request*/, ::LOPQBruteForceSearchResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestLOPQBruteForceSearch(::grpc::ServerContext* context, ::LOPQBruteForceSearchRequest* request, ::grpc::ServerAsyncResponseWriter< ::LOPQBruteForceSearchResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(4, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_LOPQTrain : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_LOPQTrain() {
      ::grpc::Service::MarkMethodAsync(5);
    }
    ~WithAsyncMethod_LOPQTrain() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status LOPQTrain(::grpc::ServerContext* /*context*/, const ::LOPQTrainRequest* /*request*/, ::LOPQTrainResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestLOPQTrain(::grpc::ServerContext* context, ::LOPQTrainRequest* request, ::grpc::ServerAsyncResponseWriter< ::LOPQTrainResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(5, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_LOPQTrainAndEval : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_LOPQTrainAndEval() {
      ::grpc::Service::MarkMethodAsync(6);
    }
    ~WithAsyncMethod_LOPQTrainAndEval() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status LOPQTrainAndEval(::grpc::ServerContext* /*context*/, const ::LOPQTrainAndEvalRequest* /*request*/, ::LOPQTrainAndEvalResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestLOPQTrainAndEval(::grpc::ServerContext* context, ::LOPQTrainAndEvalRequest* request, ::grpc::ServerAsyncResponseWriter< ::LOPQTrainAndEvalResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(6, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  typedef WithAsyncMethod_LOPQPredict<WithAsyncMethod_LOPQSearch<WithAsyncMethod_LOPQAttributeSearch<WithAsyncMethod_LOPQSearchForCodes<WithAsyncMethod_LOPQBruteForceSearch<WithAsyncMethod_LOPQTrain<WithAsyncMethod_LOPQTrainAndEval<Service > > > > > > > AsyncService;
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_LOPQPredict : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_LOPQPredict() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(0,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::LOPQPredictRequest, ::LOPQPredictResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::LOPQPredictRequest* request, ::LOPQPredictResponse* response) { return this->LOPQPredict(context, request, response); }));}
    void SetMessageAllocatorFor_LOPQPredict(
        ::grpc::experimental::MessageAllocator< ::LOPQPredictRequest, ::LOPQPredictResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(0);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(0);
    #endif
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::LOPQPredictRequest, ::LOPQPredictResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_LOPQPredict() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status LOPQPredict(::grpc::ServerContext* /*context*/, const ::LOPQPredictRequest* /*request*/, ::LOPQPredictResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* LOPQPredict(
      ::grpc::CallbackServerContext* /*context*/, const ::LOPQPredictRequest* /*request*/, ::LOPQPredictResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* LOPQPredict(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::LOPQPredictRequest* /*request*/, ::LOPQPredictResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_LOPQSearch : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_LOPQSearch() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(1,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::LOPQSearchRequest, ::LOPQSearchResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::LOPQSearchRequest* request, ::LOPQSearchResponse* response) { return this->LOPQSearch(context, request, response); }));}
    void SetMessageAllocatorFor_LOPQSearch(
        ::grpc::experimental::MessageAllocator< ::LOPQSearchRequest, ::LOPQSearchResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(1);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(1);
    #endif
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::LOPQSearchRequest, ::LOPQSearchResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_LOPQSearch() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status LOPQSearch(::grpc::ServerContext* /*context*/, const ::LOPQSearchRequest* /*request*/, ::LOPQSearchResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* LOPQSearch(
      ::grpc::CallbackServerContext* /*context*/, const ::LOPQSearchRequest* /*request*/, ::LOPQSearchResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* LOPQSearch(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::LOPQSearchRequest* /*request*/, ::LOPQSearchResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_LOPQAttributeSearch : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_LOPQAttributeSearch() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(2,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::LOPQAttributeSearchRequest, ::LOPQSearchResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::LOPQAttributeSearchRequest* request, ::LOPQSearchResponse* response) { return this->LOPQAttributeSearch(context, request, response); }));}
    void SetMessageAllocatorFor_LOPQAttributeSearch(
        ::grpc::experimental::MessageAllocator< ::LOPQAttributeSearchRequest, ::LOPQSearchResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(2);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(2);
    #endif
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::LOPQAttributeSearchRequest, ::LOPQSearchResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_LOPQAttributeSearch() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status LOPQAttributeSearch(::grpc::ServerContext* /*context*/, const ::LOPQAttributeSearchRequest* /*request*/, ::LOPQSearchResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* LOPQAttributeSearch(
      ::grpc::CallbackServerContext* /*context*/, const ::LOPQAttributeSearchRequest* /*request*/, ::LOPQSearchResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* LOPQAttributeSearch(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::LOPQAttributeSearchRequest* /*request*/, ::LOPQSearchResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_LOPQSearchForCodes : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_LOPQSearchForCodes() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(3,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::LOPQSearchForCodesRequest, ::LOPQSearchForCodesResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::LOPQSearchForCodesRequest* request, ::LOPQSearchForCodesResponse* response) { return this->LOPQSearchForCodes(context, request, response); }));}
    void SetMessageAllocatorFor_LOPQSearchForCodes(
        ::grpc::experimental::MessageAllocator< ::LOPQSearchForCodesRequest, ::LOPQSearchForCodesResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(3);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(3);
    #endif
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::LOPQSearchForCodesRequest, ::LOPQSearchForCodesResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_LOPQSearchForCodes() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status LOPQSearchForCodes(::grpc::ServerContext* /*context*/, const ::LOPQSearchForCodesRequest* /*request*/, ::LOPQSearchForCodesResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* LOPQSearchForCodes(
      ::grpc::CallbackServerContext* /*context*/, const ::LOPQSearchForCodesRequest* /*request*/, ::LOPQSearchForCodesResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* LOPQSearchForCodes(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::LOPQSearchForCodesRequest* /*request*/, ::LOPQSearchForCodesResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_LOPQBruteForceSearch : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_LOPQBruteForceSearch() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(4,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::LOPQBruteForceSearchRequest, ::LOPQBruteForceSearchResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::LOPQBruteForceSearchRequest* request, ::LOPQBruteForceSearchResponse* response) { return this->LOPQBruteForceSearch(context, request, response); }));}
    void SetMessageAllocatorFor_LOPQBruteForceSearch(
        ::grpc::experimental::MessageAllocator< ::LOPQBruteForceSearchRequest, ::LOPQBruteForceSearchResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(4);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(4);
    #endif
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::LOPQBruteForceSearchRequest, ::LOPQBruteForceSearchResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_LOPQBruteForceSearch() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status LOPQBruteForceSearch(::grpc::ServerContext* /*context*/, const ::LOPQBruteForceSearchRequest* /*request*/, ::LOPQBruteForceSearchResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* LOPQBruteForceSearch(
      ::grpc::CallbackServerContext* /*context*/, const ::LOPQBruteForceSearchRequest* /*request*/, ::LOPQBruteForceSearchResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* LOPQBruteForceSearch(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::LOPQBruteForceSearchRequest* /*request*/, ::LOPQBruteForceSearchResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_LOPQTrain : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_LOPQTrain() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(5,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::LOPQTrainRequest, ::LOPQTrainResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::LOPQTrainRequest* request, ::LOPQTrainResponse* response) { return this->LOPQTrain(context, request, response); }));}
    void SetMessageAllocatorFor_LOPQTrain(
        ::grpc::experimental::MessageAllocator< ::LOPQTrainRequest, ::LOPQTrainResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(5);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(5);
    #endif
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::LOPQTrainRequest, ::LOPQTrainResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_LOPQTrain() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status LOPQTrain(::grpc::ServerContext* /*context*/, const ::LOPQTrainRequest* /*request*/, ::LOPQTrainResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* LOPQTrain(
      ::grpc::CallbackServerContext* /*context*/, const ::LOPQTrainRequest* /*request*/, ::LOPQTrainResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* LOPQTrain(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::LOPQTrainRequest* /*request*/, ::LOPQTrainResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_LOPQTrainAndEval : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_LOPQTrainAndEval() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(6,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::LOPQTrainAndEvalRequest, ::LOPQTrainAndEvalResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::LOPQTrainAndEvalRequest* request, ::LOPQTrainAndEvalResponse* response) { return this->LOPQTrainAndEval(context, request, response); }));}
    void SetMessageAllocatorFor_LOPQTrainAndEval(
        ::grpc::experimental::MessageAllocator< ::LOPQTrainAndEvalRequest, ::LOPQTrainAndEvalResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(6);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(6);
    #endif
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::LOPQTrainAndEvalRequest, ::LOPQTrainAndEvalResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_LOPQTrainAndEval() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status LOPQTrainAndEval(::grpc::ServerContext* /*context*/, const ::LOPQTrainAndEvalRequest* /*request*/, ::LOPQTrainAndEvalResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* LOPQTrainAndEval(
      ::grpc::CallbackServerContext* /*context*/, const ::LOPQTrainAndEvalRequest* /*request*/, ::LOPQTrainAndEvalResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* LOPQTrainAndEval(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::LOPQTrainAndEvalRequest* /*request*/, ::LOPQTrainAndEvalResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
  typedef ExperimentalWithCallbackMethod_LOPQPredict<ExperimentalWithCallbackMethod_LOPQSearch<ExperimentalWithCallbackMethod_LOPQAttributeSearch<ExperimentalWithCallbackMethod_LOPQSearchForCodes<ExperimentalWithCallbackMethod_LOPQBruteForceSearch<ExperimentalWithCallbackMethod_LOPQTrain<ExperimentalWithCallbackMethod_LOPQTrainAndEval<Service > > > > > > > CallbackService;
  #endif

  typedef ExperimentalWithCallbackMethod_LOPQPredict<ExperimentalWithCallbackMethod_LOPQSearch<ExperimentalWithCallbackMethod_LOPQAttributeSearch<ExperimentalWithCallbackMethod_LOPQSearchForCodes<ExperimentalWithCallbackMethod_LOPQBruteForceSearch<ExperimentalWithCallbackMethod_LOPQTrain<ExperimentalWithCallbackMethod_LOPQTrainAndEval<Service > > > > > > > ExperimentalCallbackService;
  template <class BaseClass>
  class WithGenericMethod_LOPQPredict : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_LOPQPredict() {
      ::grpc::Service::MarkMethodGeneric(0);
    }
    ~WithGenericMethod_LOPQPredict() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status LOPQPredict(::grpc::ServerContext* /*context*/, const ::LOPQPredictRequest* /*request*/, ::LOPQPredictResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_LOPQSearch : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_LOPQSearch() {
      ::grpc::Service::MarkMethodGeneric(1);
    }
    ~WithGenericMethod_LOPQSearch() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status LOPQSearch(::grpc::ServerContext* /*context*/, const ::LOPQSearchRequest* /*request*/, ::LOPQSearchResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_LOPQAttributeSearch : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_LOPQAttributeSearch() {
      ::grpc::Service::MarkMethodGeneric(2);
    }
    ~WithGenericMethod_LOPQAttributeSearch() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status LOPQAttributeSearch(::grpc::ServerContext* /*context*/, const ::LOPQAttributeSearchRequest* /*request*/, ::LOPQSearchResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_LOPQSearchForCodes : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_LOPQSearchForCodes() {
      ::grpc::Service::MarkMethodGeneric(3);
    }
    ~WithGenericMethod_LOPQSearchForCodes() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status LOPQSearchForCodes(::grpc::ServerContext* /*context*/, const ::LOPQSearchForCodesRequest* /*request*/, ::LOPQSearchForCodesResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_LOPQBruteForceSearch : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_LOPQBruteForceSearch() {
      ::grpc::Service::MarkMethodGeneric(4);
    }
    ~WithGenericMethod_LOPQBruteForceSearch() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status LOPQBruteForceSearch(::grpc::ServerContext* /*context*/, const ::LOPQBruteForceSearchRequest* /*request*/, ::LOPQBruteForceSearchResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_LOPQTrain : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_LOPQTrain() {
      ::grpc::Service::MarkMethodGeneric(5);
    }
    ~WithGenericMethod_LOPQTrain() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status LOPQTrain(::grpc::ServerContext* /*context*/, const ::LOPQTrainRequest* /*request*/, ::LOPQTrainResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_LOPQTrainAndEval : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_LOPQTrainAndEval() {
      ::grpc::Service::MarkMethodGeneric(6);
    }
    ~WithGenericMethod_LOPQTrainAndEval() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status LOPQTrainAndEval(::grpc::ServerContext* /*context*/, const ::LOPQTrainAndEvalRequest* /*request*/, ::LOPQTrainAndEvalResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithRawMethod_LOPQPredict : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_LOPQPredict() {
      ::grpc::Service::MarkMethodRaw(0);
    }
    ~WithRawMethod_LOPQPredict() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status LOPQPredict(::grpc::ServerContext* /*context*/, const ::LOPQPredictRequest* /*request*/, ::LOPQPredictResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestLOPQPredict(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_LOPQSearch : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_LOPQSearch() {
      ::grpc::Service::MarkMethodRaw(1);
    }
    ~WithRawMethod_LOPQSearch() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status LOPQSearch(::grpc::ServerContext* /*context*/, const ::LOPQSearchRequest* /*request*/, ::LOPQSearchResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestLOPQSearch(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_LOPQAttributeSearch : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_LOPQAttributeSearch() {
      ::grpc::Service::MarkMethodRaw(2);
    }
    ~WithRawMethod_LOPQAttributeSearch() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status LOPQAttributeSearch(::grpc::ServerContext* /*context*/, const ::LOPQAttributeSearchRequest* /*request*/, ::LOPQSearchResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestLOPQAttributeSearch(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(2, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_LOPQSearchForCodes : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_LOPQSearchForCodes() {
      ::grpc::Service::MarkMethodRaw(3);
    }
    ~WithRawMethod_LOPQSearchForCodes() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status LOPQSearchForCodes(::grpc::ServerContext* /*context*/, const ::LOPQSearchForCodesRequest* /*request*/, ::LOPQSearchForCodesResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestLOPQSearchForCodes(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(3, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_LOPQBruteForceSearch : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_LOPQBruteForceSearch() {
      ::grpc::Service::MarkMethodRaw(4);
    }
    ~WithRawMethod_LOPQBruteForceSearch() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status LOPQBruteForceSearch(::grpc::ServerContext* /*context*/, const ::LOPQBruteForceSearchRequest* /*request*/, ::LOPQBruteForceSearchResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestLOPQBruteForceSearch(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(4, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_LOPQTrain : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_LOPQTrain() {
      ::grpc::Service::MarkMethodRaw(5);
    }
    ~WithRawMethod_LOPQTrain() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status LOPQTrain(::grpc::ServerContext* /*context*/, const ::LOPQTrainRequest* /*request*/, ::LOPQTrainResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestLOPQTrain(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(5, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_LOPQTrainAndEval : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_LOPQTrainAndEval() {
      ::grpc::Service::MarkMethodRaw(6);
    }
    ~WithRawMethod_LOPQTrainAndEval() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status LOPQTrainAndEval(::grpc::ServerContext* /*context*/, const ::LOPQTrainAndEvalRequest* /*request*/, ::LOPQTrainAndEvalResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestLOPQTrainAndEval(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(6, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_LOPQPredict : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_LOPQPredict() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(0,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->LOPQPredict(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_LOPQPredict() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status LOPQPredict(::grpc::ServerContext* /*context*/, const ::LOPQPredictRequest* /*request*/, ::LOPQPredictResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* LOPQPredict(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* LOPQPredict(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_LOPQSearch : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_LOPQSearch() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(1,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->LOPQSearch(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_LOPQSearch() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status LOPQSearch(::grpc::ServerContext* /*context*/, const ::LOPQSearchRequest* /*request*/, ::LOPQSearchResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* LOPQSearch(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* LOPQSearch(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_LOPQAttributeSearch : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_LOPQAttributeSearch() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(2,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->LOPQAttributeSearch(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_LOPQAttributeSearch() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status LOPQAttributeSearch(::grpc::ServerContext* /*context*/, const ::LOPQAttributeSearchRequest* /*request*/, ::LOPQSearchResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* LOPQAttributeSearch(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* LOPQAttributeSearch(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_LOPQSearchForCodes : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_LOPQSearchForCodes() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(3,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->LOPQSearchForCodes(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_LOPQSearchForCodes() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status LOPQSearchForCodes(::grpc::ServerContext* /*context*/, const ::LOPQSearchForCodesRequest* /*request*/, ::LOPQSearchForCodesResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* LOPQSearchForCodes(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* LOPQSearchForCodes(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_LOPQBruteForceSearch : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_LOPQBruteForceSearch() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(4,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->LOPQBruteForceSearch(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_LOPQBruteForceSearch() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status LOPQBruteForceSearch(::grpc::ServerContext* /*context*/, const ::LOPQBruteForceSearchRequest* /*request*/, ::LOPQBruteForceSearchResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* LOPQBruteForceSearch(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* LOPQBruteForceSearch(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_LOPQTrain : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_LOPQTrain() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(5,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->LOPQTrain(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_LOPQTrain() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status LOPQTrain(::grpc::ServerContext* /*context*/, const ::LOPQTrainRequest* /*request*/, ::LOPQTrainResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* LOPQTrain(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* LOPQTrain(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_LOPQTrainAndEval : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_LOPQTrainAndEval() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(6,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->LOPQTrainAndEval(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_LOPQTrainAndEval() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status LOPQTrainAndEval(::grpc::ServerContext* /*context*/, const ::LOPQTrainAndEvalRequest* /*request*/, ::LOPQTrainAndEvalResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* LOPQTrainAndEval(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* LOPQTrainAndEval(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_LOPQPredict : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_LOPQPredict() {
      ::grpc::Service::MarkMethodStreamed(0,
        new ::grpc::internal::StreamedUnaryHandler<
          ::LOPQPredictRequest, ::LOPQPredictResponse>(
            [this](::grpc_impl::ServerContext* context,
                   ::grpc_impl::ServerUnaryStreamer<
                     ::LOPQPredictRequest, ::LOPQPredictResponse>* streamer) {
                       return this->StreamedLOPQPredict(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_LOPQPredict() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status LOPQPredict(::grpc::ServerContext* /*context*/, const ::LOPQPredictRequest* /*request*/, ::LOPQPredictResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedLOPQPredict(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::LOPQPredictRequest,::LOPQPredictResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_LOPQSearch : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_LOPQSearch() {
      ::grpc::Service::MarkMethodStreamed(1,
        new ::grpc::internal::StreamedUnaryHandler<
          ::LOPQSearchRequest, ::LOPQSearchResponse>(
            [this](::grpc_impl::ServerContext* context,
                   ::grpc_impl::ServerUnaryStreamer<
                     ::LOPQSearchRequest, ::LOPQSearchResponse>* streamer) {
                       return this->StreamedLOPQSearch(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_LOPQSearch() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status LOPQSearch(::grpc::ServerContext* /*context*/, const ::LOPQSearchRequest* /*request*/, ::LOPQSearchResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedLOPQSearch(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::LOPQSearchRequest,::LOPQSearchResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_LOPQAttributeSearch : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_LOPQAttributeSearch() {
      ::grpc::Service::MarkMethodStreamed(2,
        new ::grpc::internal::StreamedUnaryHandler<
          ::LOPQAttributeSearchRequest, ::LOPQSearchResponse>(
            [this](::grpc_impl::ServerContext* context,
                   ::grpc_impl::ServerUnaryStreamer<
                     ::LOPQAttributeSearchRequest, ::LOPQSearchResponse>* streamer) {
                       return this->StreamedLOPQAttributeSearch(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_LOPQAttributeSearch() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status LOPQAttributeSearch(::grpc::ServerContext* /*context*/, const ::LOPQAttributeSearchRequest* /*request*/, ::LOPQSearchResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedLOPQAttributeSearch(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::LOPQAttributeSearchRequest,::LOPQSearchResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_LOPQSearchForCodes : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_LOPQSearchForCodes() {
      ::grpc::Service::MarkMethodStreamed(3,
        new ::grpc::internal::StreamedUnaryHandler<
          ::LOPQSearchForCodesRequest, ::LOPQSearchForCodesResponse>(
            [this](::grpc_impl::ServerContext* context,
                   ::grpc_impl::ServerUnaryStreamer<
                     ::LOPQSearchForCodesRequest, ::LOPQSearchForCodesResponse>* streamer) {
                       return this->StreamedLOPQSearchForCodes(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_LOPQSearchForCodes() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status LOPQSearchForCodes(::grpc::ServerContext* /*context*/, const ::LOPQSearchForCodesRequest* /*request*/, ::LOPQSearchForCodesResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedLOPQSearchForCodes(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::LOPQSearchForCodesRequest,::LOPQSearchForCodesResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_LOPQBruteForceSearch : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_LOPQBruteForceSearch() {
      ::grpc::Service::MarkMethodStreamed(4,
        new ::grpc::internal::StreamedUnaryHandler<
          ::LOPQBruteForceSearchRequest, ::LOPQBruteForceSearchResponse>(
            [this](::grpc_impl::ServerContext* context,
                   ::grpc_impl::ServerUnaryStreamer<
                     ::LOPQBruteForceSearchRequest, ::LOPQBruteForceSearchResponse>* streamer) {
                       return this->StreamedLOPQBruteForceSearch(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_LOPQBruteForceSearch() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status LOPQBruteForceSearch(::grpc::ServerContext* /*context*/, const ::LOPQBruteForceSearchRequest* /*request*/, ::LOPQBruteForceSearchResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedLOPQBruteForceSearch(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::LOPQBruteForceSearchRequest,::LOPQBruteForceSearchResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_LOPQTrain : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_LOPQTrain() {
      ::grpc::Service::MarkMethodStreamed(5,
        new ::grpc::internal::StreamedUnaryHandler<
          ::LOPQTrainRequest, ::LOPQTrainResponse>(
            [this](::grpc_impl::ServerContext* context,
                   ::grpc_impl::ServerUnaryStreamer<
                     ::LOPQTrainRequest, ::LOPQTrainResponse>* streamer) {
                       return this->StreamedLOPQTrain(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_LOPQTrain() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status LOPQTrain(::grpc::ServerContext* /*context*/, const ::LOPQTrainRequest* /*request*/, ::LOPQTrainResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedLOPQTrain(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::LOPQTrainRequest,::LOPQTrainResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_LOPQTrainAndEval : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_LOPQTrainAndEval() {
      ::grpc::Service::MarkMethodStreamed(6,
        new ::grpc::internal::StreamedUnaryHandler<
          ::LOPQTrainAndEvalRequest, ::LOPQTrainAndEvalResponse>(
            [this](::grpc_impl::ServerContext* context,
                   ::grpc_impl::ServerUnaryStreamer<
                     ::LOPQTrainAndEvalRequest, ::LOPQTrainAndEvalResponse>* streamer) {
                       return this->StreamedLOPQTrainAndEval(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_LOPQTrainAndEval() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status LOPQTrainAndEval(::grpc::ServerContext* /*context*/, const ::LOPQTrainAndEvalRequest* /*request*/, ::LOPQTrainAndEvalResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedLOPQTrainAndEval(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::LOPQTrainAndEvalRequest,::LOPQTrainAndEvalResponse>* server_unary_streamer) = 0;
  };
  typedef WithStreamedUnaryMethod_LOPQPredict<WithStreamedUnaryMethod_LOPQSearch<WithStreamedUnaryMethod_LOPQAttributeSearch<WithStreamedUnaryMethod_LOPQSearchForCodes<WithStreamedUnaryMethod_LOPQBruteForceSearch<WithStreamedUnaryMethod_LOPQTrain<WithStreamedUnaryMethod_LOPQTrainAndEval<Service > > > > > > > StreamedUnaryService;
  typedef Service SplitStreamedService;
  typedef WithStreamedUnaryMethod_LOPQPredict<WithStreamedUnaryMethod_LOPQSearch<WithStreamedUnaryMethod_LOPQAttributeSearch<WithStreamedUnaryMethod_LOPQSearchForCodes<WithStreamedUnaryMethod_LOPQBruteForceSearch<WithStreamedUnaryMethod_LOPQTrain<WithStreamedUnaryMethod_LOPQTrainAndEval<Service > > > > > > > StreamedService;
};


#endif  // GRPC_proto_2flopq_2flopq_5fservice_2eproto__INCLUDED
