// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: proto/concept_trainer_dump/concept_trainer_dump.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_proto_2fconcept_5ftrainer_5fdump_2fconcept_5ftrainer_5fdump_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_proto_2fconcept_5ftrainer_5fdump_2fconcept_5ftrainer_5fdump_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3013000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3013000 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/map.h>  // IWYU pragma: export
#include <google/protobuf/map_entry.h>
#include <google/protobuf/map_field_inl.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include <google/protobuf/timestamp.pb.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_proto_2fconcept_5ftrainer_5fdump_2fconcept_5ftrainer_5fdump_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_proto_2fconcept_5ftrainer_5fdump_2fconcept_5ftrainer_5fdump_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[3]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_proto_2fconcept_5ftrainer_5fdump_2fconcept_5ftrainer_5fdump_2eproto;
class ConceptClassifierDump;
class ConceptClassifierDumpDefaultTypeInternal;
extern ConceptClassifierDumpDefaultTypeInternal _ConceptClassifierDump_default_instance_;
class ConceptTrainerDump;
class ConceptTrainerDumpDefaultTypeInternal;
extern ConceptTrainerDumpDefaultTypeInternal _ConceptTrainerDump_default_instance_;
class ConceptTrainerDump_ClassifiersEntry_DoNotUse;
class ConceptTrainerDump_ClassifiersEntry_DoNotUseDefaultTypeInternal;
extern ConceptTrainerDump_ClassifiersEntry_DoNotUseDefaultTypeInternal _ConceptTrainerDump_ClassifiersEntry_DoNotUse_default_instance_;
PROTOBUF_NAMESPACE_OPEN
template<> ::ConceptClassifierDump* Arena::CreateMaybeMessage<::ConceptClassifierDump>(Arena*);
template<> ::ConceptTrainerDump* Arena::CreateMaybeMessage<::ConceptTrainerDump>(Arena*);
template<> ::ConceptTrainerDump_ClassifiersEntry_DoNotUse* Arena::CreateMaybeMessage<::ConceptTrainerDump_ClassifiersEntry_DoNotUse>(Arena*);
PROTOBUF_NAMESPACE_CLOSE

enum TrainingType : int {
  M_VS_N = 0,
  ONE_VS_N = 1,
  TrainingType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  TrainingType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool TrainingType_IsValid(int value);
constexpr TrainingType TrainingType_MIN = M_VS_N;
constexpr TrainingType TrainingType_MAX = ONE_VS_N;
constexpr int TrainingType_ARRAYSIZE = TrainingType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* TrainingType_descriptor();
template<typename T>
inline const std::string& TrainingType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, TrainingType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function TrainingType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    TrainingType_descriptor(), enum_t_value);
}
inline bool TrainingType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, TrainingType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<TrainingType>(
    TrainingType_descriptor(), name, value);
}
enum TrainingEnvironment : int {
  OPEN = 0,
  CLOSED = 1,
  TrainingEnvironment_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  TrainingEnvironment_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool TrainingEnvironment_IsValid(int value);
constexpr TrainingEnvironment TrainingEnvironment_MIN = OPEN;
constexpr TrainingEnvironment TrainingEnvironment_MAX = CLOSED;
constexpr int TrainingEnvironment_ARRAYSIZE = TrainingEnvironment_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* TrainingEnvironment_descriptor();
template<typename T>
inline const std::string& TrainingEnvironment_Name(T enum_t_value) {
  static_assert(::std::is_same<T, TrainingEnvironment>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function TrainingEnvironment_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    TrainingEnvironment_descriptor(), enum_t_value);
}
inline bool TrainingEnvironment_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, TrainingEnvironment* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<TrainingEnvironment>(
    TrainingEnvironment_descriptor(), name, value);
}
enum MissingPositiveExamplePolicy : int {
  SAMPLE_NEGATIVE_EMBEDDINGS = 0,
  DISALLOW = 1,
  MissingPositiveExamplePolicy_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  MissingPositiveExamplePolicy_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool MissingPositiveExamplePolicy_IsValid(int value);
constexpr MissingPositiveExamplePolicy MissingPositiveExamplePolicy_MIN = SAMPLE_NEGATIVE_EMBEDDINGS;
constexpr MissingPositiveExamplePolicy MissingPositiveExamplePolicy_MAX = DISALLOW;
constexpr int MissingPositiveExamplePolicy_ARRAYSIZE = MissingPositiveExamplePolicy_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* MissingPositiveExamplePolicy_descriptor();
template<typename T>
inline const std::string& MissingPositiveExamplePolicy_Name(T enum_t_value) {
  static_assert(::std::is_same<T, MissingPositiveExamplePolicy>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function MissingPositiveExamplePolicy_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    MissingPositiveExamplePolicy_descriptor(), enum_t_value);
}
inline bool MissingPositiveExamplePolicy_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, MissingPositiveExamplePolicy* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<MissingPositiveExamplePolicy>(
    MissingPositiveExamplePolicy_descriptor(), name, value);
}
// ===================================================================

class ConceptTrainerDump_ClassifiersEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<ConceptTrainerDump_ClassifiersEntry_DoNotUse, 
    std::string, ::ConceptClassifierDump,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE,
    0 > {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<ConceptTrainerDump_ClassifiersEntry_DoNotUse, 
    std::string, ::ConceptClassifierDump,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE,
    0 > SuperType;
  ConceptTrainerDump_ClassifiersEntry_DoNotUse();
  explicit ConceptTrainerDump_ClassifiersEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const ConceptTrainerDump_ClassifiersEntry_DoNotUse& other);
  static const ConceptTrainerDump_ClassifiersEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const ConceptTrainerDump_ClassifiersEntry_DoNotUse*>(&_ConceptTrainerDump_ClassifiersEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "ConceptTrainerDump.ClassifiersEntry.key");
 }
  static bool ValidateValue(void*) { return true; }
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& other) final;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_proto_2fconcept_5ftrainer_5fdump_2fconcept_5ftrainer_5fdump_2eproto);
    return ::descriptor_table_proto_2fconcept_5ftrainer_5fdump_2fconcept_5ftrainer_5fdump_2eproto.file_level_metadata[0];
  }

  public:
};

// -------------------------------------------------------------------

class ConceptTrainerDump PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ConceptTrainerDump) */ {
 public:
  inline ConceptTrainerDump() : ConceptTrainerDump(nullptr) {}
  virtual ~ConceptTrainerDump();

  ConceptTrainerDump(const ConceptTrainerDump& from);
  ConceptTrainerDump(ConceptTrainerDump&& from) noexcept
    : ConceptTrainerDump() {
    *this = ::std::move(from);
  }

  inline ConceptTrainerDump& operator=(const ConceptTrainerDump& from) {
    CopyFrom(from);
    return *this;
  }
  inline ConceptTrainerDump& operator=(ConceptTrainerDump&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ConceptTrainerDump& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ConceptTrainerDump* internal_default_instance() {
    return reinterpret_cast<const ConceptTrainerDump*>(
               &_ConceptTrainerDump_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(ConceptTrainerDump& a, ConceptTrainerDump& b) {
    a.Swap(&b);
  }
  inline void Swap(ConceptTrainerDump* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ConceptTrainerDump* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ConceptTrainerDump* New() const final {
    return CreateMaybeMessage<ConceptTrainerDump>(nullptr);
  }

  ConceptTrainerDump* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ConceptTrainerDump>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ConceptTrainerDump& from);
  void MergeFrom(const ConceptTrainerDump& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ConceptTrainerDump* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ConceptTrainerDump";
  }
  protected:
  explicit ConceptTrainerDump(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_proto_2fconcept_5ftrainer_5fdump_2fconcept_5ftrainer_5fdump_2eproto);
    return ::descriptor_table_proto_2fconcept_5ftrainer_5fdump_2fconcept_5ftrainer_5fdump_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kClassifiersFieldNumber = 3,
    kAiidsFieldNumber = 9,
    kConceptIdsFieldNumber = 11,
    kEmbeddingsModelFieldNumber = 4,
    kTfGraphProtoFieldNumber = 7,
    kTfFrozenMetaGraphFieldNumber = 8,
    kUpdateTimeFieldNumber = 2,
    kVersionFieldNumber = 1,
    kTrainingTypeFieldNumber = 5,
    kFeatureNormalizationFieldNumber = 6,
    kTrainingEnvironmentFieldNumber = 10,
    kMissingPositiveExamplePolicyFieldNumber = 12,
  };
  // map<string, .ConceptClassifierDump> classifiers = 3;
  int classifiers_size() const;
  private:
  int _internal_classifiers_size() const;
  public:
  void clear_classifiers();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::ConceptClassifierDump >&
      _internal_classifiers() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::ConceptClassifierDump >*
      _internal_mutable_classifiers();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::ConceptClassifierDump >&
      classifiers() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::ConceptClassifierDump >*
      mutable_classifiers();

  // repeated string aiids = 9;
  int aiids_size() const;
  private:
  int _internal_aiids_size() const;
  public:
  void clear_aiids();
  const std::string& aiids(int index) const;
  std::string* mutable_aiids(int index);
  void set_aiids(int index, const std::string& value);
  void set_aiids(int index, std::string&& value);
  void set_aiids(int index, const char* value);
  void set_aiids(int index, const char* value, size_t size);
  std::string* add_aiids();
  void add_aiids(const std::string& value);
  void add_aiids(std::string&& value);
  void add_aiids(const char* value);
  void add_aiids(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& aiids() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_aiids();
  private:
  const std::string& _internal_aiids(int index) const;
  std::string* _internal_add_aiids();
  public:

  // repeated string concept_ids = 11;
  int concept_ids_size() const;
  private:
  int _internal_concept_ids_size() const;
  public:
  void clear_concept_ids();
  const std::string& concept_ids(int index) const;
  std::string* mutable_concept_ids(int index);
  void set_concept_ids(int index, const std::string& value);
  void set_concept_ids(int index, std::string&& value);
  void set_concept_ids(int index, const char* value);
  void set_concept_ids(int index, const char* value, size_t size);
  std::string* add_concept_ids();
  void add_concept_ids(const std::string& value);
  void add_concept_ids(std::string&& value);
  void add_concept_ids(const char* value);
  void add_concept_ids(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& concept_ids() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_concept_ids();
  private:
  const std::string& _internal_concept_ids(int index) const;
  std::string* _internal_add_concept_ids();
  public:

  // string embeddings_model = 4;
  void clear_embeddings_model();
  const std::string& embeddings_model() const;
  void set_embeddings_model(const std::string& value);
  void set_embeddings_model(std::string&& value);
  void set_embeddings_model(const char* value);
  void set_embeddings_model(const char* value, size_t size);
  std::string* mutable_embeddings_model();
  std::string* release_embeddings_model();
  void set_allocated_embeddings_model(std::string* embeddings_model);
  private:
  const std::string& _internal_embeddings_model() const;
  void _internal_set_embeddings_model(const std::string& value);
  std::string* _internal_mutable_embeddings_model();
  public:

  // bytes tf_graph_proto = 7;
  void clear_tf_graph_proto();
  const std::string& tf_graph_proto() const;
  void set_tf_graph_proto(const std::string& value);
  void set_tf_graph_proto(std::string&& value);
  void set_tf_graph_proto(const char* value);
  void set_tf_graph_proto(const void* value, size_t size);
  std::string* mutable_tf_graph_proto();
  std::string* release_tf_graph_proto();
  void set_allocated_tf_graph_proto(std::string* tf_graph_proto);
  private:
  const std::string& _internal_tf_graph_proto() const;
  void _internal_set_tf_graph_proto(const std::string& value);
  std::string* _internal_mutable_tf_graph_proto();
  public:

  // bytes tf_frozen_meta_graph = 8;
  void clear_tf_frozen_meta_graph();
  const std::string& tf_frozen_meta_graph() const;
  void set_tf_frozen_meta_graph(const std::string& value);
  void set_tf_frozen_meta_graph(std::string&& value);
  void set_tf_frozen_meta_graph(const char* value);
  void set_tf_frozen_meta_graph(const void* value, size_t size);
  std::string* mutable_tf_frozen_meta_graph();
  std::string* release_tf_frozen_meta_graph();
  void set_allocated_tf_frozen_meta_graph(std::string* tf_frozen_meta_graph);
  private:
  const std::string& _internal_tf_frozen_meta_graph() const;
  void _internal_set_tf_frozen_meta_graph(const std::string& value);
  std::string* _internal_mutable_tf_frozen_meta_graph();
  public:

  // .google.protobuf.Timestamp update_time = 2;
  bool has_update_time() const;
  private:
  bool _internal_has_update_time() const;
  public:
  void clear_update_time();
  const PROTOBUF_NAMESPACE_ID::Timestamp& update_time() const;
  PROTOBUF_NAMESPACE_ID::Timestamp* release_update_time();
  PROTOBUF_NAMESPACE_ID::Timestamp* mutable_update_time();
  void set_allocated_update_time(PROTOBUF_NAMESPACE_ID::Timestamp* update_time);
  private:
  const PROTOBUF_NAMESPACE_ID::Timestamp& _internal_update_time() const;
  PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_update_time();
  public:
  void unsafe_arena_set_allocated_update_time(
      PROTOBUF_NAMESPACE_ID::Timestamp* update_time);
  PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_update_time();

  // int32 version = 1;
  void clear_version();
  ::PROTOBUF_NAMESPACE_ID::int32 version() const;
  void set_version(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_version() const;
  void _internal_set_version(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // .TrainingType training_type = 5;
  void clear_training_type();
  ::TrainingType training_type() const;
  void set_training_type(::TrainingType value);
  private:
  ::TrainingType _internal_training_type() const;
  void _internal_set_training_type(::TrainingType value);
  public:

  // bool feature_normalization = 6;
  void clear_feature_normalization();
  bool feature_normalization() const;
  void set_feature_normalization(bool value);
  private:
  bool _internal_feature_normalization() const;
  void _internal_set_feature_normalization(bool value);
  public:

  // .TrainingEnvironment training_environment = 10;
  void clear_training_environment();
  ::TrainingEnvironment training_environment() const;
  void set_training_environment(::TrainingEnvironment value);
  private:
  ::TrainingEnvironment _internal_training_environment() const;
  void _internal_set_training_environment(::TrainingEnvironment value);
  public:

  // .MissingPositiveExamplePolicy missing_positive_example_policy = 12;
  void clear_missing_positive_example_policy();
  ::MissingPositiveExamplePolicy missing_positive_example_policy() const;
  void set_missing_positive_example_policy(::MissingPositiveExamplePolicy value);
  private:
  ::MissingPositiveExamplePolicy _internal_missing_positive_example_policy() const;
  void _internal_set_missing_positive_example_policy(::MissingPositiveExamplePolicy value);
  public:

  // @@protoc_insertion_point(class_scope:ConceptTrainerDump)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::MapField<
      ConceptTrainerDump_ClassifiersEntry_DoNotUse,
      std::string, ::ConceptClassifierDump,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE,
      0 > classifiers_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> aiids_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> concept_ids_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr embeddings_model_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr tf_graph_proto_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr tf_frozen_meta_graph_;
  PROTOBUF_NAMESPACE_ID::Timestamp* update_time_;
  ::PROTOBUF_NAMESPACE_ID::int32 version_;
  int training_type_;
  bool feature_normalization_;
  int training_environment_;
  int missing_positive_example_policy_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_proto_2fconcept_5ftrainer_5fdump_2fconcept_5ftrainer_5fdump_2eproto;
};
// -------------------------------------------------------------------

class ConceptClassifierDump PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ConceptClassifierDump) */ {
 public:
  inline ConceptClassifierDump() : ConceptClassifierDump(nullptr) {}
  virtual ~ConceptClassifierDump();

  ConceptClassifierDump(const ConceptClassifierDump& from);
  ConceptClassifierDump(ConceptClassifierDump&& from) noexcept
    : ConceptClassifierDump() {
    *this = ::std::move(from);
  }

  inline ConceptClassifierDump& operator=(const ConceptClassifierDump& from) {
    CopyFrom(from);
    return *this;
  }
  inline ConceptClassifierDump& operator=(ConceptClassifierDump&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ConceptClassifierDump& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ConceptClassifierDump* internal_default_instance() {
    return reinterpret_cast<const ConceptClassifierDump*>(
               &_ConceptClassifierDump_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(ConceptClassifierDump& a, ConceptClassifierDump& b) {
    a.Swap(&b);
  }
  inline void Swap(ConceptClassifierDump* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ConceptClassifierDump* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ConceptClassifierDump* New() const final {
    return CreateMaybeMessage<ConceptClassifierDump>(nullptr);
  }

  ConceptClassifierDump* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ConceptClassifierDump>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ConceptClassifierDump& from);
  void MergeFrom(const ConceptClassifierDump& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ConceptClassifierDump* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ConceptClassifierDump";
  }
  protected:
  explicit ConceptClassifierDump(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_proto_2fconcept_5ftrainer_5fdump_2fconcept_5ftrainer_5fdump_2eproto);
    return ::descriptor_table_proto_2fconcept_5ftrainer_5fdump_2fconcept_5ftrainer_5fdump_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kWeightFieldNumber = 2,
    kClassifierTypeFieldNumber = 1,
    kBiasFieldNumber = 3,
    kNormFieldNumber = 4,
    kLogisticTempFieldNumber = 5,
  };
  // repeated float weight = 2 [packed = true];
  int weight_size() const;
  private:
  int _internal_weight_size() const;
  public:
  void clear_weight();
  private:
  float _internal_weight(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
      _internal_weight() const;
  void _internal_add_weight(float value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
      _internal_mutable_weight();
  public:
  float weight(int index) const;
  void set_weight(int index, float value);
  void add_weight(float value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
      weight() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
      mutable_weight();

  // string classifier_type = 1;
  void clear_classifier_type();
  const std::string& classifier_type() const;
  void set_classifier_type(const std::string& value);
  void set_classifier_type(std::string&& value);
  void set_classifier_type(const char* value);
  void set_classifier_type(const char* value, size_t size);
  std::string* mutable_classifier_type();
  std::string* release_classifier_type();
  void set_allocated_classifier_type(std::string* classifier_type);
  private:
  const std::string& _internal_classifier_type() const;
  void _internal_set_classifier_type(const std::string& value);
  std::string* _internal_mutable_classifier_type();
  public:

  // float bias = 3;
  void clear_bias();
  float bias() const;
  void set_bias(float value);
  private:
  float _internal_bias() const;
  void _internal_set_bias(float value);
  public:

  // float norm = 4 [deprecated = true];
  PROTOBUF_DEPRECATED void clear_norm();
  PROTOBUF_DEPRECATED float norm() const;
  PROTOBUF_DEPRECATED void set_norm(float value);
  private:
  float _internal_norm() const;
  void _internal_set_norm(float value);
  public:

  // float logistic_temp = 5;
  void clear_logistic_temp();
  float logistic_temp() const;
  void set_logistic_temp(float value);
  private:
  float _internal_logistic_temp() const;
  void _internal_set_logistic_temp(float value);
  public:

  // @@protoc_insertion_point(class_scope:ConceptClassifierDump)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float > weight_;
  mutable std::atomic<int> _weight_cached_byte_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr classifier_type_;
  float bias_;
  float norm_;
  float logistic_temp_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_proto_2fconcept_5ftrainer_5fdump_2fconcept_5ftrainer_5fdump_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// ConceptTrainerDump

// int32 version = 1;
inline void ConceptTrainerDump::clear_version() {
  version_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 ConceptTrainerDump::_internal_version() const {
  return version_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 ConceptTrainerDump::version() const {
  // @@protoc_insertion_point(field_get:ConceptTrainerDump.version)
  return _internal_version();
}
inline void ConceptTrainerDump::_internal_set_version(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  version_ = value;
}
inline void ConceptTrainerDump::set_version(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_version(value);
  // @@protoc_insertion_point(field_set:ConceptTrainerDump.version)
}

// .google.protobuf.Timestamp update_time = 2;
inline bool ConceptTrainerDump::_internal_has_update_time() const {
  return this != internal_default_instance() && update_time_ != nullptr;
}
inline bool ConceptTrainerDump::has_update_time() const {
  return _internal_has_update_time();
}
inline const PROTOBUF_NAMESPACE_ID::Timestamp& ConceptTrainerDump::_internal_update_time() const {
  const PROTOBUF_NAMESPACE_ID::Timestamp* p = update_time_;
  return p != nullptr ? *p : *reinterpret_cast<const PROTOBUF_NAMESPACE_ID::Timestamp*>(
      &PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const PROTOBUF_NAMESPACE_ID::Timestamp& ConceptTrainerDump::update_time() const {
  // @@protoc_insertion_point(field_get:ConceptTrainerDump.update_time)
  return _internal_update_time();
}
inline void ConceptTrainerDump::unsafe_arena_set_allocated_update_time(
    PROTOBUF_NAMESPACE_ID::Timestamp* update_time) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(update_time_);
  }
  update_time_ = update_time;
  if (update_time) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ConceptTrainerDump.update_time)
}
inline PROTOBUF_NAMESPACE_ID::Timestamp* ConceptTrainerDump::release_update_time() {
  
  PROTOBUF_NAMESPACE_ID::Timestamp* temp = update_time_;
  update_time_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline PROTOBUF_NAMESPACE_ID::Timestamp* ConceptTrainerDump::unsafe_arena_release_update_time() {
  // @@protoc_insertion_point(field_release:ConceptTrainerDump.update_time)
  
  PROTOBUF_NAMESPACE_ID::Timestamp* temp = update_time_;
  update_time_ = nullptr;
  return temp;
}
inline PROTOBUF_NAMESPACE_ID::Timestamp* ConceptTrainerDump::_internal_mutable_update_time() {
  
  if (update_time_ == nullptr) {
    auto* p = CreateMaybeMessage<PROTOBUF_NAMESPACE_ID::Timestamp>(GetArena());
    update_time_ = p;
  }
  return update_time_;
}
inline PROTOBUF_NAMESPACE_ID::Timestamp* ConceptTrainerDump::mutable_update_time() {
  // @@protoc_insertion_point(field_mutable:ConceptTrainerDump.update_time)
  return _internal_mutable_update_time();
}
inline void ConceptTrainerDump::set_allocated_update_time(PROTOBUF_NAMESPACE_ID::Timestamp* update_time) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(update_time_);
  }
  if (update_time) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(update_time)->GetArena();
    if (message_arena != submessage_arena) {
      update_time = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, update_time, submessage_arena);
    }
    
  } else {
    
  }
  update_time_ = update_time;
  // @@protoc_insertion_point(field_set_allocated:ConceptTrainerDump.update_time)
}

// map<string, .ConceptClassifierDump> classifiers = 3;
inline int ConceptTrainerDump::_internal_classifiers_size() const {
  return classifiers_.size();
}
inline int ConceptTrainerDump::classifiers_size() const {
  return _internal_classifiers_size();
}
inline void ConceptTrainerDump::clear_classifiers() {
  classifiers_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::ConceptClassifierDump >&
ConceptTrainerDump::_internal_classifiers() const {
  return classifiers_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::ConceptClassifierDump >&
ConceptTrainerDump::classifiers() const {
  // @@protoc_insertion_point(field_map:ConceptTrainerDump.classifiers)
  return _internal_classifiers();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::ConceptClassifierDump >*
ConceptTrainerDump::_internal_mutable_classifiers() {
  return classifiers_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::ConceptClassifierDump >*
ConceptTrainerDump::mutable_classifiers() {
  // @@protoc_insertion_point(field_mutable_map:ConceptTrainerDump.classifiers)
  return _internal_mutable_classifiers();
}

// string embeddings_model = 4;
inline void ConceptTrainerDump::clear_embeddings_model() {
  embeddings_model_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& ConceptTrainerDump::embeddings_model() const {
  // @@protoc_insertion_point(field_get:ConceptTrainerDump.embeddings_model)
  return _internal_embeddings_model();
}
inline void ConceptTrainerDump::set_embeddings_model(const std::string& value) {
  _internal_set_embeddings_model(value);
  // @@protoc_insertion_point(field_set:ConceptTrainerDump.embeddings_model)
}
inline std::string* ConceptTrainerDump::mutable_embeddings_model() {
  // @@protoc_insertion_point(field_mutable:ConceptTrainerDump.embeddings_model)
  return _internal_mutable_embeddings_model();
}
inline const std::string& ConceptTrainerDump::_internal_embeddings_model() const {
  return embeddings_model_.Get();
}
inline void ConceptTrainerDump::_internal_set_embeddings_model(const std::string& value) {
  
  embeddings_model_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void ConceptTrainerDump::set_embeddings_model(std::string&& value) {
  
  embeddings_model_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:ConceptTrainerDump.embeddings_model)
}
inline void ConceptTrainerDump::set_embeddings_model(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  embeddings_model_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:ConceptTrainerDump.embeddings_model)
}
inline void ConceptTrainerDump::set_embeddings_model(const char* value,
    size_t size) {
  
  embeddings_model_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:ConceptTrainerDump.embeddings_model)
}
inline std::string* ConceptTrainerDump::_internal_mutable_embeddings_model() {
  
  return embeddings_model_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* ConceptTrainerDump::release_embeddings_model() {
  // @@protoc_insertion_point(field_release:ConceptTrainerDump.embeddings_model)
  return embeddings_model_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void ConceptTrainerDump::set_allocated_embeddings_model(std::string* embeddings_model) {
  if (embeddings_model != nullptr) {
    
  } else {
    
  }
  embeddings_model_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), embeddings_model,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:ConceptTrainerDump.embeddings_model)
}

// .TrainingType training_type = 5;
inline void ConceptTrainerDump::clear_training_type() {
  training_type_ = 0;
}
inline ::TrainingType ConceptTrainerDump::_internal_training_type() const {
  return static_cast< ::TrainingType >(training_type_);
}
inline ::TrainingType ConceptTrainerDump::training_type() const {
  // @@protoc_insertion_point(field_get:ConceptTrainerDump.training_type)
  return _internal_training_type();
}
inline void ConceptTrainerDump::_internal_set_training_type(::TrainingType value) {
  
  training_type_ = value;
}
inline void ConceptTrainerDump::set_training_type(::TrainingType value) {
  _internal_set_training_type(value);
  // @@protoc_insertion_point(field_set:ConceptTrainerDump.training_type)
}

// bool feature_normalization = 6;
inline void ConceptTrainerDump::clear_feature_normalization() {
  feature_normalization_ = false;
}
inline bool ConceptTrainerDump::_internal_feature_normalization() const {
  return feature_normalization_;
}
inline bool ConceptTrainerDump::feature_normalization() const {
  // @@protoc_insertion_point(field_get:ConceptTrainerDump.feature_normalization)
  return _internal_feature_normalization();
}
inline void ConceptTrainerDump::_internal_set_feature_normalization(bool value) {
  
  feature_normalization_ = value;
}
inline void ConceptTrainerDump::set_feature_normalization(bool value) {
  _internal_set_feature_normalization(value);
  // @@protoc_insertion_point(field_set:ConceptTrainerDump.feature_normalization)
}

// bytes tf_graph_proto = 7;
inline void ConceptTrainerDump::clear_tf_graph_proto() {
  tf_graph_proto_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& ConceptTrainerDump::tf_graph_proto() const {
  // @@protoc_insertion_point(field_get:ConceptTrainerDump.tf_graph_proto)
  return _internal_tf_graph_proto();
}
inline void ConceptTrainerDump::set_tf_graph_proto(const std::string& value) {
  _internal_set_tf_graph_proto(value);
  // @@protoc_insertion_point(field_set:ConceptTrainerDump.tf_graph_proto)
}
inline std::string* ConceptTrainerDump::mutable_tf_graph_proto() {
  // @@protoc_insertion_point(field_mutable:ConceptTrainerDump.tf_graph_proto)
  return _internal_mutable_tf_graph_proto();
}
inline const std::string& ConceptTrainerDump::_internal_tf_graph_proto() const {
  return tf_graph_proto_.Get();
}
inline void ConceptTrainerDump::_internal_set_tf_graph_proto(const std::string& value) {
  
  tf_graph_proto_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void ConceptTrainerDump::set_tf_graph_proto(std::string&& value) {
  
  tf_graph_proto_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:ConceptTrainerDump.tf_graph_proto)
}
inline void ConceptTrainerDump::set_tf_graph_proto(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  tf_graph_proto_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:ConceptTrainerDump.tf_graph_proto)
}
inline void ConceptTrainerDump::set_tf_graph_proto(const void* value,
    size_t size) {
  
  tf_graph_proto_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:ConceptTrainerDump.tf_graph_proto)
}
inline std::string* ConceptTrainerDump::_internal_mutable_tf_graph_proto() {
  
  return tf_graph_proto_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* ConceptTrainerDump::release_tf_graph_proto() {
  // @@protoc_insertion_point(field_release:ConceptTrainerDump.tf_graph_proto)
  return tf_graph_proto_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void ConceptTrainerDump::set_allocated_tf_graph_proto(std::string* tf_graph_proto) {
  if (tf_graph_proto != nullptr) {
    
  } else {
    
  }
  tf_graph_proto_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), tf_graph_proto,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:ConceptTrainerDump.tf_graph_proto)
}

// bytes tf_frozen_meta_graph = 8;
inline void ConceptTrainerDump::clear_tf_frozen_meta_graph() {
  tf_frozen_meta_graph_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& ConceptTrainerDump::tf_frozen_meta_graph() const {
  // @@protoc_insertion_point(field_get:ConceptTrainerDump.tf_frozen_meta_graph)
  return _internal_tf_frozen_meta_graph();
}
inline void ConceptTrainerDump::set_tf_frozen_meta_graph(const std::string& value) {
  _internal_set_tf_frozen_meta_graph(value);
  // @@protoc_insertion_point(field_set:ConceptTrainerDump.tf_frozen_meta_graph)
}
inline std::string* ConceptTrainerDump::mutable_tf_frozen_meta_graph() {
  // @@protoc_insertion_point(field_mutable:ConceptTrainerDump.tf_frozen_meta_graph)
  return _internal_mutable_tf_frozen_meta_graph();
}
inline const std::string& ConceptTrainerDump::_internal_tf_frozen_meta_graph() const {
  return tf_frozen_meta_graph_.Get();
}
inline void ConceptTrainerDump::_internal_set_tf_frozen_meta_graph(const std::string& value) {
  
  tf_frozen_meta_graph_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void ConceptTrainerDump::set_tf_frozen_meta_graph(std::string&& value) {
  
  tf_frozen_meta_graph_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:ConceptTrainerDump.tf_frozen_meta_graph)
}
inline void ConceptTrainerDump::set_tf_frozen_meta_graph(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  tf_frozen_meta_graph_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:ConceptTrainerDump.tf_frozen_meta_graph)
}
inline void ConceptTrainerDump::set_tf_frozen_meta_graph(const void* value,
    size_t size) {
  
  tf_frozen_meta_graph_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:ConceptTrainerDump.tf_frozen_meta_graph)
}
inline std::string* ConceptTrainerDump::_internal_mutable_tf_frozen_meta_graph() {
  
  return tf_frozen_meta_graph_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* ConceptTrainerDump::release_tf_frozen_meta_graph() {
  // @@protoc_insertion_point(field_release:ConceptTrainerDump.tf_frozen_meta_graph)
  return tf_frozen_meta_graph_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void ConceptTrainerDump::set_allocated_tf_frozen_meta_graph(std::string* tf_frozen_meta_graph) {
  if (tf_frozen_meta_graph != nullptr) {
    
  } else {
    
  }
  tf_frozen_meta_graph_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), tf_frozen_meta_graph,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:ConceptTrainerDump.tf_frozen_meta_graph)
}

// repeated string aiids = 9;
inline int ConceptTrainerDump::_internal_aiids_size() const {
  return aiids_.size();
}
inline int ConceptTrainerDump::aiids_size() const {
  return _internal_aiids_size();
}
inline void ConceptTrainerDump::clear_aiids() {
  aiids_.Clear();
}
inline std::string* ConceptTrainerDump::add_aiids() {
  // @@protoc_insertion_point(field_add_mutable:ConceptTrainerDump.aiids)
  return _internal_add_aiids();
}
inline const std::string& ConceptTrainerDump::_internal_aiids(int index) const {
  return aiids_.Get(index);
}
inline const std::string& ConceptTrainerDump::aiids(int index) const {
  // @@protoc_insertion_point(field_get:ConceptTrainerDump.aiids)
  return _internal_aiids(index);
}
inline std::string* ConceptTrainerDump::mutable_aiids(int index) {
  // @@protoc_insertion_point(field_mutable:ConceptTrainerDump.aiids)
  return aiids_.Mutable(index);
}
inline void ConceptTrainerDump::set_aiids(int index, const std::string& value) {
  // @@protoc_insertion_point(field_set:ConceptTrainerDump.aiids)
  aiids_.Mutable(index)->assign(value);
}
inline void ConceptTrainerDump::set_aiids(int index, std::string&& value) {
  // @@protoc_insertion_point(field_set:ConceptTrainerDump.aiids)
  aiids_.Mutable(index)->assign(std::move(value));
}
inline void ConceptTrainerDump::set_aiids(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  aiids_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:ConceptTrainerDump.aiids)
}
inline void ConceptTrainerDump::set_aiids(int index, const char* value, size_t size) {
  aiids_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:ConceptTrainerDump.aiids)
}
inline std::string* ConceptTrainerDump::_internal_add_aiids() {
  return aiids_.Add();
}
inline void ConceptTrainerDump::add_aiids(const std::string& value) {
  aiids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:ConceptTrainerDump.aiids)
}
inline void ConceptTrainerDump::add_aiids(std::string&& value) {
  aiids_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:ConceptTrainerDump.aiids)
}
inline void ConceptTrainerDump::add_aiids(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  aiids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:ConceptTrainerDump.aiids)
}
inline void ConceptTrainerDump::add_aiids(const char* value, size_t size) {
  aiids_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:ConceptTrainerDump.aiids)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
ConceptTrainerDump::aiids() const {
  // @@protoc_insertion_point(field_list:ConceptTrainerDump.aiids)
  return aiids_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
ConceptTrainerDump::mutable_aiids() {
  // @@protoc_insertion_point(field_mutable_list:ConceptTrainerDump.aiids)
  return &aiids_;
}

// .TrainingEnvironment training_environment = 10;
inline void ConceptTrainerDump::clear_training_environment() {
  training_environment_ = 0;
}
inline ::TrainingEnvironment ConceptTrainerDump::_internal_training_environment() const {
  return static_cast< ::TrainingEnvironment >(training_environment_);
}
inline ::TrainingEnvironment ConceptTrainerDump::training_environment() const {
  // @@protoc_insertion_point(field_get:ConceptTrainerDump.training_environment)
  return _internal_training_environment();
}
inline void ConceptTrainerDump::_internal_set_training_environment(::TrainingEnvironment value) {
  
  training_environment_ = value;
}
inline void ConceptTrainerDump::set_training_environment(::TrainingEnvironment value) {
  _internal_set_training_environment(value);
  // @@protoc_insertion_point(field_set:ConceptTrainerDump.training_environment)
}

// repeated string concept_ids = 11;
inline int ConceptTrainerDump::_internal_concept_ids_size() const {
  return concept_ids_.size();
}
inline int ConceptTrainerDump::concept_ids_size() const {
  return _internal_concept_ids_size();
}
inline void ConceptTrainerDump::clear_concept_ids() {
  concept_ids_.Clear();
}
inline std::string* ConceptTrainerDump::add_concept_ids() {
  // @@protoc_insertion_point(field_add_mutable:ConceptTrainerDump.concept_ids)
  return _internal_add_concept_ids();
}
inline const std::string& ConceptTrainerDump::_internal_concept_ids(int index) const {
  return concept_ids_.Get(index);
}
inline const std::string& ConceptTrainerDump::concept_ids(int index) const {
  // @@protoc_insertion_point(field_get:ConceptTrainerDump.concept_ids)
  return _internal_concept_ids(index);
}
inline std::string* ConceptTrainerDump::mutable_concept_ids(int index) {
  // @@protoc_insertion_point(field_mutable:ConceptTrainerDump.concept_ids)
  return concept_ids_.Mutable(index);
}
inline void ConceptTrainerDump::set_concept_ids(int index, const std::string& value) {
  // @@protoc_insertion_point(field_set:ConceptTrainerDump.concept_ids)
  concept_ids_.Mutable(index)->assign(value);
}
inline void ConceptTrainerDump::set_concept_ids(int index, std::string&& value) {
  // @@protoc_insertion_point(field_set:ConceptTrainerDump.concept_ids)
  concept_ids_.Mutable(index)->assign(std::move(value));
}
inline void ConceptTrainerDump::set_concept_ids(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  concept_ids_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:ConceptTrainerDump.concept_ids)
}
inline void ConceptTrainerDump::set_concept_ids(int index, const char* value, size_t size) {
  concept_ids_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:ConceptTrainerDump.concept_ids)
}
inline std::string* ConceptTrainerDump::_internal_add_concept_ids() {
  return concept_ids_.Add();
}
inline void ConceptTrainerDump::add_concept_ids(const std::string& value) {
  concept_ids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:ConceptTrainerDump.concept_ids)
}
inline void ConceptTrainerDump::add_concept_ids(std::string&& value) {
  concept_ids_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:ConceptTrainerDump.concept_ids)
}
inline void ConceptTrainerDump::add_concept_ids(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  concept_ids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:ConceptTrainerDump.concept_ids)
}
inline void ConceptTrainerDump::add_concept_ids(const char* value, size_t size) {
  concept_ids_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:ConceptTrainerDump.concept_ids)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
ConceptTrainerDump::concept_ids() const {
  // @@protoc_insertion_point(field_list:ConceptTrainerDump.concept_ids)
  return concept_ids_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
ConceptTrainerDump::mutable_concept_ids() {
  // @@protoc_insertion_point(field_mutable_list:ConceptTrainerDump.concept_ids)
  return &concept_ids_;
}

// .MissingPositiveExamplePolicy missing_positive_example_policy = 12;
inline void ConceptTrainerDump::clear_missing_positive_example_policy() {
  missing_positive_example_policy_ = 0;
}
inline ::MissingPositiveExamplePolicy ConceptTrainerDump::_internal_missing_positive_example_policy() const {
  return static_cast< ::MissingPositiveExamplePolicy >(missing_positive_example_policy_);
}
inline ::MissingPositiveExamplePolicy ConceptTrainerDump::missing_positive_example_policy() const {
  // @@protoc_insertion_point(field_get:ConceptTrainerDump.missing_positive_example_policy)
  return _internal_missing_positive_example_policy();
}
inline void ConceptTrainerDump::_internal_set_missing_positive_example_policy(::MissingPositiveExamplePolicy value) {
  
  missing_positive_example_policy_ = value;
}
inline void ConceptTrainerDump::set_missing_positive_example_policy(::MissingPositiveExamplePolicy value) {
  _internal_set_missing_positive_example_policy(value);
  // @@protoc_insertion_point(field_set:ConceptTrainerDump.missing_positive_example_policy)
}

// -------------------------------------------------------------------

// ConceptClassifierDump

// string classifier_type = 1;
inline void ConceptClassifierDump::clear_classifier_type() {
  classifier_type_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& ConceptClassifierDump::classifier_type() const {
  // @@protoc_insertion_point(field_get:ConceptClassifierDump.classifier_type)
  return _internal_classifier_type();
}
inline void ConceptClassifierDump::set_classifier_type(const std::string& value) {
  _internal_set_classifier_type(value);
  // @@protoc_insertion_point(field_set:ConceptClassifierDump.classifier_type)
}
inline std::string* ConceptClassifierDump::mutable_classifier_type() {
  // @@protoc_insertion_point(field_mutable:ConceptClassifierDump.classifier_type)
  return _internal_mutable_classifier_type();
}
inline const std::string& ConceptClassifierDump::_internal_classifier_type() const {
  return classifier_type_.Get();
}
inline void ConceptClassifierDump::_internal_set_classifier_type(const std::string& value) {
  
  classifier_type_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void ConceptClassifierDump::set_classifier_type(std::string&& value) {
  
  classifier_type_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:ConceptClassifierDump.classifier_type)
}
inline void ConceptClassifierDump::set_classifier_type(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  classifier_type_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:ConceptClassifierDump.classifier_type)
}
inline void ConceptClassifierDump::set_classifier_type(const char* value,
    size_t size) {
  
  classifier_type_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:ConceptClassifierDump.classifier_type)
}
inline std::string* ConceptClassifierDump::_internal_mutable_classifier_type() {
  
  return classifier_type_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* ConceptClassifierDump::release_classifier_type() {
  // @@protoc_insertion_point(field_release:ConceptClassifierDump.classifier_type)
  return classifier_type_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void ConceptClassifierDump::set_allocated_classifier_type(std::string* classifier_type) {
  if (classifier_type != nullptr) {
    
  } else {
    
  }
  classifier_type_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), classifier_type,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:ConceptClassifierDump.classifier_type)
}

// repeated float weight = 2 [packed = true];
inline int ConceptClassifierDump::_internal_weight_size() const {
  return weight_.size();
}
inline int ConceptClassifierDump::weight_size() const {
  return _internal_weight_size();
}
inline void ConceptClassifierDump::clear_weight() {
  weight_.Clear();
}
inline float ConceptClassifierDump::_internal_weight(int index) const {
  return weight_.Get(index);
}
inline float ConceptClassifierDump::weight(int index) const {
  // @@protoc_insertion_point(field_get:ConceptClassifierDump.weight)
  return _internal_weight(index);
}
inline void ConceptClassifierDump::set_weight(int index, float value) {
  weight_.Set(index, value);
  // @@protoc_insertion_point(field_set:ConceptClassifierDump.weight)
}
inline void ConceptClassifierDump::_internal_add_weight(float value) {
  weight_.Add(value);
}
inline void ConceptClassifierDump::add_weight(float value) {
  _internal_add_weight(value);
  // @@protoc_insertion_point(field_add:ConceptClassifierDump.weight)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
ConceptClassifierDump::_internal_weight() const {
  return weight_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
ConceptClassifierDump::weight() const {
  // @@protoc_insertion_point(field_list:ConceptClassifierDump.weight)
  return _internal_weight();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
ConceptClassifierDump::_internal_mutable_weight() {
  return &weight_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
ConceptClassifierDump::mutable_weight() {
  // @@protoc_insertion_point(field_mutable_list:ConceptClassifierDump.weight)
  return _internal_mutable_weight();
}

// float bias = 3;
inline void ConceptClassifierDump::clear_bias() {
  bias_ = 0;
}
inline float ConceptClassifierDump::_internal_bias() const {
  return bias_;
}
inline float ConceptClassifierDump::bias() const {
  // @@protoc_insertion_point(field_get:ConceptClassifierDump.bias)
  return _internal_bias();
}
inline void ConceptClassifierDump::_internal_set_bias(float value) {
  
  bias_ = value;
}
inline void ConceptClassifierDump::set_bias(float value) {
  _internal_set_bias(value);
  // @@protoc_insertion_point(field_set:ConceptClassifierDump.bias)
}

// float norm = 4 [deprecated = true];
inline void ConceptClassifierDump::clear_norm() {
  norm_ = 0;
}
inline float ConceptClassifierDump::_internal_norm() const {
  return norm_;
}
inline float ConceptClassifierDump::norm() const {
  // @@protoc_insertion_point(field_get:ConceptClassifierDump.norm)
  return _internal_norm();
}
inline void ConceptClassifierDump::_internal_set_norm(float value) {
  
  norm_ = value;
}
inline void ConceptClassifierDump::set_norm(float value) {
  _internal_set_norm(value);
  // @@protoc_insertion_point(field_set:ConceptClassifierDump.norm)
}

// float logistic_temp = 5;
inline void ConceptClassifierDump::clear_logistic_temp() {
  logistic_temp_ = 0;
}
inline float ConceptClassifierDump::_internal_logistic_temp() const {
  return logistic_temp_;
}
inline float ConceptClassifierDump::logistic_temp() const {
  // @@protoc_insertion_point(field_get:ConceptClassifierDump.logistic_temp)
  return _internal_logistic_temp();
}
inline void ConceptClassifierDump::_internal_set_logistic_temp(float value) {
  
  logistic_temp_ = value;
}
inline void ConceptClassifierDump::set_logistic_temp(float value) {
  _internal_set_logistic_temp(value);
  // @@protoc_insertion_point(field_set:ConceptClassifierDump.logistic_temp)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)


PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::TrainingType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::TrainingType>() {
  return ::TrainingType_descriptor();
}
template <> struct is_proto_enum< ::TrainingEnvironment> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::TrainingEnvironment>() {
  return ::TrainingEnvironment_descriptor();
}
template <> struct is_proto_enum< ::MissingPositiveExamplePolicy> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::MissingPositiveExamplePolicy>() {
  return ::MissingPositiveExamplePolicy_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_proto_2fconcept_5ftrainer_5fdump_2fconcept_5ftrainer_5fdump_2eproto
