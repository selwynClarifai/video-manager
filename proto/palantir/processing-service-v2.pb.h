// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: proto/palantir/processing-service-v2.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_proto_2fpalantir_2fprocessing_2dservice_2dv2_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_proto_2fpalantir_2fprocessing_2dservice_2dv2_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3013000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3013000 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include <google/protobuf/duration.pb.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_proto_2fpalantir_2fprocessing_2dservice_2dv2_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_proto_2fpalantir_2fprocessing_2dservice_2dv2_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[35]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_proto_2fpalantir_2fprocessing_2dservice_2dv2_2eproto;
namespace aip {
namespace processor {
namespace v2 {
class Bgr888Image;
class Bgr888ImageDefaultTypeInternal;
extern Bgr888ImageDefaultTypeInternal _Bgr888Image_default_instance_;
class BoundingBox;
class BoundingBoxDefaultTypeInternal;
extern BoundingBoxDefaultTypeInternal _BoundingBox_default_instance_;
class BoundingPolygon;
class BoundingPolygonDefaultTypeInternal;
extern BoundingPolygonDefaultTypeInternal _BoundingPolygon_default_instance_;
class Classification;
class ClassificationDefaultTypeInternal;
extern ClassificationDefaultTypeInternal _Classification_default_instance_;
class DigitalGlobeMetadata;
class DigitalGlobeMetadataDefaultTypeInternal;
extern DigitalGlobeMetadataDefaultTypeInternal _DigitalGlobeMetadata_default_instance_;
class Frame;
class FrameDefaultTypeInternal;
extern FrameDefaultTypeInternal _Frame_default_instance_;
class GeoBoundingBox;
class GeoBoundingBoxDefaultTypeInternal;
extern GeoBoundingBoxDefaultTypeInternal _GeoBoundingBox_default_instance_;
class GeoBoundingPolygon;
class GeoBoundingPolygonDefaultTypeInternal;
extern GeoBoundingPolygonDefaultTypeInternal _GeoBoundingPolygon_default_instance_;
class GeoCoordinate;
class GeoCoordinateDefaultTypeInternal;
extern GeoCoordinateDefaultTypeInternal _GeoCoordinate_default_instance_;
class GeoPolygon;
class GeoPolygonDefaultTypeInternal;
extern GeoPolygonDefaultTypeInternal _GeoPolygon_default_instance_;
class GeoRegistration;
class GeoRegistrationDefaultTypeInternal;
extern GeoRegistrationDefaultTypeInternal _GeoRegistration_default_instance_;
class GeoRegistrationRequest;
class GeoRegistrationRequestDefaultTypeInternal;
extern GeoRegistrationRequestDefaultTypeInternal _GeoRegistrationRequest_default_instance_;
class GeoRegistrationResponse;
class GeoRegistrationResponseDefaultTypeInternal;
extern GeoRegistrationResponseDefaultTypeInternal _GeoRegistrationResponse_default_instance_;
class Identifier;
class IdentifierDefaultTypeInternal;
extern IdentifierDefaultTypeInternal _Identifier_default_instance_;
class Image;
class ImageDefaultTypeInternal;
extern ImageDefaultTypeInternal _Image_default_instance_;
class Inference;
class InferenceDefaultTypeInternal;
extern InferenceDefaultTypeInternal _Inference_default_instance_;
class InferenceRequest;
class InferenceRequestDefaultTypeInternal;
extern InferenceRequestDefaultTypeInternal _InferenceRequest_default_instance_;
class InferenceResponse;
class InferenceResponseDefaultTypeInternal;
extern InferenceResponseDefaultTypeInternal _InferenceResponse_default_instance_;
class Inferences;
class InferencesDefaultTypeInternal;
extern InferencesDefaultTypeInternal _Inferences_default_instance_;
class Lattice;
class LatticeDefaultTypeInternal;
extern LatticeDefaultTypeInternal _Lattice_default_instance_;
class Lattice_Point;
class Lattice_PointDefaultTypeInternal;
extern Lattice_PointDefaultTypeInternal _Lattice_Point_default_instance_;
class Nitf21Image;
class Nitf21ImageDefaultTypeInternal;
extern Nitf21ImageDefaultTypeInternal _Nitf21Image_default_instance_;
class PixelVelocityVector;
class PixelVelocityVectorDefaultTypeInternal;
extern PixelVelocityVectorDefaultTypeInternal _PixelVelocityVector_default_instance_;
class PngImage;
class PngImageDefaultTypeInternal;
extern PngImageDefaultTypeInternal _PngImage_default_instance_;
class Polygon;
class PolygonDefaultTypeInternal;
extern PolygonDefaultTypeInternal _Polygon_default_instance_;
class ProcessorV2Config;
class ProcessorV2ConfigDefaultTypeInternal;
extern ProcessorV2ConfigDefaultTypeInternal _ProcessorV2Config_default_instance_;
class ProviderMetadata;
class ProviderMetadataDefaultTypeInternal;
extern ProviderMetadataDefaultTypeInternal _ProviderMetadata_default_instance_;
class RequestHeader;
class RequestHeaderDefaultTypeInternal;
extern RequestHeaderDefaultTypeInternal _RequestHeader_default_instance_;
class Rgb888Image;
class Rgb888ImageDefaultTypeInternal;
extern Rgb888ImageDefaultTypeInternal _Rgb888Image_default_instance_;
class TiffImage;
class TiffImageDefaultTypeInternal;
extern TiffImageDefaultTypeInternal _TiffImage_default_instance_;
class Timestamp;
class TimestampDefaultTypeInternal;
extern TimestampDefaultTypeInternal _Timestamp_default_instance_;
class TrackRequest;
class TrackRequestDefaultTypeInternal;
extern TrackRequestDefaultTypeInternal _TrackRequest_default_instance_;
class UasMetadata;
class UasMetadataDefaultTypeInternal;
extern UasMetadataDefaultTypeInternal _UasMetadata_default_instance_;
class UnitCoordinate;
class UnitCoordinateDefaultTypeInternal;
extern UnitCoordinateDefaultTypeInternal _UnitCoordinate_default_instance_;
class Velocity;
class VelocityDefaultTypeInternal;
extern VelocityDefaultTypeInternal _Velocity_default_instance_;
}  // namespace v2
}  // namespace processor
}  // namespace aip
PROTOBUF_NAMESPACE_OPEN
template<> ::aip::processor::v2::Bgr888Image* Arena::CreateMaybeMessage<::aip::processor::v2::Bgr888Image>(Arena*);
template<> ::aip::processor::v2::BoundingBox* Arena::CreateMaybeMessage<::aip::processor::v2::BoundingBox>(Arena*);
template<> ::aip::processor::v2::BoundingPolygon* Arena::CreateMaybeMessage<::aip::processor::v2::BoundingPolygon>(Arena*);
template<> ::aip::processor::v2::Classification* Arena::CreateMaybeMessage<::aip::processor::v2::Classification>(Arena*);
template<> ::aip::processor::v2::DigitalGlobeMetadata* Arena::CreateMaybeMessage<::aip::processor::v2::DigitalGlobeMetadata>(Arena*);
template<> ::aip::processor::v2::Frame* Arena::CreateMaybeMessage<::aip::processor::v2::Frame>(Arena*);
template<> ::aip::processor::v2::GeoBoundingBox* Arena::CreateMaybeMessage<::aip::processor::v2::GeoBoundingBox>(Arena*);
template<> ::aip::processor::v2::GeoBoundingPolygon* Arena::CreateMaybeMessage<::aip::processor::v2::GeoBoundingPolygon>(Arena*);
template<> ::aip::processor::v2::GeoCoordinate* Arena::CreateMaybeMessage<::aip::processor::v2::GeoCoordinate>(Arena*);
template<> ::aip::processor::v2::GeoPolygon* Arena::CreateMaybeMessage<::aip::processor::v2::GeoPolygon>(Arena*);
template<> ::aip::processor::v2::GeoRegistration* Arena::CreateMaybeMessage<::aip::processor::v2::GeoRegistration>(Arena*);
template<> ::aip::processor::v2::GeoRegistrationRequest* Arena::CreateMaybeMessage<::aip::processor::v2::GeoRegistrationRequest>(Arena*);
template<> ::aip::processor::v2::GeoRegistrationResponse* Arena::CreateMaybeMessage<::aip::processor::v2::GeoRegistrationResponse>(Arena*);
template<> ::aip::processor::v2::Identifier* Arena::CreateMaybeMessage<::aip::processor::v2::Identifier>(Arena*);
template<> ::aip::processor::v2::Image* Arena::CreateMaybeMessage<::aip::processor::v2::Image>(Arena*);
template<> ::aip::processor::v2::Inference* Arena::CreateMaybeMessage<::aip::processor::v2::Inference>(Arena*);
template<> ::aip::processor::v2::InferenceRequest* Arena::CreateMaybeMessage<::aip::processor::v2::InferenceRequest>(Arena*);
template<> ::aip::processor::v2::InferenceResponse* Arena::CreateMaybeMessage<::aip::processor::v2::InferenceResponse>(Arena*);
template<> ::aip::processor::v2::Inferences* Arena::CreateMaybeMessage<::aip::processor::v2::Inferences>(Arena*);
template<> ::aip::processor::v2::Lattice* Arena::CreateMaybeMessage<::aip::processor::v2::Lattice>(Arena*);
template<> ::aip::processor::v2::Lattice_Point* Arena::CreateMaybeMessage<::aip::processor::v2::Lattice_Point>(Arena*);
template<> ::aip::processor::v2::Nitf21Image* Arena::CreateMaybeMessage<::aip::processor::v2::Nitf21Image>(Arena*);
template<> ::aip::processor::v2::PixelVelocityVector* Arena::CreateMaybeMessage<::aip::processor::v2::PixelVelocityVector>(Arena*);
template<> ::aip::processor::v2::PngImage* Arena::CreateMaybeMessage<::aip::processor::v2::PngImage>(Arena*);
template<> ::aip::processor::v2::Polygon* Arena::CreateMaybeMessage<::aip::processor::v2::Polygon>(Arena*);
template<> ::aip::processor::v2::ProcessorV2Config* Arena::CreateMaybeMessage<::aip::processor::v2::ProcessorV2Config>(Arena*);
template<> ::aip::processor::v2::ProviderMetadata* Arena::CreateMaybeMessage<::aip::processor::v2::ProviderMetadata>(Arena*);
template<> ::aip::processor::v2::RequestHeader* Arena::CreateMaybeMessage<::aip::processor::v2::RequestHeader>(Arena*);
template<> ::aip::processor::v2::Rgb888Image* Arena::CreateMaybeMessage<::aip::processor::v2::Rgb888Image>(Arena*);
template<> ::aip::processor::v2::TiffImage* Arena::CreateMaybeMessage<::aip::processor::v2::TiffImage>(Arena*);
template<> ::aip::processor::v2::Timestamp* Arena::CreateMaybeMessage<::aip::processor::v2::Timestamp>(Arena*);
template<> ::aip::processor::v2::TrackRequest* Arena::CreateMaybeMessage<::aip::processor::v2::TrackRequest>(Arena*);
template<> ::aip::processor::v2::UasMetadata* Arena::CreateMaybeMessage<::aip::processor::v2::UasMetadata>(Arena*);
template<> ::aip::processor::v2::UnitCoordinate* Arena::CreateMaybeMessage<::aip::processor::v2::UnitCoordinate>(Arena*);
template<> ::aip::processor::v2::Velocity* Arena::CreateMaybeMessage<::aip::processor::v2::Velocity>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace aip {
namespace processor {
namespace v2 {

enum ProcessorV2Config_Capability : int {
  ProcessorV2Config_Capability_GEO_REGISTER = 0,
  ProcessorV2Config_Capability_INFER = 1,
  ProcessorV2Config_Capability_TRACK = 2,
  ProcessorV2Config_Capability_ProcessorV2Config_Capability_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  ProcessorV2Config_Capability_ProcessorV2Config_Capability_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool ProcessorV2Config_Capability_IsValid(int value);
constexpr ProcessorV2Config_Capability ProcessorV2Config_Capability_Capability_MIN = ProcessorV2Config_Capability_GEO_REGISTER;
constexpr ProcessorV2Config_Capability ProcessorV2Config_Capability_Capability_MAX = ProcessorV2Config_Capability_TRACK;
constexpr int ProcessorV2Config_Capability_Capability_ARRAYSIZE = ProcessorV2Config_Capability_Capability_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ProcessorV2Config_Capability_descriptor();
template<typename T>
inline const std::string& ProcessorV2Config_Capability_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ProcessorV2Config_Capability>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ProcessorV2Config_Capability_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ProcessorV2Config_Capability_descriptor(), enum_t_value);
}
inline bool ProcessorV2Config_Capability_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ProcessorV2Config_Capability* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ProcessorV2Config_Capability>(
    ProcessorV2Config_Capability_descriptor(), name, value);
}
enum ImageFormat : int {
  RGB888 = 0,
  PNG = 1,
  TIFF = 2,
  BGR888 = 3,
  NITF21 = 4,
  ImageFormat_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  ImageFormat_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool ImageFormat_IsValid(int value);
constexpr ImageFormat ImageFormat_MIN = RGB888;
constexpr ImageFormat ImageFormat_MAX = NITF21;
constexpr int ImageFormat_ARRAYSIZE = ImageFormat_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ImageFormat_descriptor();
template<typename T>
inline const std::string& ImageFormat_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ImageFormat>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ImageFormat_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ImageFormat_descriptor(), enum_t_value);
}
inline bool ImageFormat_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ImageFormat* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ImageFormat>(
    ImageFormat_descriptor(), name, value);
}
// ===================================================================

class ProcessorV2Config PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:aip.processor.v2.ProcessorV2Config) */ {
 public:
  inline ProcessorV2Config() : ProcessorV2Config(nullptr) {}
  virtual ~ProcessorV2Config();

  ProcessorV2Config(const ProcessorV2Config& from);
  ProcessorV2Config(ProcessorV2Config&& from) noexcept
    : ProcessorV2Config() {
    *this = ::std::move(from);
  }

  inline ProcessorV2Config& operator=(const ProcessorV2Config& from) {
    CopyFrom(from);
    return *this;
  }
  inline ProcessorV2Config& operator=(ProcessorV2Config&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ProcessorV2Config& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ProcessorV2Config* internal_default_instance() {
    return reinterpret_cast<const ProcessorV2Config*>(
               &_ProcessorV2Config_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(ProcessorV2Config& a, ProcessorV2Config& b) {
    a.Swap(&b);
  }
  inline void Swap(ProcessorV2Config* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ProcessorV2Config* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ProcessorV2Config* New() const final {
    return CreateMaybeMessage<ProcessorV2Config>(nullptr);
  }

  ProcessorV2Config* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ProcessorV2Config>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ProcessorV2Config& from);
  void MergeFrom(const ProcessorV2Config& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ProcessorV2Config* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "aip.processor.v2.ProcessorV2Config";
  }
  protected:
  explicit ProcessorV2Config(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_proto_2fpalantir_2fprocessing_2dservice_2dv2_2eproto);
    return ::descriptor_table_proto_2fpalantir_2fprocessing_2dservice_2dv2_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef ProcessorV2Config_Capability Capability;
  static constexpr Capability GEO_REGISTER =
    ProcessorV2Config_Capability_GEO_REGISTER;
  static constexpr Capability INFER =
    ProcessorV2Config_Capability_INFER;
  static constexpr Capability TRACK =
    ProcessorV2Config_Capability_TRACK;
  static inline bool Capability_IsValid(int value) {
    return ProcessorV2Config_Capability_IsValid(value);
  }
  static constexpr Capability Capability_MIN =
    ProcessorV2Config_Capability_Capability_MIN;
  static constexpr Capability Capability_MAX =
    ProcessorV2Config_Capability_Capability_MAX;
  static constexpr int Capability_ARRAYSIZE =
    ProcessorV2Config_Capability_Capability_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Capability_descriptor() {
    return ProcessorV2Config_Capability_descriptor();
  }
  template<typename T>
  static inline const std::string& Capability_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Capability>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Capability_Name.");
    return ProcessorV2Config_Capability_Name(enum_t_value);
  }
  static inline bool Capability_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Capability* value) {
    return ProcessorV2Config_Capability_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kCapabilitiesFieldNumber = 2,
    kImageFormatFieldNumber = 1,
  };
  // repeated .aip.processor.v2.ProcessorV2Config.Capability capabilities = 2;
  int capabilities_size() const;
  private:
  int _internal_capabilities_size() const;
  public:
  void clear_capabilities();
  private:
  ::aip::processor::v2::ProcessorV2Config_Capability _internal_capabilities(int index) const;
  void _internal_add_capabilities(::aip::processor::v2::ProcessorV2Config_Capability value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>* _internal_mutable_capabilities();
  public:
  ::aip::processor::v2::ProcessorV2Config_Capability capabilities(int index) const;
  void set_capabilities(int index, ::aip::processor::v2::ProcessorV2Config_Capability value);
  void add_capabilities(::aip::processor::v2::ProcessorV2Config_Capability value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>& capabilities() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>* mutable_capabilities();

  // .aip.processor.v2.ImageFormat image_format = 1;
  void clear_image_format();
  ::aip::processor::v2::ImageFormat image_format() const;
  void set_image_format(::aip::processor::v2::ImageFormat value);
  private:
  ::aip::processor::v2::ImageFormat _internal_image_format() const;
  void _internal_set_image_format(::aip::processor::v2::ImageFormat value);
  public:

  // @@protoc_insertion_point(class_scope:aip.processor.v2.ProcessorV2Config)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int> capabilities_;
  mutable std::atomic<int> _capabilities_cached_byte_size_;
  int image_format_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_proto_2fpalantir_2fprocessing_2dservice_2dv2_2eproto;
};
// -------------------------------------------------------------------

class RequestHeader PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:aip.processor.v2.RequestHeader) */ {
 public:
  inline RequestHeader() : RequestHeader(nullptr) {}
  virtual ~RequestHeader();

  RequestHeader(const RequestHeader& from);
  RequestHeader(RequestHeader&& from) noexcept
    : RequestHeader() {
    *this = ::std::move(from);
  }

  inline RequestHeader& operator=(const RequestHeader& from) {
    CopyFrom(from);
    return *this;
  }
  inline RequestHeader& operator=(RequestHeader&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const RequestHeader& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RequestHeader* internal_default_instance() {
    return reinterpret_cast<const RequestHeader*>(
               &_RequestHeader_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(RequestHeader& a, RequestHeader& b) {
    a.Swap(&b);
  }
  inline void Swap(RequestHeader* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RequestHeader* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline RequestHeader* New() const final {
    return CreateMaybeMessage<RequestHeader>(nullptr);
  }

  RequestHeader* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<RequestHeader>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const RequestHeader& from);
  void MergeFrom(const RequestHeader& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RequestHeader* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "aip.processor.v2.RequestHeader";
  }
  protected:
  explicit RequestHeader(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_proto_2fpalantir_2fprocessing_2dservice_2dv2_2eproto);
    return ::descriptor_table_proto_2fpalantir_2fprocessing_2dservice_2dv2_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdentifierFieldNumber = 1,
    kDeadlineFieldNumber = 2,
    kTimestampFieldNumber = 3,
  };
  // .aip.processor.v2.Identifier identifier = 1;
  bool has_identifier() const;
  private:
  bool _internal_has_identifier() const;
  public:
  void clear_identifier();
  const ::aip::processor::v2::Identifier& identifier() const;
  ::aip::processor::v2::Identifier* release_identifier();
  ::aip::processor::v2::Identifier* mutable_identifier();
  void set_allocated_identifier(::aip::processor::v2::Identifier* identifier);
  private:
  const ::aip::processor::v2::Identifier& _internal_identifier() const;
  ::aip::processor::v2::Identifier* _internal_mutable_identifier();
  public:
  void unsafe_arena_set_allocated_identifier(
      ::aip::processor::v2::Identifier* identifier);
  ::aip::processor::v2::Identifier* unsafe_arena_release_identifier();

  // .google.protobuf.Duration deadline = 2;
  bool has_deadline() const;
  private:
  bool _internal_has_deadline() const;
  public:
  void clear_deadline();
  const PROTOBUF_NAMESPACE_ID::Duration& deadline() const;
  PROTOBUF_NAMESPACE_ID::Duration* release_deadline();
  PROTOBUF_NAMESPACE_ID::Duration* mutable_deadline();
  void set_allocated_deadline(PROTOBUF_NAMESPACE_ID::Duration* deadline);
  private:
  const PROTOBUF_NAMESPACE_ID::Duration& _internal_deadline() const;
  PROTOBUF_NAMESPACE_ID::Duration* _internal_mutable_deadline();
  public:
  void unsafe_arena_set_allocated_deadline(
      PROTOBUF_NAMESPACE_ID::Duration* deadline);
  PROTOBUF_NAMESPACE_ID::Duration* unsafe_arena_release_deadline();

  // .aip.processor.v2.Timestamp timestamp = 3;
  bool has_timestamp() const;
  private:
  bool _internal_has_timestamp() const;
  public:
  void clear_timestamp();
  const ::aip::processor::v2::Timestamp& timestamp() const;
  ::aip::processor::v2::Timestamp* release_timestamp();
  ::aip::processor::v2::Timestamp* mutable_timestamp();
  void set_allocated_timestamp(::aip::processor::v2::Timestamp* timestamp);
  private:
  const ::aip::processor::v2::Timestamp& _internal_timestamp() const;
  ::aip::processor::v2::Timestamp* _internal_mutable_timestamp();
  public:
  void unsafe_arena_set_allocated_timestamp(
      ::aip::processor::v2::Timestamp* timestamp);
  ::aip::processor::v2::Timestamp* unsafe_arena_release_timestamp();

  // @@protoc_insertion_point(class_scope:aip.processor.v2.RequestHeader)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::aip::processor::v2::Identifier* identifier_;
  PROTOBUF_NAMESPACE_ID::Duration* deadline_;
  ::aip::processor::v2::Timestamp* timestamp_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_proto_2fpalantir_2fprocessing_2dservice_2dv2_2eproto;
};
// -------------------------------------------------------------------

class Identifier PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:aip.processor.v2.Identifier) */ {
 public:
  inline Identifier() : Identifier(nullptr) {}
  virtual ~Identifier();

  Identifier(const Identifier& from);
  Identifier(Identifier&& from) noexcept
    : Identifier() {
    *this = ::std::move(from);
  }

  inline Identifier& operator=(const Identifier& from) {
    CopyFrom(from);
    return *this;
  }
  inline Identifier& operator=(Identifier&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Identifier& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Identifier* internal_default_instance() {
    return reinterpret_cast<const Identifier*>(
               &_Identifier_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(Identifier& a, Identifier& b) {
    a.Swap(&b);
  }
  inline void Swap(Identifier* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Identifier* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Identifier* New() const final {
    return CreateMaybeMessage<Identifier>(nullptr);
  }

  Identifier* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Identifier>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Identifier& from);
  void MergeFrom(const Identifier& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Identifier* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "aip.processor.v2.Identifier";
  }
  protected:
  explicit Identifier(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_proto_2fpalantir_2fprocessing_2dservice_2dv2_2eproto);
    return ::descriptor_table_proto_2fpalantir_2fprocessing_2dservice_2dv2_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStreamIdFieldNumber = 1,
    kFrameIdFieldNumber = 2,
  };
  // uint64 stream_id = 1;
  void clear_stream_id();
  ::PROTOBUF_NAMESPACE_ID::uint64 stream_id() const;
  void set_stream_id(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_stream_id() const;
  void _internal_set_stream_id(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // uint64 frame_id = 2;
  void clear_frame_id();
  ::PROTOBUF_NAMESPACE_ID::uint64 frame_id() const;
  void set_frame_id(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_frame_id() const;
  void _internal_set_frame_id(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // @@protoc_insertion_point(class_scope:aip.processor.v2.Identifier)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::uint64 stream_id_;
  ::PROTOBUF_NAMESPACE_ID::uint64 frame_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_proto_2fpalantir_2fprocessing_2dservice_2dv2_2eproto;
};
// -------------------------------------------------------------------

class Timestamp PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:aip.processor.v2.Timestamp) */ {
 public:
  inline Timestamp() : Timestamp(nullptr) {}
  virtual ~Timestamp();

  Timestamp(const Timestamp& from);
  Timestamp(Timestamp&& from) noexcept
    : Timestamp() {
    *this = ::std::move(from);
  }

  inline Timestamp& operator=(const Timestamp& from) {
    CopyFrom(from);
    return *this;
  }
  inline Timestamp& operator=(Timestamp&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Timestamp& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Timestamp* internal_default_instance() {
    return reinterpret_cast<const Timestamp*>(
               &_Timestamp_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(Timestamp& a, Timestamp& b) {
    a.Swap(&b);
  }
  inline void Swap(Timestamp* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Timestamp* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Timestamp* New() const final {
    return CreateMaybeMessage<Timestamp>(nullptr);
  }

  Timestamp* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Timestamp>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Timestamp& from);
  void MergeFrom(const Timestamp& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Timestamp* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "aip.processor.v2.Timestamp";
  }
  protected:
  explicit Timestamp(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_proto_2fpalantir_2fprocessing_2dservice_2dv2_2eproto);
    return ::descriptor_table_proto_2fpalantir_2fprocessing_2dservice_2dv2_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNanosFieldNumber = 1,
  };
  // uint64 nanos = 1;
  void clear_nanos();
  ::PROTOBUF_NAMESPACE_ID::uint64 nanos() const;
  void set_nanos(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_nanos() const;
  void _internal_set_nanos(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // @@protoc_insertion_point(class_scope:aip.processor.v2.Timestamp)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::uint64 nanos_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_proto_2fpalantir_2fprocessing_2dservice_2dv2_2eproto;
};
// -------------------------------------------------------------------

class GeoRegistrationRequest PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:aip.processor.v2.GeoRegistrationRequest) */ {
 public:
  inline GeoRegistrationRequest() : GeoRegistrationRequest(nullptr) {}
  virtual ~GeoRegistrationRequest();

  GeoRegistrationRequest(const GeoRegistrationRequest& from);
  GeoRegistrationRequest(GeoRegistrationRequest&& from) noexcept
    : GeoRegistrationRequest() {
    *this = ::std::move(from);
  }

  inline GeoRegistrationRequest& operator=(const GeoRegistrationRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GeoRegistrationRequest& operator=(GeoRegistrationRequest&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const GeoRegistrationRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GeoRegistrationRequest* internal_default_instance() {
    return reinterpret_cast<const GeoRegistrationRequest*>(
               &_GeoRegistrationRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(GeoRegistrationRequest& a, GeoRegistrationRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GeoRegistrationRequest* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GeoRegistrationRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GeoRegistrationRequest* New() const final {
    return CreateMaybeMessage<GeoRegistrationRequest>(nullptr);
  }

  GeoRegistrationRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GeoRegistrationRequest>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const GeoRegistrationRequest& from);
  void MergeFrom(const GeoRegistrationRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GeoRegistrationRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "aip.processor.v2.GeoRegistrationRequest";
  }
  protected:
  explicit GeoRegistrationRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_proto_2fpalantir_2fprocessing_2dservice_2dv2_2eproto);
    return ::descriptor_table_proto_2fpalantir_2fprocessing_2dservice_2dv2_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHeaderFieldNumber = 1,
    kFrameFieldNumber = 2,
  };
  // .aip.processor.v2.RequestHeader header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::aip::processor::v2::RequestHeader& header() const;
  ::aip::processor::v2::RequestHeader* release_header();
  ::aip::processor::v2::RequestHeader* mutable_header();
  void set_allocated_header(::aip::processor::v2::RequestHeader* header);
  private:
  const ::aip::processor::v2::RequestHeader& _internal_header() const;
  ::aip::processor::v2::RequestHeader* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::aip::processor::v2::RequestHeader* header);
  ::aip::processor::v2::RequestHeader* unsafe_arena_release_header();

  // .aip.processor.v2.Frame frame = 2;
  bool has_frame() const;
  private:
  bool _internal_has_frame() const;
  public:
  void clear_frame();
  const ::aip::processor::v2::Frame& frame() const;
  ::aip::processor::v2::Frame* release_frame();
  ::aip::processor::v2::Frame* mutable_frame();
  void set_allocated_frame(::aip::processor::v2::Frame* frame);
  private:
  const ::aip::processor::v2::Frame& _internal_frame() const;
  ::aip::processor::v2::Frame* _internal_mutable_frame();
  public:
  void unsafe_arena_set_allocated_frame(
      ::aip::processor::v2::Frame* frame);
  ::aip::processor::v2::Frame* unsafe_arena_release_frame();

  // @@protoc_insertion_point(class_scope:aip.processor.v2.GeoRegistrationRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::aip::processor::v2::RequestHeader* header_;
  ::aip::processor::v2::Frame* frame_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_proto_2fpalantir_2fprocessing_2dservice_2dv2_2eproto;
};
// -------------------------------------------------------------------

class GeoRegistrationResponse PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:aip.processor.v2.GeoRegistrationResponse) */ {
 public:
  inline GeoRegistrationResponse() : GeoRegistrationResponse(nullptr) {}
  virtual ~GeoRegistrationResponse();

  GeoRegistrationResponse(const GeoRegistrationResponse& from);
  GeoRegistrationResponse(GeoRegistrationResponse&& from) noexcept
    : GeoRegistrationResponse() {
    *this = ::std::move(from);
  }

  inline GeoRegistrationResponse& operator=(const GeoRegistrationResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GeoRegistrationResponse& operator=(GeoRegistrationResponse&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const GeoRegistrationResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GeoRegistrationResponse* internal_default_instance() {
    return reinterpret_cast<const GeoRegistrationResponse*>(
               &_GeoRegistrationResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(GeoRegistrationResponse& a, GeoRegistrationResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(GeoRegistrationResponse* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GeoRegistrationResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GeoRegistrationResponse* New() const final {
    return CreateMaybeMessage<GeoRegistrationResponse>(nullptr);
  }

  GeoRegistrationResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GeoRegistrationResponse>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const GeoRegistrationResponse& from);
  void MergeFrom(const GeoRegistrationResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GeoRegistrationResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "aip.processor.v2.GeoRegistrationResponse";
  }
  protected:
  explicit GeoRegistrationResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_proto_2fpalantir_2fprocessing_2dservice_2dv2_2eproto);
    return ::descriptor_table_proto_2fpalantir_2fprocessing_2dservice_2dv2_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdentifierFieldNumber = 1,
    kGeoRegistrationFieldNumber = 2,
  };
  // .aip.processor.v2.Identifier identifier = 1;
  bool has_identifier() const;
  private:
  bool _internal_has_identifier() const;
  public:
  void clear_identifier();
  const ::aip::processor::v2::Identifier& identifier() const;
  ::aip::processor::v2::Identifier* release_identifier();
  ::aip::processor::v2::Identifier* mutable_identifier();
  void set_allocated_identifier(::aip::processor::v2::Identifier* identifier);
  private:
  const ::aip::processor::v2::Identifier& _internal_identifier() const;
  ::aip::processor::v2::Identifier* _internal_mutable_identifier();
  public:
  void unsafe_arena_set_allocated_identifier(
      ::aip::processor::v2::Identifier* identifier);
  ::aip::processor::v2::Identifier* unsafe_arena_release_identifier();

  // .aip.processor.v2.GeoRegistration geo_registration = 2;
  bool has_geo_registration() const;
  private:
  bool _internal_has_geo_registration() const;
  public:
  void clear_geo_registration();
  const ::aip::processor::v2::GeoRegistration& geo_registration() const;
  ::aip::processor::v2::GeoRegistration* release_geo_registration();
  ::aip::processor::v2::GeoRegistration* mutable_geo_registration();
  void set_allocated_geo_registration(::aip::processor::v2::GeoRegistration* geo_registration);
  private:
  const ::aip::processor::v2::GeoRegistration& _internal_geo_registration() const;
  ::aip::processor::v2::GeoRegistration* _internal_mutable_geo_registration();
  public:
  void unsafe_arena_set_allocated_geo_registration(
      ::aip::processor::v2::GeoRegistration* geo_registration);
  ::aip::processor::v2::GeoRegistration* unsafe_arena_release_geo_registration();

  // @@protoc_insertion_point(class_scope:aip.processor.v2.GeoRegistrationResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::aip::processor::v2::Identifier* identifier_;
  ::aip::processor::v2::GeoRegistration* geo_registration_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_proto_2fpalantir_2fprocessing_2dservice_2dv2_2eproto;
};
// -------------------------------------------------------------------

class InferenceRequest PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:aip.processor.v2.InferenceRequest) */ {
 public:
  inline InferenceRequest() : InferenceRequest(nullptr) {}
  virtual ~InferenceRequest();

  InferenceRequest(const InferenceRequest& from);
  InferenceRequest(InferenceRequest&& from) noexcept
    : InferenceRequest() {
    *this = ::std::move(from);
  }

  inline InferenceRequest& operator=(const InferenceRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline InferenceRequest& operator=(InferenceRequest&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const InferenceRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const InferenceRequest* internal_default_instance() {
    return reinterpret_cast<const InferenceRequest*>(
               &_InferenceRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(InferenceRequest& a, InferenceRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(InferenceRequest* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(InferenceRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline InferenceRequest* New() const final {
    return CreateMaybeMessage<InferenceRequest>(nullptr);
  }

  InferenceRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<InferenceRequest>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const InferenceRequest& from);
  void MergeFrom(const InferenceRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(InferenceRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "aip.processor.v2.InferenceRequest";
  }
  protected:
  explicit InferenceRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_proto_2fpalantir_2fprocessing_2dservice_2dv2_2eproto);
    return ::descriptor_table_proto_2fpalantir_2fprocessing_2dservice_2dv2_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHeaderFieldNumber = 1,
    kFrameFieldNumber = 2,
  };
  // .aip.processor.v2.RequestHeader header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::aip::processor::v2::RequestHeader& header() const;
  ::aip::processor::v2::RequestHeader* release_header();
  ::aip::processor::v2::RequestHeader* mutable_header();
  void set_allocated_header(::aip::processor::v2::RequestHeader* header);
  private:
  const ::aip::processor::v2::RequestHeader& _internal_header() const;
  ::aip::processor::v2::RequestHeader* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::aip::processor::v2::RequestHeader* header);
  ::aip::processor::v2::RequestHeader* unsafe_arena_release_header();

  // .aip.processor.v2.Frame frame = 2;
  bool has_frame() const;
  private:
  bool _internal_has_frame() const;
  public:
  void clear_frame();
  const ::aip::processor::v2::Frame& frame() const;
  ::aip::processor::v2::Frame* release_frame();
  ::aip::processor::v2::Frame* mutable_frame();
  void set_allocated_frame(::aip::processor::v2::Frame* frame);
  private:
  const ::aip::processor::v2::Frame& _internal_frame() const;
  ::aip::processor::v2::Frame* _internal_mutable_frame();
  public:
  void unsafe_arena_set_allocated_frame(
      ::aip::processor::v2::Frame* frame);
  ::aip::processor::v2::Frame* unsafe_arena_release_frame();

  // @@protoc_insertion_point(class_scope:aip.processor.v2.InferenceRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::aip::processor::v2::RequestHeader* header_;
  ::aip::processor::v2::Frame* frame_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_proto_2fpalantir_2fprocessing_2dservice_2dv2_2eproto;
};
// -------------------------------------------------------------------

class InferenceResponse PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:aip.processor.v2.InferenceResponse) */ {
 public:
  inline InferenceResponse() : InferenceResponse(nullptr) {}
  virtual ~InferenceResponse();

  InferenceResponse(const InferenceResponse& from);
  InferenceResponse(InferenceResponse&& from) noexcept
    : InferenceResponse() {
    *this = ::std::move(from);
  }

  inline InferenceResponse& operator=(const InferenceResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline InferenceResponse& operator=(InferenceResponse&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const InferenceResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const InferenceResponse* internal_default_instance() {
    return reinterpret_cast<const InferenceResponse*>(
               &_InferenceResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(InferenceResponse& a, InferenceResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(InferenceResponse* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(InferenceResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline InferenceResponse* New() const final {
    return CreateMaybeMessage<InferenceResponse>(nullptr);
  }

  InferenceResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<InferenceResponse>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const InferenceResponse& from);
  void MergeFrom(const InferenceResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(InferenceResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "aip.processor.v2.InferenceResponse";
  }
  protected:
  explicit InferenceResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_proto_2fpalantir_2fprocessing_2dservice_2dv2_2eproto);
    return ::descriptor_table_proto_2fpalantir_2fprocessing_2dservice_2dv2_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdentifierFieldNumber = 1,
    kInferencesFieldNumber = 2,
  };
  // .aip.processor.v2.Identifier identifier = 1;
  bool has_identifier() const;
  private:
  bool _internal_has_identifier() const;
  public:
  void clear_identifier();
  const ::aip::processor::v2::Identifier& identifier() const;
  ::aip::processor::v2::Identifier* release_identifier();
  ::aip::processor::v2::Identifier* mutable_identifier();
  void set_allocated_identifier(::aip::processor::v2::Identifier* identifier);
  private:
  const ::aip::processor::v2::Identifier& _internal_identifier() const;
  ::aip::processor::v2::Identifier* _internal_mutable_identifier();
  public:
  void unsafe_arena_set_allocated_identifier(
      ::aip::processor::v2::Identifier* identifier);
  ::aip::processor::v2::Identifier* unsafe_arena_release_identifier();

  // .aip.processor.v2.Inferences inferences = 2;
  bool has_inferences() const;
  private:
  bool _internal_has_inferences() const;
  public:
  void clear_inferences();
  const ::aip::processor::v2::Inferences& inferences() const;
  ::aip::processor::v2::Inferences* release_inferences();
  ::aip::processor::v2::Inferences* mutable_inferences();
  void set_allocated_inferences(::aip::processor::v2::Inferences* inferences);
  private:
  const ::aip::processor::v2::Inferences& _internal_inferences() const;
  ::aip::processor::v2::Inferences* _internal_mutable_inferences();
  public:
  void unsafe_arena_set_allocated_inferences(
      ::aip::processor::v2::Inferences* inferences);
  ::aip::processor::v2::Inferences* unsafe_arena_release_inferences();

  // @@protoc_insertion_point(class_scope:aip.processor.v2.InferenceResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::aip::processor::v2::Identifier* identifier_;
  ::aip::processor::v2::Inferences* inferences_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_proto_2fpalantir_2fprocessing_2dservice_2dv2_2eproto;
};
// -------------------------------------------------------------------

class TrackRequest PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:aip.processor.v2.TrackRequest) */ {
 public:
  inline TrackRequest() : TrackRequest(nullptr) {}
  virtual ~TrackRequest();

  TrackRequest(const TrackRequest& from);
  TrackRequest(TrackRequest&& from) noexcept
    : TrackRequest() {
    *this = ::std::move(from);
  }

  inline TrackRequest& operator=(const TrackRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline TrackRequest& operator=(TrackRequest&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const TrackRequest& default_instance();

  enum MaybeInferencesCase {
    kInferences = 3,
    MAYBE_INFERENCES_NOT_SET = 0,
  };

  enum MaybeGeoRegistrationCase {
    kGeoRegistration = 4,
    MAYBE_GEO_REGISTRATION_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TrackRequest* internal_default_instance() {
    return reinterpret_cast<const TrackRequest*>(
               &_TrackRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(TrackRequest& a, TrackRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(TrackRequest* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TrackRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline TrackRequest* New() const final {
    return CreateMaybeMessage<TrackRequest>(nullptr);
  }

  TrackRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<TrackRequest>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const TrackRequest& from);
  void MergeFrom(const TrackRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TrackRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "aip.processor.v2.TrackRequest";
  }
  protected:
  explicit TrackRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_proto_2fpalantir_2fprocessing_2dservice_2dv2_2eproto);
    return ::descriptor_table_proto_2fpalantir_2fprocessing_2dservice_2dv2_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHeaderFieldNumber = 1,
    kFrameFieldNumber = 2,
    kInferencesFieldNumber = 3,
    kGeoRegistrationFieldNumber = 4,
  };
  // .aip.processor.v2.RequestHeader header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::aip::processor::v2::RequestHeader& header() const;
  ::aip::processor::v2::RequestHeader* release_header();
  ::aip::processor::v2::RequestHeader* mutable_header();
  void set_allocated_header(::aip::processor::v2::RequestHeader* header);
  private:
  const ::aip::processor::v2::RequestHeader& _internal_header() const;
  ::aip::processor::v2::RequestHeader* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::aip::processor::v2::RequestHeader* header);
  ::aip::processor::v2::RequestHeader* unsafe_arena_release_header();

  // .aip.processor.v2.Frame frame = 2;
  bool has_frame() const;
  private:
  bool _internal_has_frame() const;
  public:
  void clear_frame();
  const ::aip::processor::v2::Frame& frame() const;
  ::aip::processor::v2::Frame* release_frame();
  ::aip::processor::v2::Frame* mutable_frame();
  void set_allocated_frame(::aip::processor::v2::Frame* frame);
  private:
  const ::aip::processor::v2::Frame& _internal_frame() const;
  ::aip::processor::v2::Frame* _internal_mutable_frame();
  public:
  void unsafe_arena_set_allocated_frame(
      ::aip::processor::v2::Frame* frame);
  ::aip::processor::v2::Frame* unsafe_arena_release_frame();

  // .aip.processor.v2.Inferences inferences = 3;
  bool has_inferences() const;
  private:
  bool _internal_has_inferences() const;
  public:
  void clear_inferences();
  const ::aip::processor::v2::Inferences& inferences() const;
  ::aip::processor::v2::Inferences* release_inferences();
  ::aip::processor::v2::Inferences* mutable_inferences();
  void set_allocated_inferences(::aip::processor::v2::Inferences* inferences);
  private:
  const ::aip::processor::v2::Inferences& _internal_inferences() const;
  ::aip::processor::v2::Inferences* _internal_mutable_inferences();
  public:
  void unsafe_arena_set_allocated_inferences(
      ::aip::processor::v2::Inferences* inferences);
  ::aip::processor::v2::Inferences* unsafe_arena_release_inferences();

  // .aip.processor.v2.GeoRegistration geo_registration = 4;
  bool has_geo_registration() const;
  private:
  bool _internal_has_geo_registration() const;
  public:
  void clear_geo_registration();
  const ::aip::processor::v2::GeoRegistration& geo_registration() const;
  ::aip::processor::v2::GeoRegistration* release_geo_registration();
  ::aip::processor::v2::GeoRegistration* mutable_geo_registration();
  void set_allocated_geo_registration(::aip::processor::v2::GeoRegistration* geo_registration);
  private:
  const ::aip::processor::v2::GeoRegistration& _internal_geo_registration() const;
  ::aip::processor::v2::GeoRegistration* _internal_mutable_geo_registration();
  public:
  void unsafe_arena_set_allocated_geo_registration(
      ::aip::processor::v2::GeoRegistration* geo_registration);
  ::aip::processor::v2::GeoRegistration* unsafe_arena_release_geo_registration();

  void clear_maybe_inferences();
  MaybeInferencesCase maybe_inferences_case() const;
  void clear_maybe_geo_registration();
  MaybeGeoRegistrationCase maybe_geo_registration_case() const;
  // @@protoc_insertion_point(class_scope:aip.processor.v2.TrackRequest)
 private:
  class _Internal;
  void set_has_inferences();
  void set_has_geo_registration();

  inline bool has_maybe_inferences() const;
  inline void clear_has_maybe_inferences();

  inline bool has_maybe_geo_registration() const;
  inline void clear_has_maybe_geo_registration();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::aip::processor::v2::RequestHeader* header_;
  ::aip::processor::v2::Frame* frame_;
  union MaybeInferencesUnion {
    MaybeInferencesUnion() {}
    ::aip::processor::v2::Inferences* inferences_;
  } maybe_inferences_;
  union MaybeGeoRegistrationUnion {
    MaybeGeoRegistrationUnion() {}
    ::aip::processor::v2::GeoRegistration* geo_registration_;
  } maybe_geo_registration_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint32 _oneof_case_[2];

  friend struct ::TableStruct_proto_2fpalantir_2fprocessing_2dservice_2dv2_2eproto;
};
// -------------------------------------------------------------------

class GeoRegistration PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:aip.processor.v2.GeoRegistration) */ {
 public:
  inline GeoRegistration() : GeoRegistration(nullptr) {}
  virtual ~GeoRegistration();

  GeoRegistration(const GeoRegistration& from);
  GeoRegistration(GeoRegistration&& from) noexcept
    : GeoRegistration() {
    *this = ::std::move(from);
  }

  inline GeoRegistration& operator=(const GeoRegistration& from) {
    CopyFrom(from);
    return *this;
  }
  inline GeoRegistration& operator=(GeoRegistration&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const GeoRegistration& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GeoRegistration* internal_default_instance() {
    return reinterpret_cast<const GeoRegistration*>(
               &_GeoRegistration_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(GeoRegistration& a, GeoRegistration& b) {
    a.Swap(&b);
  }
  inline void Swap(GeoRegistration* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GeoRegistration* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GeoRegistration* New() const final {
    return CreateMaybeMessage<GeoRegistration>(nullptr);
  }

  GeoRegistration* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GeoRegistration>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const GeoRegistration& from);
  void MergeFrom(const GeoRegistration& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GeoRegistration* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "aip.processor.v2.GeoRegistration";
  }
  protected:
  explicit GeoRegistration(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_proto_2fpalantir_2fprocessing_2dservice_2dv2_2eproto);
    return ::descriptor_table_proto_2fpalantir_2fprocessing_2dservice_2dv2_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLatticeFieldNumber = 1,
    kUpdatedMetadataFieldNumber = 3,
    kConfidenceFieldNumber = 2,
  };
  // .aip.processor.v2.Lattice lattice = 1;
  bool has_lattice() const;
  private:
  bool _internal_has_lattice() const;
  public:
  void clear_lattice();
  const ::aip::processor::v2::Lattice& lattice() const;
  ::aip::processor::v2::Lattice* release_lattice();
  ::aip::processor::v2::Lattice* mutable_lattice();
  void set_allocated_lattice(::aip::processor::v2::Lattice* lattice);
  private:
  const ::aip::processor::v2::Lattice& _internal_lattice() const;
  ::aip::processor::v2::Lattice* _internal_mutable_lattice();
  public:
  void unsafe_arena_set_allocated_lattice(
      ::aip::processor::v2::Lattice* lattice);
  ::aip::processor::v2::Lattice* unsafe_arena_release_lattice();

  // .aip.processor.v2.UasMetadata updatedMetadata = 3;
  bool has_updatedmetadata() const;
  private:
  bool _internal_has_updatedmetadata() const;
  public:
  void clear_updatedmetadata();
  const ::aip::processor::v2::UasMetadata& updatedmetadata() const;
  ::aip::processor::v2::UasMetadata* release_updatedmetadata();
  ::aip::processor::v2::UasMetadata* mutable_updatedmetadata();
  void set_allocated_updatedmetadata(::aip::processor::v2::UasMetadata* updatedmetadata);
  private:
  const ::aip::processor::v2::UasMetadata& _internal_updatedmetadata() const;
  ::aip::processor::v2::UasMetadata* _internal_mutable_updatedmetadata();
  public:
  void unsafe_arena_set_allocated_updatedmetadata(
      ::aip::processor::v2::UasMetadata* updatedmetadata);
  ::aip::processor::v2::UasMetadata* unsafe_arena_release_updatedmetadata();

  // double confidence = 2;
  void clear_confidence();
  double confidence() const;
  void set_confidence(double value);
  private:
  double _internal_confidence() const;
  void _internal_set_confidence(double value);
  public:

  // @@protoc_insertion_point(class_scope:aip.processor.v2.GeoRegistration)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::aip::processor::v2::Lattice* lattice_;
  ::aip::processor::v2::UasMetadata* updatedmetadata_;
  double confidence_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_proto_2fpalantir_2fprocessing_2dservice_2dv2_2eproto;
};
// -------------------------------------------------------------------

class Inferences PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:aip.processor.v2.Inferences) */ {
 public:
  inline Inferences() : Inferences(nullptr) {}
  virtual ~Inferences();

  Inferences(const Inferences& from);
  Inferences(Inferences&& from) noexcept
    : Inferences() {
    *this = ::std::move(from);
  }

  inline Inferences& operator=(const Inferences& from) {
    CopyFrom(from);
    return *this;
  }
  inline Inferences& operator=(Inferences&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Inferences& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Inferences* internal_default_instance() {
    return reinterpret_cast<const Inferences*>(
               &_Inferences_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(Inferences& a, Inferences& b) {
    a.Swap(&b);
  }
  inline void Swap(Inferences* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Inferences* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Inferences* New() const final {
    return CreateMaybeMessage<Inferences>(nullptr);
  }

  Inferences* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Inferences>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Inferences& from);
  void MergeFrom(const Inferences& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Inferences* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "aip.processor.v2.Inferences";
  }
  protected:
  explicit Inferences(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_proto_2fpalantir_2fprocessing_2dservice_2dv2_2eproto);
    return ::descriptor_table_proto_2fpalantir_2fprocessing_2dservice_2dv2_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kInferenceFieldNumber = 1,
  };
  // repeated .aip.processor.v2.Inference inference = 1;
  int inference_size() const;
  private:
  int _internal_inference_size() const;
  public:
  void clear_inference();
  ::aip::processor::v2::Inference* mutable_inference(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::aip::processor::v2::Inference >*
      mutable_inference();
  private:
  const ::aip::processor::v2::Inference& _internal_inference(int index) const;
  ::aip::processor::v2::Inference* _internal_add_inference();
  public:
  const ::aip::processor::v2::Inference& inference(int index) const;
  ::aip::processor::v2::Inference* add_inference();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::aip::processor::v2::Inference >&
      inference() const;

  // @@protoc_insertion_point(class_scope:aip.processor.v2.Inferences)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::aip::processor::v2::Inference > inference_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_proto_2fpalantir_2fprocessing_2dservice_2dv2_2eproto;
};
// -------------------------------------------------------------------

class Inference PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:aip.processor.v2.Inference) */ {
 public:
  inline Inference() : Inference(nullptr) {}
  virtual ~Inference();

  Inference(const Inference& from);
  Inference(Inference&& from) noexcept
    : Inference() {
    *this = ::std::move(from);
  }

  inline Inference& operator=(const Inference& from) {
    CopyFrom(from);
    return *this;
  }
  inline Inference& operator=(Inference&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Inference& default_instance();

  enum InferenceCase {
    kBox = 2,
    kPolygon = 3,
    kGeoBox = 5,
    kGeoPolygon = 6,
    INFERENCE_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Inference* internal_default_instance() {
    return reinterpret_cast<const Inference*>(
               &_Inference_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(Inference& a, Inference& b) {
    a.Swap(&b);
  }
  inline void Swap(Inference* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Inference* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Inference* New() const final {
    return CreateMaybeMessage<Inference>(nullptr);
  }

  Inference* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Inference>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Inference& from);
  void MergeFrom(const Inference& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Inference* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "aip.processor.v2.Inference";
  }
  protected:
  explicit Inference(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_proto_2fpalantir_2fprocessing_2dservice_2dv2_2eproto);
    return ::descriptor_table_proto_2fpalantir_2fprocessing_2dservice_2dv2_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kInferenceIdFieldNumber = 1,
    kVelocityFieldNumber = 4,
    kBoxFieldNumber = 2,
    kPolygonFieldNumber = 3,
    kGeoBoxFieldNumber = 5,
    kGeoPolygonFieldNumber = 6,
  };
  // string inferenceId = 1;
  void clear_inferenceid();
  const std::string& inferenceid() const;
  void set_inferenceid(const std::string& value);
  void set_inferenceid(std::string&& value);
  void set_inferenceid(const char* value);
  void set_inferenceid(const char* value, size_t size);
  std::string* mutable_inferenceid();
  std::string* release_inferenceid();
  void set_allocated_inferenceid(std::string* inferenceid);
  private:
  const std::string& _internal_inferenceid() const;
  void _internal_set_inferenceid(const std::string& value);
  std::string* _internal_mutable_inferenceid();
  public:

  // .aip.processor.v2.Velocity velocity = 4;
  bool has_velocity() const;
  private:
  bool _internal_has_velocity() const;
  public:
  void clear_velocity();
  const ::aip::processor::v2::Velocity& velocity() const;
  ::aip::processor::v2::Velocity* release_velocity();
  ::aip::processor::v2::Velocity* mutable_velocity();
  void set_allocated_velocity(::aip::processor::v2::Velocity* velocity);
  private:
  const ::aip::processor::v2::Velocity& _internal_velocity() const;
  ::aip::processor::v2::Velocity* _internal_mutable_velocity();
  public:
  void unsafe_arena_set_allocated_velocity(
      ::aip::processor::v2::Velocity* velocity);
  ::aip::processor::v2::Velocity* unsafe_arena_release_velocity();

  // .aip.processor.v2.BoundingBox box = 2;
  bool has_box() const;
  private:
  bool _internal_has_box() const;
  public:
  void clear_box();
  const ::aip::processor::v2::BoundingBox& box() const;
  ::aip::processor::v2::BoundingBox* release_box();
  ::aip::processor::v2::BoundingBox* mutable_box();
  void set_allocated_box(::aip::processor::v2::BoundingBox* box);
  private:
  const ::aip::processor::v2::BoundingBox& _internal_box() const;
  ::aip::processor::v2::BoundingBox* _internal_mutable_box();
  public:
  void unsafe_arena_set_allocated_box(
      ::aip::processor::v2::BoundingBox* box);
  ::aip::processor::v2::BoundingBox* unsafe_arena_release_box();

  // .aip.processor.v2.BoundingPolygon polygon = 3;
  bool has_polygon() const;
  private:
  bool _internal_has_polygon() const;
  public:
  void clear_polygon();
  const ::aip::processor::v2::BoundingPolygon& polygon() const;
  ::aip::processor::v2::BoundingPolygon* release_polygon();
  ::aip::processor::v2::BoundingPolygon* mutable_polygon();
  void set_allocated_polygon(::aip::processor::v2::BoundingPolygon* polygon);
  private:
  const ::aip::processor::v2::BoundingPolygon& _internal_polygon() const;
  ::aip::processor::v2::BoundingPolygon* _internal_mutable_polygon();
  public:
  void unsafe_arena_set_allocated_polygon(
      ::aip::processor::v2::BoundingPolygon* polygon);
  ::aip::processor::v2::BoundingPolygon* unsafe_arena_release_polygon();

  // .aip.processor.v2.GeoBoundingBox geo_box = 5;
  bool has_geo_box() const;
  private:
  bool _internal_has_geo_box() const;
  public:
  void clear_geo_box();
  const ::aip::processor::v2::GeoBoundingBox& geo_box() const;
  ::aip::processor::v2::GeoBoundingBox* release_geo_box();
  ::aip::processor::v2::GeoBoundingBox* mutable_geo_box();
  void set_allocated_geo_box(::aip::processor::v2::GeoBoundingBox* geo_box);
  private:
  const ::aip::processor::v2::GeoBoundingBox& _internal_geo_box() const;
  ::aip::processor::v2::GeoBoundingBox* _internal_mutable_geo_box();
  public:
  void unsafe_arena_set_allocated_geo_box(
      ::aip::processor::v2::GeoBoundingBox* geo_box);
  ::aip::processor::v2::GeoBoundingBox* unsafe_arena_release_geo_box();

  // .aip.processor.v2.GeoBoundingPolygon geo_polygon = 6;
  bool has_geo_polygon() const;
  private:
  bool _internal_has_geo_polygon() const;
  public:
  void clear_geo_polygon();
  const ::aip::processor::v2::GeoBoundingPolygon& geo_polygon() const;
  ::aip::processor::v2::GeoBoundingPolygon* release_geo_polygon();
  ::aip::processor::v2::GeoBoundingPolygon* mutable_geo_polygon();
  void set_allocated_geo_polygon(::aip::processor::v2::GeoBoundingPolygon* geo_polygon);
  private:
  const ::aip::processor::v2::GeoBoundingPolygon& _internal_geo_polygon() const;
  ::aip::processor::v2::GeoBoundingPolygon* _internal_mutable_geo_polygon();
  public:
  void unsafe_arena_set_allocated_geo_polygon(
      ::aip::processor::v2::GeoBoundingPolygon* geo_polygon);
  ::aip::processor::v2::GeoBoundingPolygon* unsafe_arena_release_geo_polygon();

  void clear_inference();
  InferenceCase inference_case() const;
  // @@protoc_insertion_point(class_scope:aip.processor.v2.Inference)
 private:
  class _Internal;
  void set_has_box();
  void set_has_polygon();
  void set_has_geo_box();
  void set_has_geo_polygon();

  inline bool has_inference() const;
  inline void clear_has_inference();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr inferenceid_;
  ::aip::processor::v2::Velocity* velocity_;
  union InferenceUnion {
    InferenceUnion() {}
    ::aip::processor::v2::BoundingBox* box_;
    ::aip::processor::v2::BoundingPolygon* polygon_;
    ::aip::processor::v2::GeoBoundingBox* geo_box_;
    ::aip::processor::v2::GeoBoundingPolygon* geo_polygon_;
  } inference_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint32 _oneof_case_[1];

  friend struct ::TableStruct_proto_2fpalantir_2fprocessing_2dservice_2dv2_2eproto;
};
// -------------------------------------------------------------------

class GeoCoordinate PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:aip.processor.v2.GeoCoordinate) */ {
 public:
  inline GeoCoordinate() : GeoCoordinate(nullptr) {}
  virtual ~GeoCoordinate();

  GeoCoordinate(const GeoCoordinate& from);
  GeoCoordinate(GeoCoordinate&& from) noexcept
    : GeoCoordinate() {
    *this = ::std::move(from);
  }

  inline GeoCoordinate& operator=(const GeoCoordinate& from) {
    CopyFrom(from);
    return *this;
  }
  inline GeoCoordinate& operator=(GeoCoordinate&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const GeoCoordinate& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GeoCoordinate* internal_default_instance() {
    return reinterpret_cast<const GeoCoordinate*>(
               &_GeoCoordinate_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(GeoCoordinate& a, GeoCoordinate& b) {
    a.Swap(&b);
  }
  inline void Swap(GeoCoordinate* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GeoCoordinate* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GeoCoordinate* New() const final {
    return CreateMaybeMessage<GeoCoordinate>(nullptr);
  }

  GeoCoordinate* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GeoCoordinate>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const GeoCoordinate& from);
  void MergeFrom(const GeoCoordinate& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GeoCoordinate* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "aip.processor.v2.GeoCoordinate";
  }
  protected:
  explicit GeoCoordinate(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_proto_2fpalantir_2fprocessing_2dservice_2dv2_2eproto);
    return ::descriptor_table_proto_2fpalantir_2fprocessing_2dservice_2dv2_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLatitudeFieldNumber = 1,
    kLongitudeFieldNumber = 2,
  };
  // double latitude = 1;
  void clear_latitude();
  double latitude() const;
  void set_latitude(double value);
  private:
  double _internal_latitude() const;
  void _internal_set_latitude(double value);
  public:

  // double longitude = 2;
  void clear_longitude();
  double longitude() const;
  void set_longitude(double value);
  private:
  double _internal_longitude() const;
  void _internal_set_longitude(double value);
  public:

  // @@protoc_insertion_point(class_scope:aip.processor.v2.GeoCoordinate)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  double latitude_;
  double longitude_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_proto_2fpalantir_2fprocessing_2dservice_2dv2_2eproto;
};
// -------------------------------------------------------------------

class BoundingBox PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:aip.processor.v2.BoundingBox) */ {
 public:
  inline BoundingBox() : BoundingBox(nullptr) {}
  virtual ~BoundingBox();

  BoundingBox(const BoundingBox& from);
  BoundingBox(BoundingBox&& from) noexcept
    : BoundingBox() {
    *this = ::std::move(from);
  }

  inline BoundingBox& operator=(const BoundingBox& from) {
    CopyFrom(from);
    return *this;
  }
  inline BoundingBox& operator=(BoundingBox&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const BoundingBox& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const BoundingBox* internal_default_instance() {
    return reinterpret_cast<const BoundingBox*>(
               &_BoundingBox_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(BoundingBox& a, BoundingBox& b) {
    a.Swap(&b);
  }
  inline void Swap(BoundingBox* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BoundingBox* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline BoundingBox* New() const final {
    return CreateMaybeMessage<BoundingBox>(nullptr);
  }

  BoundingBox* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<BoundingBox>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const BoundingBox& from);
  void MergeFrom(const BoundingBox& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BoundingBox* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "aip.processor.v2.BoundingBox";
  }
  protected:
  explicit BoundingBox(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_proto_2fpalantir_2fprocessing_2dservice_2dv2_2eproto);
    return ::descriptor_table_proto_2fpalantir_2fprocessing_2dservice_2dv2_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kClassificationsFieldNumber = 3,
    kC0FieldNumber = 1,
    kC1FieldNumber = 2,
  };
  // repeated .aip.processor.v2.Classification classifications = 3;
  int classifications_size() const;
  private:
  int _internal_classifications_size() const;
  public:
  void clear_classifications();
  ::aip::processor::v2::Classification* mutable_classifications(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::aip::processor::v2::Classification >*
      mutable_classifications();
  private:
  const ::aip::processor::v2::Classification& _internal_classifications(int index) const;
  ::aip::processor::v2::Classification* _internal_add_classifications();
  public:
  const ::aip::processor::v2::Classification& classifications(int index) const;
  ::aip::processor::v2::Classification* add_classifications();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::aip::processor::v2::Classification >&
      classifications() const;

  // .aip.processor.v2.UnitCoordinate c0 = 1;
  bool has_c0() const;
  private:
  bool _internal_has_c0() const;
  public:
  void clear_c0();
  const ::aip::processor::v2::UnitCoordinate& c0() const;
  ::aip::processor::v2::UnitCoordinate* release_c0();
  ::aip::processor::v2::UnitCoordinate* mutable_c0();
  void set_allocated_c0(::aip::processor::v2::UnitCoordinate* c0);
  private:
  const ::aip::processor::v2::UnitCoordinate& _internal_c0() const;
  ::aip::processor::v2::UnitCoordinate* _internal_mutable_c0();
  public:
  void unsafe_arena_set_allocated_c0(
      ::aip::processor::v2::UnitCoordinate* c0);
  ::aip::processor::v2::UnitCoordinate* unsafe_arena_release_c0();

  // .aip.processor.v2.UnitCoordinate c1 = 2;
  bool has_c1() const;
  private:
  bool _internal_has_c1() const;
  public:
  void clear_c1();
  const ::aip::processor::v2::UnitCoordinate& c1() const;
  ::aip::processor::v2::UnitCoordinate* release_c1();
  ::aip::processor::v2::UnitCoordinate* mutable_c1();
  void set_allocated_c1(::aip::processor::v2::UnitCoordinate* c1);
  private:
  const ::aip::processor::v2::UnitCoordinate& _internal_c1() const;
  ::aip::processor::v2::UnitCoordinate* _internal_mutable_c1();
  public:
  void unsafe_arena_set_allocated_c1(
      ::aip::processor::v2::UnitCoordinate* c1);
  ::aip::processor::v2::UnitCoordinate* unsafe_arena_release_c1();

  // @@protoc_insertion_point(class_scope:aip.processor.v2.BoundingBox)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::aip::processor::v2::Classification > classifications_;
  ::aip::processor::v2::UnitCoordinate* c0_;
  ::aip::processor::v2::UnitCoordinate* c1_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_proto_2fpalantir_2fprocessing_2dservice_2dv2_2eproto;
};
// -------------------------------------------------------------------

class GeoBoundingBox PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:aip.processor.v2.GeoBoundingBox) */ {
 public:
  inline GeoBoundingBox() : GeoBoundingBox(nullptr) {}
  virtual ~GeoBoundingBox();

  GeoBoundingBox(const GeoBoundingBox& from);
  GeoBoundingBox(GeoBoundingBox&& from) noexcept
    : GeoBoundingBox() {
    *this = ::std::move(from);
  }

  inline GeoBoundingBox& operator=(const GeoBoundingBox& from) {
    CopyFrom(from);
    return *this;
  }
  inline GeoBoundingBox& operator=(GeoBoundingBox&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const GeoBoundingBox& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GeoBoundingBox* internal_default_instance() {
    return reinterpret_cast<const GeoBoundingBox*>(
               &_GeoBoundingBox_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(GeoBoundingBox& a, GeoBoundingBox& b) {
    a.Swap(&b);
  }
  inline void Swap(GeoBoundingBox* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GeoBoundingBox* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GeoBoundingBox* New() const final {
    return CreateMaybeMessage<GeoBoundingBox>(nullptr);
  }

  GeoBoundingBox* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GeoBoundingBox>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const GeoBoundingBox& from);
  void MergeFrom(const GeoBoundingBox& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GeoBoundingBox* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "aip.processor.v2.GeoBoundingBox";
  }
  protected:
  explicit GeoBoundingBox(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_proto_2fpalantir_2fprocessing_2dservice_2dv2_2eproto);
    return ::descriptor_table_proto_2fpalantir_2fprocessing_2dservice_2dv2_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kClassificationsFieldNumber = 3,
    kC0FieldNumber = 1,
    kC1FieldNumber = 2,
  };
  // repeated .aip.processor.v2.Classification classifications = 3;
  int classifications_size() const;
  private:
  int _internal_classifications_size() const;
  public:
  void clear_classifications();
  ::aip::processor::v2::Classification* mutable_classifications(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::aip::processor::v2::Classification >*
      mutable_classifications();
  private:
  const ::aip::processor::v2::Classification& _internal_classifications(int index) const;
  ::aip::processor::v2::Classification* _internal_add_classifications();
  public:
  const ::aip::processor::v2::Classification& classifications(int index) const;
  ::aip::processor::v2::Classification* add_classifications();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::aip::processor::v2::Classification >&
      classifications() const;

  // .aip.processor.v2.GeoCoordinate c0 = 1;
  bool has_c0() const;
  private:
  bool _internal_has_c0() const;
  public:
  void clear_c0();
  const ::aip::processor::v2::GeoCoordinate& c0() const;
  ::aip::processor::v2::GeoCoordinate* release_c0();
  ::aip::processor::v2::GeoCoordinate* mutable_c0();
  void set_allocated_c0(::aip::processor::v2::GeoCoordinate* c0);
  private:
  const ::aip::processor::v2::GeoCoordinate& _internal_c0() const;
  ::aip::processor::v2::GeoCoordinate* _internal_mutable_c0();
  public:
  void unsafe_arena_set_allocated_c0(
      ::aip::processor::v2::GeoCoordinate* c0);
  ::aip::processor::v2::GeoCoordinate* unsafe_arena_release_c0();

  // .aip.processor.v2.GeoCoordinate c1 = 2;
  bool has_c1() const;
  private:
  bool _internal_has_c1() const;
  public:
  void clear_c1();
  const ::aip::processor::v2::GeoCoordinate& c1() const;
  ::aip::processor::v2::GeoCoordinate* release_c1();
  ::aip::processor::v2::GeoCoordinate* mutable_c1();
  void set_allocated_c1(::aip::processor::v2::GeoCoordinate* c1);
  private:
  const ::aip::processor::v2::GeoCoordinate& _internal_c1() const;
  ::aip::processor::v2::GeoCoordinate* _internal_mutable_c1();
  public:
  void unsafe_arena_set_allocated_c1(
      ::aip::processor::v2::GeoCoordinate* c1);
  ::aip::processor::v2::GeoCoordinate* unsafe_arena_release_c1();

  // @@protoc_insertion_point(class_scope:aip.processor.v2.GeoBoundingBox)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::aip::processor::v2::Classification > classifications_;
  ::aip::processor::v2::GeoCoordinate* c0_;
  ::aip::processor::v2::GeoCoordinate* c1_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_proto_2fpalantir_2fprocessing_2dservice_2dv2_2eproto;
};
// -------------------------------------------------------------------

class BoundingPolygon PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:aip.processor.v2.BoundingPolygon) */ {
 public:
  inline BoundingPolygon() : BoundingPolygon(nullptr) {}
  virtual ~BoundingPolygon();

  BoundingPolygon(const BoundingPolygon& from);
  BoundingPolygon(BoundingPolygon&& from) noexcept
    : BoundingPolygon() {
    *this = ::std::move(from);
  }

  inline BoundingPolygon& operator=(const BoundingPolygon& from) {
    CopyFrom(from);
    return *this;
  }
  inline BoundingPolygon& operator=(BoundingPolygon&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const BoundingPolygon& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const BoundingPolygon* internal_default_instance() {
    return reinterpret_cast<const BoundingPolygon*>(
               &_BoundingPolygon_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(BoundingPolygon& a, BoundingPolygon& b) {
    a.Swap(&b);
  }
  inline void Swap(BoundingPolygon* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BoundingPolygon* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline BoundingPolygon* New() const final {
    return CreateMaybeMessage<BoundingPolygon>(nullptr);
  }

  BoundingPolygon* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<BoundingPolygon>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const BoundingPolygon& from);
  void MergeFrom(const BoundingPolygon& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BoundingPolygon* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "aip.processor.v2.BoundingPolygon";
  }
  protected:
  explicit BoundingPolygon(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_proto_2fpalantir_2fprocessing_2dservice_2dv2_2eproto);
    return ::descriptor_table_proto_2fpalantir_2fprocessing_2dservice_2dv2_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kClassificationsFieldNumber = 2,
    kPolygonFieldNumber = 1,
  };
  // repeated .aip.processor.v2.Classification classifications = 2;
  int classifications_size() const;
  private:
  int _internal_classifications_size() const;
  public:
  void clear_classifications();
  ::aip::processor::v2::Classification* mutable_classifications(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::aip::processor::v2::Classification >*
      mutable_classifications();
  private:
  const ::aip::processor::v2::Classification& _internal_classifications(int index) const;
  ::aip::processor::v2::Classification* _internal_add_classifications();
  public:
  const ::aip::processor::v2::Classification& classifications(int index) const;
  ::aip::processor::v2::Classification* add_classifications();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::aip::processor::v2::Classification >&
      classifications() const;

  // .aip.processor.v2.Polygon polygon = 1;
  bool has_polygon() const;
  private:
  bool _internal_has_polygon() const;
  public:
  void clear_polygon();
  const ::aip::processor::v2::Polygon& polygon() const;
  ::aip::processor::v2::Polygon* release_polygon();
  ::aip::processor::v2::Polygon* mutable_polygon();
  void set_allocated_polygon(::aip::processor::v2::Polygon* polygon);
  private:
  const ::aip::processor::v2::Polygon& _internal_polygon() const;
  ::aip::processor::v2::Polygon* _internal_mutable_polygon();
  public:
  void unsafe_arena_set_allocated_polygon(
      ::aip::processor::v2::Polygon* polygon);
  ::aip::processor::v2::Polygon* unsafe_arena_release_polygon();

  // @@protoc_insertion_point(class_scope:aip.processor.v2.BoundingPolygon)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::aip::processor::v2::Classification > classifications_;
  ::aip::processor::v2::Polygon* polygon_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_proto_2fpalantir_2fprocessing_2dservice_2dv2_2eproto;
};
// -------------------------------------------------------------------

class GeoBoundingPolygon PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:aip.processor.v2.GeoBoundingPolygon) */ {
 public:
  inline GeoBoundingPolygon() : GeoBoundingPolygon(nullptr) {}
  virtual ~GeoBoundingPolygon();

  GeoBoundingPolygon(const GeoBoundingPolygon& from);
  GeoBoundingPolygon(GeoBoundingPolygon&& from) noexcept
    : GeoBoundingPolygon() {
    *this = ::std::move(from);
  }

  inline GeoBoundingPolygon& operator=(const GeoBoundingPolygon& from) {
    CopyFrom(from);
    return *this;
  }
  inline GeoBoundingPolygon& operator=(GeoBoundingPolygon&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const GeoBoundingPolygon& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GeoBoundingPolygon* internal_default_instance() {
    return reinterpret_cast<const GeoBoundingPolygon*>(
               &_GeoBoundingPolygon_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(GeoBoundingPolygon& a, GeoBoundingPolygon& b) {
    a.Swap(&b);
  }
  inline void Swap(GeoBoundingPolygon* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GeoBoundingPolygon* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GeoBoundingPolygon* New() const final {
    return CreateMaybeMessage<GeoBoundingPolygon>(nullptr);
  }

  GeoBoundingPolygon* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GeoBoundingPolygon>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const GeoBoundingPolygon& from);
  void MergeFrom(const GeoBoundingPolygon& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GeoBoundingPolygon* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "aip.processor.v2.GeoBoundingPolygon";
  }
  protected:
  explicit GeoBoundingPolygon(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_proto_2fpalantir_2fprocessing_2dservice_2dv2_2eproto);
    return ::descriptor_table_proto_2fpalantir_2fprocessing_2dservice_2dv2_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kClassificationsFieldNumber = 2,
    kPolygonFieldNumber = 1,
  };
  // repeated .aip.processor.v2.Classification classifications = 2;
  int classifications_size() const;
  private:
  int _internal_classifications_size() const;
  public:
  void clear_classifications();
  ::aip::processor::v2::Classification* mutable_classifications(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::aip::processor::v2::Classification >*
      mutable_classifications();
  private:
  const ::aip::processor::v2::Classification& _internal_classifications(int index) const;
  ::aip::processor::v2::Classification* _internal_add_classifications();
  public:
  const ::aip::processor::v2::Classification& classifications(int index) const;
  ::aip::processor::v2::Classification* add_classifications();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::aip::processor::v2::Classification >&
      classifications() const;

  // .aip.processor.v2.GeoPolygon polygon = 1;
  bool has_polygon() const;
  private:
  bool _internal_has_polygon() const;
  public:
  void clear_polygon();
  const ::aip::processor::v2::GeoPolygon& polygon() const;
  ::aip::processor::v2::GeoPolygon* release_polygon();
  ::aip::processor::v2::GeoPolygon* mutable_polygon();
  void set_allocated_polygon(::aip::processor::v2::GeoPolygon* polygon);
  private:
  const ::aip::processor::v2::GeoPolygon& _internal_polygon() const;
  ::aip::processor::v2::GeoPolygon* _internal_mutable_polygon();
  public:
  void unsafe_arena_set_allocated_polygon(
      ::aip::processor::v2::GeoPolygon* polygon);
  ::aip::processor::v2::GeoPolygon* unsafe_arena_release_polygon();

  // @@protoc_insertion_point(class_scope:aip.processor.v2.GeoBoundingPolygon)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::aip::processor::v2::Classification > classifications_;
  ::aip::processor::v2::GeoPolygon* polygon_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_proto_2fpalantir_2fprocessing_2dservice_2dv2_2eproto;
};
// -------------------------------------------------------------------

class Polygon PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:aip.processor.v2.Polygon) */ {
 public:
  inline Polygon() : Polygon(nullptr) {}
  virtual ~Polygon();

  Polygon(const Polygon& from);
  Polygon(Polygon&& from) noexcept
    : Polygon() {
    *this = ::std::move(from);
  }

  inline Polygon& operator=(const Polygon& from) {
    CopyFrom(from);
    return *this;
  }
  inline Polygon& operator=(Polygon&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Polygon& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Polygon* internal_default_instance() {
    return reinterpret_cast<const Polygon*>(
               &_Polygon_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(Polygon& a, Polygon& b) {
    a.Swap(&b);
  }
  inline void Swap(Polygon* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Polygon* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Polygon* New() const final {
    return CreateMaybeMessage<Polygon>(nullptr);
  }

  Polygon* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Polygon>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Polygon& from);
  void MergeFrom(const Polygon& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Polygon* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "aip.processor.v2.Polygon";
  }
  protected:
  explicit Polygon(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_proto_2fpalantir_2fprocessing_2dservice_2dv2_2eproto);
    return ::descriptor_table_proto_2fpalantir_2fprocessing_2dservice_2dv2_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kVerticesFieldNumber = 1,
  };
  // repeated .aip.processor.v2.UnitCoordinate vertices = 1;
  int vertices_size() const;
  private:
  int _internal_vertices_size() const;
  public:
  void clear_vertices();
  ::aip::processor::v2::UnitCoordinate* mutable_vertices(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::aip::processor::v2::UnitCoordinate >*
      mutable_vertices();
  private:
  const ::aip::processor::v2::UnitCoordinate& _internal_vertices(int index) const;
  ::aip::processor::v2::UnitCoordinate* _internal_add_vertices();
  public:
  const ::aip::processor::v2::UnitCoordinate& vertices(int index) const;
  ::aip::processor::v2::UnitCoordinate* add_vertices();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::aip::processor::v2::UnitCoordinate >&
      vertices() const;

  // @@protoc_insertion_point(class_scope:aip.processor.v2.Polygon)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::aip::processor::v2::UnitCoordinate > vertices_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_proto_2fpalantir_2fprocessing_2dservice_2dv2_2eproto;
};
// -------------------------------------------------------------------

class GeoPolygon PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:aip.processor.v2.GeoPolygon) */ {
 public:
  inline GeoPolygon() : GeoPolygon(nullptr) {}
  virtual ~GeoPolygon();

  GeoPolygon(const GeoPolygon& from);
  GeoPolygon(GeoPolygon&& from) noexcept
    : GeoPolygon() {
    *this = ::std::move(from);
  }

  inline GeoPolygon& operator=(const GeoPolygon& from) {
    CopyFrom(from);
    return *this;
  }
  inline GeoPolygon& operator=(GeoPolygon&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const GeoPolygon& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GeoPolygon* internal_default_instance() {
    return reinterpret_cast<const GeoPolygon*>(
               &_GeoPolygon_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(GeoPolygon& a, GeoPolygon& b) {
    a.Swap(&b);
  }
  inline void Swap(GeoPolygon* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GeoPolygon* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GeoPolygon* New() const final {
    return CreateMaybeMessage<GeoPolygon>(nullptr);
  }

  GeoPolygon* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GeoPolygon>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const GeoPolygon& from);
  void MergeFrom(const GeoPolygon& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GeoPolygon* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "aip.processor.v2.GeoPolygon";
  }
  protected:
  explicit GeoPolygon(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_proto_2fpalantir_2fprocessing_2dservice_2dv2_2eproto);
    return ::descriptor_table_proto_2fpalantir_2fprocessing_2dservice_2dv2_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kVerticesFieldNumber = 1,
  };
  // repeated .aip.processor.v2.GeoCoordinate vertices = 1;
  int vertices_size() const;
  private:
  int _internal_vertices_size() const;
  public:
  void clear_vertices();
  ::aip::processor::v2::GeoCoordinate* mutable_vertices(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::aip::processor::v2::GeoCoordinate >*
      mutable_vertices();
  private:
  const ::aip::processor::v2::GeoCoordinate& _internal_vertices(int index) const;
  ::aip::processor::v2::GeoCoordinate* _internal_add_vertices();
  public:
  const ::aip::processor::v2::GeoCoordinate& vertices(int index) const;
  ::aip::processor::v2::GeoCoordinate* add_vertices();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::aip::processor::v2::GeoCoordinate >&
      vertices() const;

  // @@protoc_insertion_point(class_scope:aip.processor.v2.GeoPolygon)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::aip::processor::v2::GeoCoordinate > vertices_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_proto_2fpalantir_2fprocessing_2dservice_2dv2_2eproto;
};
// -------------------------------------------------------------------

class UnitCoordinate PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:aip.processor.v2.UnitCoordinate) */ {
 public:
  inline UnitCoordinate() : UnitCoordinate(nullptr) {}
  virtual ~UnitCoordinate();

  UnitCoordinate(const UnitCoordinate& from);
  UnitCoordinate(UnitCoordinate&& from) noexcept
    : UnitCoordinate() {
    *this = ::std::move(from);
  }

  inline UnitCoordinate& operator=(const UnitCoordinate& from) {
    CopyFrom(from);
    return *this;
  }
  inline UnitCoordinate& operator=(UnitCoordinate&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const UnitCoordinate& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const UnitCoordinate* internal_default_instance() {
    return reinterpret_cast<const UnitCoordinate*>(
               &_UnitCoordinate_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(UnitCoordinate& a, UnitCoordinate& b) {
    a.Swap(&b);
  }
  inline void Swap(UnitCoordinate* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UnitCoordinate* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline UnitCoordinate* New() const final {
    return CreateMaybeMessage<UnitCoordinate>(nullptr);
  }

  UnitCoordinate* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<UnitCoordinate>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const UnitCoordinate& from);
  void MergeFrom(const UnitCoordinate& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UnitCoordinate* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "aip.processor.v2.UnitCoordinate";
  }
  protected:
  explicit UnitCoordinate(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_proto_2fpalantir_2fprocessing_2dservice_2dv2_2eproto);
    return ::descriptor_table_proto_2fpalantir_2fprocessing_2dservice_2dv2_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRowFieldNumber = 1,
    kColFieldNumber = 2,
  };
  // double row = 1;
  void clear_row();
  double row() const;
  void set_row(double value);
  private:
  double _internal_row() const;
  void _internal_set_row(double value);
  public:

  // double col = 2;
  void clear_col();
  double col() const;
  void set_col(double value);
  private:
  double _internal_col() const;
  void _internal_set_col(double value);
  public:

  // @@protoc_insertion_point(class_scope:aip.processor.v2.UnitCoordinate)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  double row_;
  double col_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_proto_2fpalantir_2fprocessing_2dservice_2dv2_2eproto;
};
// -------------------------------------------------------------------

class Classification PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:aip.processor.v2.Classification) */ {
 public:
  inline Classification() : Classification(nullptr) {}
  virtual ~Classification();

  Classification(const Classification& from);
  Classification(Classification&& from) noexcept
    : Classification() {
    *this = ::std::move(from);
  }

  inline Classification& operator=(const Classification& from) {
    CopyFrom(from);
    return *this;
  }
  inline Classification& operator=(Classification&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Classification& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Classification* internal_default_instance() {
    return reinterpret_cast<const Classification*>(
               &_Classification_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  friend void swap(Classification& a, Classification& b) {
    a.Swap(&b);
  }
  inline void Swap(Classification* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Classification* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Classification* New() const final {
    return CreateMaybeMessage<Classification>(nullptr);
  }

  Classification* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Classification>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Classification& from);
  void MergeFrom(const Classification& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Classification* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "aip.processor.v2.Classification";
  }
  protected:
  explicit Classification(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_proto_2fpalantir_2fprocessing_2dservice_2dv2_2eproto);
    return ::descriptor_table_proto_2fpalantir_2fprocessing_2dservice_2dv2_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTypeFieldNumber = 1,
    kConfidenceFieldNumber = 2,
  };
  // string type = 1;
  void clear_type();
  const std::string& type() const;
  void set_type(const std::string& value);
  void set_type(std::string&& value);
  void set_type(const char* value);
  void set_type(const char* value, size_t size);
  std::string* mutable_type();
  std::string* release_type();
  void set_allocated_type(std::string* type);
  private:
  const std::string& _internal_type() const;
  void _internal_set_type(const std::string& value);
  std::string* _internal_mutable_type();
  public:

  // double confidence = 2;
  void clear_confidence();
  double confidence() const;
  void set_confidence(double value);
  private:
  double _internal_confidence() const;
  void _internal_set_confidence(double value);
  public:

  // @@protoc_insertion_point(class_scope:aip.processor.v2.Classification)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr type_;
  double confidence_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_proto_2fpalantir_2fprocessing_2dservice_2dv2_2eproto;
};
// -------------------------------------------------------------------

class Lattice_Point PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:aip.processor.v2.Lattice.Point) */ {
 public:
  inline Lattice_Point() : Lattice_Point(nullptr) {}
  virtual ~Lattice_Point();

  Lattice_Point(const Lattice_Point& from);
  Lattice_Point(Lattice_Point&& from) noexcept
    : Lattice_Point() {
    *this = ::std::move(from);
  }

  inline Lattice_Point& operator=(const Lattice_Point& from) {
    CopyFrom(from);
    return *this;
  }
  inline Lattice_Point& operator=(Lattice_Point&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Lattice_Point& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Lattice_Point* internal_default_instance() {
    return reinterpret_cast<const Lattice_Point*>(
               &_Lattice_Point_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  friend void swap(Lattice_Point& a, Lattice_Point& b) {
    a.Swap(&b);
  }
  inline void Swap(Lattice_Point* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Lattice_Point* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Lattice_Point* New() const final {
    return CreateMaybeMessage<Lattice_Point>(nullptr);
  }

  Lattice_Point* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Lattice_Point>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Lattice_Point& from);
  void MergeFrom(const Lattice_Point& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Lattice_Point* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "aip.processor.v2.Lattice.Point";
  }
  protected:
  explicit Lattice_Point(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_proto_2fpalantir_2fprocessing_2dservice_2dv2_2eproto);
    return ::descriptor_table_proto_2fpalantir_2fprocessing_2dservice_2dv2_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCoordinateFieldNumber = 1,
    kLatitudeFieldNumber = 2,
    kLongitudeFieldNumber = 3,
    kElevationFieldNumber = 4,
  };
  // .aip.processor.v2.UnitCoordinate coordinate = 1;
  bool has_coordinate() const;
  private:
  bool _internal_has_coordinate() const;
  public:
  void clear_coordinate();
  const ::aip::processor::v2::UnitCoordinate& coordinate() const;
  ::aip::processor::v2::UnitCoordinate* release_coordinate();
  ::aip::processor::v2::UnitCoordinate* mutable_coordinate();
  void set_allocated_coordinate(::aip::processor::v2::UnitCoordinate* coordinate);
  private:
  const ::aip::processor::v2::UnitCoordinate& _internal_coordinate() const;
  ::aip::processor::v2::UnitCoordinate* _internal_mutable_coordinate();
  public:
  void unsafe_arena_set_allocated_coordinate(
      ::aip::processor::v2::UnitCoordinate* coordinate);
  ::aip::processor::v2::UnitCoordinate* unsafe_arena_release_coordinate();

  // double latitude = 2;
  void clear_latitude();
  double latitude() const;
  void set_latitude(double value);
  private:
  double _internal_latitude() const;
  void _internal_set_latitude(double value);
  public:

  // double longitude = 3;
  void clear_longitude();
  double longitude() const;
  void set_longitude(double value);
  private:
  double _internal_longitude() const;
  void _internal_set_longitude(double value);
  public:

  // double elevation = 4;
  void clear_elevation();
  double elevation() const;
  void set_elevation(double value);
  private:
  double _internal_elevation() const;
  void _internal_set_elevation(double value);
  public:

  // @@protoc_insertion_point(class_scope:aip.processor.v2.Lattice.Point)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::aip::processor::v2::UnitCoordinate* coordinate_;
  double latitude_;
  double longitude_;
  double elevation_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_proto_2fpalantir_2fprocessing_2dservice_2dv2_2eproto;
};
// -------------------------------------------------------------------

class Lattice PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:aip.processor.v2.Lattice) */ {
 public:
  inline Lattice() : Lattice(nullptr) {}
  virtual ~Lattice();

  Lattice(const Lattice& from);
  Lattice(Lattice&& from) noexcept
    : Lattice() {
    *this = ::std::move(from);
  }

  inline Lattice& operator=(const Lattice& from) {
    CopyFrom(from);
    return *this;
  }
  inline Lattice& operator=(Lattice&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Lattice& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Lattice* internal_default_instance() {
    return reinterpret_cast<const Lattice*>(
               &_Lattice_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  friend void swap(Lattice& a, Lattice& b) {
    a.Swap(&b);
  }
  inline void Swap(Lattice* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Lattice* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Lattice* New() const final {
    return CreateMaybeMessage<Lattice>(nullptr);
  }

  Lattice* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Lattice>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Lattice& from);
  void MergeFrom(const Lattice& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Lattice* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "aip.processor.v2.Lattice";
  }
  protected:
  explicit Lattice(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_proto_2fpalantir_2fprocessing_2dservice_2dv2_2eproto);
    return ::descriptor_table_proto_2fpalantir_2fprocessing_2dservice_2dv2_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef Lattice_Point Point;

  // accessors -------------------------------------------------------

  enum : int {
    kEarthIntersectionFieldNumber = 1,
  };
  // repeated .aip.processor.v2.Lattice.Point earth_intersection = 1;
  int earth_intersection_size() const;
  private:
  int _internal_earth_intersection_size() const;
  public:
  void clear_earth_intersection();
  ::aip::processor::v2::Lattice_Point* mutable_earth_intersection(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::aip::processor::v2::Lattice_Point >*
      mutable_earth_intersection();
  private:
  const ::aip::processor::v2::Lattice_Point& _internal_earth_intersection(int index) const;
  ::aip::processor::v2::Lattice_Point* _internal_add_earth_intersection();
  public:
  const ::aip::processor::v2::Lattice_Point& earth_intersection(int index) const;
  ::aip::processor::v2::Lattice_Point* add_earth_intersection();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::aip::processor::v2::Lattice_Point >&
      earth_intersection() const;

  // @@protoc_insertion_point(class_scope:aip.processor.v2.Lattice)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::aip::processor::v2::Lattice_Point > earth_intersection_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_proto_2fpalantir_2fprocessing_2dservice_2dv2_2eproto;
};
// -------------------------------------------------------------------

class Velocity PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:aip.processor.v2.Velocity) */ {
 public:
  inline Velocity() : Velocity(nullptr) {}
  virtual ~Velocity();

  Velocity(const Velocity& from);
  Velocity(Velocity&& from) noexcept
    : Velocity() {
    *this = ::std::move(from);
  }

  inline Velocity& operator=(const Velocity& from) {
    CopyFrom(from);
    return *this;
  }
  inline Velocity& operator=(Velocity&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Velocity& default_instance();

  enum VelocityCase {
    kPixel = 4,
    VELOCITY_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Velocity* internal_default_instance() {
    return reinterpret_cast<const Velocity*>(
               &_Velocity_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    23;

  friend void swap(Velocity& a, Velocity& b) {
    a.Swap(&b);
  }
  inline void Swap(Velocity* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Velocity* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Velocity* New() const final {
    return CreateMaybeMessage<Velocity>(nullptr);
  }

  Velocity* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Velocity>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Velocity& from);
  void MergeFrom(const Velocity& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Velocity* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "aip.processor.v2.Velocity";
  }
  protected:
  explicit Velocity(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_proto_2fpalantir_2fprocessing_2dservice_2dv2_2eproto);
    return ::descriptor_table_proto_2fpalantir_2fprocessing_2dservice_2dv2_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPixelFieldNumber = 4,
  };
  // .aip.processor.v2.PixelVelocityVector pixel = 4;
  bool has_pixel() const;
  private:
  bool _internal_has_pixel() const;
  public:
  void clear_pixel();
  const ::aip::processor::v2::PixelVelocityVector& pixel() const;
  ::aip::processor::v2::PixelVelocityVector* release_pixel();
  ::aip::processor::v2::PixelVelocityVector* mutable_pixel();
  void set_allocated_pixel(::aip::processor::v2::PixelVelocityVector* pixel);
  private:
  const ::aip::processor::v2::PixelVelocityVector& _internal_pixel() const;
  ::aip::processor::v2::PixelVelocityVector* _internal_mutable_pixel();
  public:
  void unsafe_arena_set_allocated_pixel(
      ::aip::processor::v2::PixelVelocityVector* pixel);
  ::aip::processor::v2::PixelVelocityVector* unsafe_arena_release_pixel();

  void clear_velocity();
  VelocityCase velocity_case() const;
  // @@protoc_insertion_point(class_scope:aip.processor.v2.Velocity)
 private:
  class _Internal;
  void set_has_pixel();

  inline bool has_velocity() const;
  inline void clear_has_velocity();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  union VelocityUnion {
    VelocityUnion() {}
    ::aip::processor::v2::PixelVelocityVector* pixel_;
  } velocity_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint32 _oneof_case_[1];

  friend struct ::TableStruct_proto_2fpalantir_2fprocessing_2dservice_2dv2_2eproto;
};
// -------------------------------------------------------------------

class PixelVelocityVector PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:aip.processor.v2.PixelVelocityVector) */ {
 public:
  inline PixelVelocityVector() : PixelVelocityVector(nullptr) {}
  virtual ~PixelVelocityVector();

  PixelVelocityVector(const PixelVelocityVector& from);
  PixelVelocityVector(PixelVelocityVector&& from) noexcept
    : PixelVelocityVector() {
    *this = ::std::move(from);
  }

  inline PixelVelocityVector& operator=(const PixelVelocityVector& from) {
    CopyFrom(from);
    return *this;
  }
  inline PixelVelocityVector& operator=(PixelVelocityVector&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const PixelVelocityVector& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PixelVelocityVector* internal_default_instance() {
    return reinterpret_cast<const PixelVelocityVector*>(
               &_PixelVelocityVector_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    24;

  friend void swap(PixelVelocityVector& a, PixelVelocityVector& b) {
    a.Swap(&b);
  }
  inline void Swap(PixelVelocityVector* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PixelVelocityVector* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline PixelVelocityVector* New() const final {
    return CreateMaybeMessage<PixelVelocityVector>(nullptr);
  }

  PixelVelocityVector* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<PixelVelocityVector>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const PixelVelocityVector& from);
  void MergeFrom(const PixelVelocityVector& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PixelVelocityVector* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "aip.processor.v2.PixelVelocityVector";
  }
  protected:
  explicit PixelVelocityVector(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_proto_2fpalantir_2fprocessing_2dservice_2dv2_2eproto);
    return ::descriptor_table_proto_2fpalantir_2fprocessing_2dservice_2dv2_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kXFieldNumber = 1,
    kYFieldNumber = 2,
  };
  // double x = 1;
  void clear_x();
  double x() const;
  void set_x(double value);
  private:
  double _internal_x() const;
  void _internal_set_x(double value);
  public:

  // double y = 2;
  void clear_y();
  double y() const;
  void set_y(double value);
  private:
  double _internal_y() const;
  void _internal_set_y(double value);
  public:

  // @@protoc_insertion_point(class_scope:aip.processor.v2.PixelVelocityVector)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  double x_;
  double y_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_proto_2fpalantir_2fprocessing_2dservice_2dv2_2eproto;
};
// -------------------------------------------------------------------

class Frame PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:aip.processor.v2.Frame) */ {
 public:
  inline Frame() : Frame(nullptr) {}
  virtual ~Frame();

  Frame(const Frame& from);
  Frame(Frame&& from) noexcept
    : Frame() {
    *this = ::std::move(from);
  }

  inline Frame& operator=(const Frame& from) {
    CopyFrom(from);
    return *this;
  }
  inline Frame& operator=(Frame&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Frame& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Frame* internal_default_instance() {
    return reinterpret_cast<const Frame*>(
               &_Frame_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    25;

  friend void swap(Frame& a, Frame& b) {
    a.Swap(&b);
  }
  inline void Swap(Frame* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Frame* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Frame* New() const final {
    return CreateMaybeMessage<Frame>(nullptr);
  }

  Frame* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Frame>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Frame& from);
  void MergeFrom(const Frame& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Frame* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "aip.processor.v2.Frame";
  }
  protected:
  explicit Frame(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_proto_2fpalantir_2fprocessing_2dservice_2dv2_2eproto);
    return ::descriptor_table_proto_2fpalantir_2fprocessing_2dservice_2dv2_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kImageFieldNumber = 1,
    kUasMetadataFieldNumber = 2,
  };
  // .aip.processor.v2.Image image = 1;
  bool has_image() const;
  private:
  bool _internal_has_image() const;
  public:
  void clear_image();
  const ::aip::processor::v2::Image& image() const;
  ::aip::processor::v2::Image* release_image();
  ::aip::processor::v2::Image* mutable_image();
  void set_allocated_image(::aip::processor::v2::Image* image);
  private:
  const ::aip::processor::v2::Image& _internal_image() const;
  ::aip::processor::v2::Image* _internal_mutable_image();
  public:
  void unsafe_arena_set_allocated_image(
      ::aip::processor::v2::Image* image);
  ::aip::processor::v2::Image* unsafe_arena_release_image();

  // .aip.processor.v2.UasMetadata uas_metadata = 2;
  bool has_uas_metadata() const;
  private:
  bool _internal_has_uas_metadata() const;
  public:
  void clear_uas_metadata();
  const ::aip::processor::v2::UasMetadata& uas_metadata() const;
  ::aip::processor::v2::UasMetadata* release_uas_metadata();
  ::aip::processor::v2::UasMetadata* mutable_uas_metadata();
  void set_allocated_uas_metadata(::aip::processor::v2::UasMetadata* uas_metadata);
  private:
  const ::aip::processor::v2::UasMetadata& _internal_uas_metadata() const;
  ::aip::processor::v2::UasMetadata* _internal_mutable_uas_metadata();
  public:
  void unsafe_arena_set_allocated_uas_metadata(
      ::aip::processor::v2::UasMetadata* uas_metadata);
  ::aip::processor::v2::UasMetadata* unsafe_arena_release_uas_metadata();

  // @@protoc_insertion_point(class_scope:aip.processor.v2.Frame)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::aip::processor::v2::Image* image_;
  ::aip::processor::v2::UasMetadata* uas_metadata_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_proto_2fpalantir_2fprocessing_2dservice_2dv2_2eproto;
};
// -------------------------------------------------------------------

class Image PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:aip.processor.v2.Image) */ {
 public:
  inline Image() : Image(nullptr) {}
  virtual ~Image();

  Image(const Image& from);
  Image(Image&& from) noexcept
    : Image() {
    *this = ::std::move(from);
  }

  inline Image& operator=(const Image& from) {
    CopyFrom(from);
    return *this;
  }
  inline Image& operator=(Image&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Image& default_instance();

  enum ImageCase {
    kRgbImage = 1,
    kPngImage = 2,
    kTiffImage = 3,
    kBgrImage = 4,
    kNitf21Image = 5,
    IMAGE_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Image* internal_default_instance() {
    return reinterpret_cast<const Image*>(
               &_Image_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    26;

  friend void swap(Image& a, Image& b) {
    a.Swap(&b);
  }
  inline void Swap(Image* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Image* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Image* New() const final {
    return CreateMaybeMessage<Image>(nullptr);
  }

  Image* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Image>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Image& from);
  void MergeFrom(const Image& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Image* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "aip.processor.v2.Image";
  }
  protected:
  explicit Image(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_proto_2fpalantir_2fprocessing_2dservice_2dv2_2eproto);
    return ::descriptor_table_proto_2fpalantir_2fprocessing_2dservice_2dv2_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRgbImageFieldNumber = 1,
    kPngImageFieldNumber = 2,
    kTiffImageFieldNumber = 3,
    kBgrImageFieldNumber = 4,
    kNitf21ImageFieldNumber = 5,
  };
  // .aip.processor.v2.Rgb888Image rgb_image = 1;
  bool has_rgb_image() const;
  private:
  bool _internal_has_rgb_image() const;
  public:
  void clear_rgb_image();
  const ::aip::processor::v2::Rgb888Image& rgb_image() const;
  ::aip::processor::v2::Rgb888Image* release_rgb_image();
  ::aip::processor::v2::Rgb888Image* mutable_rgb_image();
  void set_allocated_rgb_image(::aip::processor::v2::Rgb888Image* rgb_image);
  private:
  const ::aip::processor::v2::Rgb888Image& _internal_rgb_image() const;
  ::aip::processor::v2::Rgb888Image* _internal_mutable_rgb_image();
  public:
  void unsafe_arena_set_allocated_rgb_image(
      ::aip::processor::v2::Rgb888Image* rgb_image);
  ::aip::processor::v2::Rgb888Image* unsafe_arena_release_rgb_image();

  // .aip.processor.v2.PngImage png_image = 2;
  bool has_png_image() const;
  private:
  bool _internal_has_png_image() const;
  public:
  void clear_png_image();
  const ::aip::processor::v2::PngImage& png_image() const;
  ::aip::processor::v2::PngImage* release_png_image();
  ::aip::processor::v2::PngImage* mutable_png_image();
  void set_allocated_png_image(::aip::processor::v2::PngImage* png_image);
  private:
  const ::aip::processor::v2::PngImage& _internal_png_image() const;
  ::aip::processor::v2::PngImage* _internal_mutable_png_image();
  public:
  void unsafe_arena_set_allocated_png_image(
      ::aip::processor::v2::PngImage* png_image);
  ::aip::processor::v2::PngImage* unsafe_arena_release_png_image();

  // .aip.processor.v2.TiffImage tiff_image = 3;
  bool has_tiff_image() const;
  private:
  bool _internal_has_tiff_image() const;
  public:
  void clear_tiff_image();
  const ::aip::processor::v2::TiffImage& tiff_image() const;
  ::aip::processor::v2::TiffImage* release_tiff_image();
  ::aip::processor::v2::TiffImage* mutable_tiff_image();
  void set_allocated_tiff_image(::aip::processor::v2::TiffImage* tiff_image);
  private:
  const ::aip::processor::v2::TiffImage& _internal_tiff_image() const;
  ::aip::processor::v2::TiffImage* _internal_mutable_tiff_image();
  public:
  void unsafe_arena_set_allocated_tiff_image(
      ::aip::processor::v2::TiffImage* tiff_image);
  ::aip::processor::v2::TiffImage* unsafe_arena_release_tiff_image();

  // .aip.processor.v2.Bgr888Image bgr_image = 4;
  bool has_bgr_image() const;
  private:
  bool _internal_has_bgr_image() const;
  public:
  void clear_bgr_image();
  const ::aip::processor::v2::Bgr888Image& bgr_image() const;
  ::aip::processor::v2::Bgr888Image* release_bgr_image();
  ::aip::processor::v2::Bgr888Image* mutable_bgr_image();
  void set_allocated_bgr_image(::aip::processor::v2::Bgr888Image* bgr_image);
  private:
  const ::aip::processor::v2::Bgr888Image& _internal_bgr_image() const;
  ::aip::processor::v2::Bgr888Image* _internal_mutable_bgr_image();
  public:
  void unsafe_arena_set_allocated_bgr_image(
      ::aip::processor::v2::Bgr888Image* bgr_image);
  ::aip::processor::v2::Bgr888Image* unsafe_arena_release_bgr_image();

  // .aip.processor.v2.Nitf21Image nitf21_image = 5;
  bool has_nitf21_image() const;
  private:
  bool _internal_has_nitf21_image() const;
  public:
  void clear_nitf21_image();
  const ::aip::processor::v2::Nitf21Image& nitf21_image() const;
  ::aip::processor::v2::Nitf21Image* release_nitf21_image();
  ::aip::processor::v2::Nitf21Image* mutable_nitf21_image();
  void set_allocated_nitf21_image(::aip::processor::v2::Nitf21Image* nitf21_image);
  private:
  const ::aip::processor::v2::Nitf21Image& _internal_nitf21_image() const;
  ::aip::processor::v2::Nitf21Image* _internal_mutable_nitf21_image();
  public:
  void unsafe_arena_set_allocated_nitf21_image(
      ::aip::processor::v2::Nitf21Image* nitf21_image);
  ::aip::processor::v2::Nitf21Image* unsafe_arena_release_nitf21_image();

  void clear_image();
  ImageCase image_case() const;
  // @@protoc_insertion_point(class_scope:aip.processor.v2.Image)
 private:
  class _Internal;
  void set_has_rgb_image();
  void set_has_png_image();
  void set_has_tiff_image();
  void set_has_bgr_image();
  void set_has_nitf21_image();

  inline bool has_image() const;
  inline void clear_has_image();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  union ImageUnion {
    ImageUnion() {}
    ::aip::processor::v2::Rgb888Image* rgb_image_;
    ::aip::processor::v2::PngImage* png_image_;
    ::aip::processor::v2::TiffImage* tiff_image_;
    ::aip::processor::v2::Bgr888Image* bgr_image_;
    ::aip::processor::v2::Nitf21Image* nitf21_image_;
  } image_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint32 _oneof_case_[1];

  friend struct ::TableStruct_proto_2fpalantir_2fprocessing_2dservice_2dv2_2eproto;
};
// -------------------------------------------------------------------

class Rgb888Image PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:aip.processor.v2.Rgb888Image) */ {
 public:
  inline Rgb888Image() : Rgb888Image(nullptr) {}
  virtual ~Rgb888Image();

  Rgb888Image(const Rgb888Image& from);
  Rgb888Image(Rgb888Image&& from) noexcept
    : Rgb888Image() {
    *this = ::std::move(from);
  }

  inline Rgb888Image& operator=(const Rgb888Image& from) {
    CopyFrom(from);
    return *this;
  }
  inline Rgb888Image& operator=(Rgb888Image&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Rgb888Image& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Rgb888Image* internal_default_instance() {
    return reinterpret_cast<const Rgb888Image*>(
               &_Rgb888Image_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    27;

  friend void swap(Rgb888Image& a, Rgb888Image& b) {
    a.Swap(&b);
  }
  inline void Swap(Rgb888Image* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Rgb888Image* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Rgb888Image* New() const final {
    return CreateMaybeMessage<Rgb888Image>(nullptr);
  }

  Rgb888Image* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Rgb888Image>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Rgb888Image& from);
  void MergeFrom(const Rgb888Image& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Rgb888Image* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "aip.processor.v2.Rgb888Image";
  }
  protected:
  explicit Rgb888Image(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_proto_2fpalantir_2fprocessing_2dservice_2dv2_2eproto);
    return ::descriptor_table_proto_2fpalantir_2fprocessing_2dservice_2dv2_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPathFieldNumber = 3,
    kWidthFieldNumber = 1,
    kHeightFieldNumber = 2,
  };
  // string path = 3;
  void clear_path();
  const std::string& path() const;
  void set_path(const std::string& value);
  void set_path(std::string&& value);
  void set_path(const char* value);
  void set_path(const char* value, size_t size);
  std::string* mutable_path();
  std::string* release_path();
  void set_allocated_path(std::string* path);
  private:
  const std::string& _internal_path() const;
  void _internal_set_path(const std::string& value);
  std::string* _internal_mutable_path();
  public:

  // int32 width = 1;
  void clear_width();
  ::PROTOBUF_NAMESPACE_ID::int32 width() const;
  void set_width(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_width() const;
  void _internal_set_width(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // int32 height = 2;
  void clear_height();
  ::PROTOBUF_NAMESPACE_ID::int32 height() const;
  void set_height(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_height() const;
  void _internal_set_height(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:aip.processor.v2.Rgb888Image)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr path_;
  ::PROTOBUF_NAMESPACE_ID::int32 width_;
  ::PROTOBUF_NAMESPACE_ID::int32 height_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_proto_2fpalantir_2fprocessing_2dservice_2dv2_2eproto;
};
// -------------------------------------------------------------------

class Bgr888Image PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:aip.processor.v2.Bgr888Image) */ {
 public:
  inline Bgr888Image() : Bgr888Image(nullptr) {}
  virtual ~Bgr888Image();

  Bgr888Image(const Bgr888Image& from);
  Bgr888Image(Bgr888Image&& from) noexcept
    : Bgr888Image() {
    *this = ::std::move(from);
  }

  inline Bgr888Image& operator=(const Bgr888Image& from) {
    CopyFrom(from);
    return *this;
  }
  inline Bgr888Image& operator=(Bgr888Image&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Bgr888Image& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Bgr888Image* internal_default_instance() {
    return reinterpret_cast<const Bgr888Image*>(
               &_Bgr888Image_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    28;

  friend void swap(Bgr888Image& a, Bgr888Image& b) {
    a.Swap(&b);
  }
  inline void Swap(Bgr888Image* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Bgr888Image* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Bgr888Image* New() const final {
    return CreateMaybeMessage<Bgr888Image>(nullptr);
  }

  Bgr888Image* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Bgr888Image>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Bgr888Image& from);
  void MergeFrom(const Bgr888Image& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Bgr888Image* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "aip.processor.v2.Bgr888Image";
  }
  protected:
  explicit Bgr888Image(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_proto_2fpalantir_2fprocessing_2dservice_2dv2_2eproto);
    return ::descriptor_table_proto_2fpalantir_2fprocessing_2dservice_2dv2_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPathFieldNumber = 3,
    kWidthFieldNumber = 1,
    kHeightFieldNumber = 2,
  };
  // string path = 3;
  void clear_path();
  const std::string& path() const;
  void set_path(const std::string& value);
  void set_path(std::string&& value);
  void set_path(const char* value);
  void set_path(const char* value, size_t size);
  std::string* mutable_path();
  std::string* release_path();
  void set_allocated_path(std::string* path);
  private:
  const std::string& _internal_path() const;
  void _internal_set_path(const std::string& value);
  std::string* _internal_mutable_path();
  public:

  // int32 width = 1;
  void clear_width();
  ::PROTOBUF_NAMESPACE_ID::int32 width() const;
  void set_width(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_width() const;
  void _internal_set_width(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // int32 height = 2;
  void clear_height();
  ::PROTOBUF_NAMESPACE_ID::int32 height() const;
  void set_height(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_height() const;
  void _internal_set_height(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:aip.processor.v2.Bgr888Image)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr path_;
  ::PROTOBUF_NAMESPACE_ID::int32 width_;
  ::PROTOBUF_NAMESPACE_ID::int32 height_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_proto_2fpalantir_2fprocessing_2dservice_2dv2_2eproto;
};
// -------------------------------------------------------------------

class PngImage PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:aip.processor.v2.PngImage) */ {
 public:
  inline PngImage() : PngImage(nullptr) {}
  virtual ~PngImage();

  PngImage(const PngImage& from);
  PngImage(PngImage&& from) noexcept
    : PngImage() {
    *this = ::std::move(from);
  }

  inline PngImage& operator=(const PngImage& from) {
    CopyFrom(from);
    return *this;
  }
  inline PngImage& operator=(PngImage&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const PngImage& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PngImage* internal_default_instance() {
    return reinterpret_cast<const PngImage*>(
               &_PngImage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    29;

  friend void swap(PngImage& a, PngImage& b) {
    a.Swap(&b);
  }
  inline void Swap(PngImage* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PngImage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline PngImage* New() const final {
    return CreateMaybeMessage<PngImage>(nullptr);
  }

  PngImage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<PngImage>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const PngImage& from);
  void MergeFrom(const PngImage& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PngImage* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "aip.processor.v2.PngImage";
  }
  protected:
  explicit PngImage(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_proto_2fpalantir_2fprocessing_2dservice_2dv2_2eproto);
    return ::descriptor_table_proto_2fpalantir_2fprocessing_2dservice_2dv2_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPathFieldNumber = 3,
    kWidthFieldNumber = 1,
    kHeightFieldNumber = 2,
  };
  // string path = 3;
  void clear_path();
  const std::string& path() const;
  void set_path(const std::string& value);
  void set_path(std::string&& value);
  void set_path(const char* value);
  void set_path(const char* value, size_t size);
  std::string* mutable_path();
  std::string* release_path();
  void set_allocated_path(std::string* path);
  private:
  const std::string& _internal_path() const;
  void _internal_set_path(const std::string& value);
  std::string* _internal_mutable_path();
  public:

  // int32 width = 1;
  void clear_width();
  ::PROTOBUF_NAMESPACE_ID::int32 width() const;
  void set_width(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_width() const;
  void _internal_set_width(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // int32 height = 2;
  void clear_height();
  ::PROTOBUF_NAMESPACE_ID::int32 height() const;
  void set_height(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_height() const;
  void _internal_set_height(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:aip.processor.v2.PngImage)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr path_;
  ::PROTOBUF_NAMESPACE_ID::int32 width_;
  ::PROTOBUF_NAMESPACE_ID::int32 height_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_proto_2fpalantir_2fprocessing_2dservice_2dv2_2eproto;
};
// -------------------------------------------------------------------

class TiffImage PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:aip.processor.v2.TiffImage) */ {
 public:
  inline TiffImage() : TiffImage(nullptr) {}
  virtual ~TiffImage();

  TiffImage(const TiffImage& from);
  TiffImage(TiffImage&& from) noexcept
    : TiffImage() {
    *this = ::std::move(from);
  }

  inline TiffImage& operator=(const TiffImage& from) {
    CopyFrom(from);
    return *this;
  }
  inline TiffImage& operator=(TiffImage&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const TiffImage& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TiffImage* internal_default_instance() {
    return reinterpret_cast<const TiffImage*>(
               &_TiffImage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    30;

  friend void swap(TiffImage& a, TiffImage& b) {
    a.Swap(&b);
  }
  inline void Swap(TiffImage* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TiffImage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline TiffImage* New() const final {
    return CreateMaybeMessage<TiffImage>(nullptr);
  }

  TiffImage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<TiffImage>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const TiffImage& from);
  void MergeFrom(const TiffImage& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TiffImage* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "aip.processor.v2.TiffImage";
  }
  protected:
  explicit TiffImage(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_proto_2fpalantir_2fprocessing_2dservice_2dv2_2eproto);
    return ::descriptor_table_proto_2fpalantir_2fprocessing_2dservice_2dv2_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPathFieldNumber = 3,
    kWidthFieldNumber = 1,
    kHeightFieldNumber = 2,
  };
  // string path = 3;
  void clear_path();
  const std::string& path() const;
  void set_path(const std::string& value);
  void set_path(std::string&& value);
  void set_path(const char* value);
  void set_path(const char* value, size_t size);
  std::string* mutable_path();
  std::string* release_path();
  void set_allocated_path(std::string* path);
  private:
  const std::string& _internal_path() const;
  void _internal_set_path(const std::string& value);
  std::string* _internal_mutable_path();
  public:

  // int32 width = 1;
  void clear_width();
  ::PROTOBUF_NAMESPACE_ID::int32 width() const;
  void set_width(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_width() const;
  void _internal_set_width(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // int32 height = 2;
  void clear_height();
  ::PROTOBUF_NAMESPACE_ID::int32 height() const;
  void set_height(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_height() const;
  void _internal_set_height(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:aip.processor.v2.TiffImage)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr path_;
  ::PROTOBUF_NAMESPACE_ID::int32 width_;
  ::PROTOBUF_NAMESPACE_ID::int32 height_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_proto_2fpalantir_2fprocessing_2dservice_2dv2_2eproto;
};
// -------------------------------------------------------------------

class Nitf21Image PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:aip.processor.v2.Nitf21Image) */ {
 public:
  inline Nitf21Image() : Nitf21Image(nullptr) {}
  virtual ~Nitf21Image();

  Nitf21Image(const Nitf21Image& from);
  Nitf21Image(Nitf21Image&& from) noexcept
    : Nitf21Image() {
    *this = ::std::move(from);
  }

  inline Nitf21Image& operator=(const Nitf21Image& from) {
    CopyFrom(from);
    return *this;
  }
  inline Nitf21Image& operator=(Nitf21Image&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Nitf21Image& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Nitf21Image* internal_default_instance() {
    return reinterpret_cast<const Nitf21Image*>(
               &_Nitf21Image_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    31;

  friend void swap(Nitf21Image& a, Nitf21Image& b) {
    a.Swap(&b);
  }
  inline void Swap(Nitf21Image* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Nitf21Image* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Nitf21Image* New() const final {
    return CreateMaybeMessage<Nitf21Image>(nullptr);
  }

  Nitf21Image* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Nitf21Image>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Nitf21Image& from);
  void MergeFrom(const Nitf21Image& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Nitf21Image* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "aip.processor.v2.Nitf21Image";
  }
  protected:
  explicit Nitf21Image(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_proto_2fpalantir_2fprocessing_2dservice_2dv2_2eproto);
    return ::descriptor_table_proto_2fpalantir_2fprocessing_2dservice_2dv2_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPathFieldNumber = 1,
  };
  // string path = 1;
  void clear_path();
  const std::string& path() const;
  void set_path(const std::string& value);
  void set_path(std::string&& value);
  void set_path(const char* value);
  void set_path(const char* value, size_t size);
  std::string* mutable_path();
  std::string* release_path();
  void set_allocated_path(std::string* path);
  private:
  const std::string& _internal_path() const;
  void _internal_set_path(const std::string& value);
  std::string* _internal_mutable_path();
  public:

  // @@protoc_insertion_point(class_scope:aip.processor.v2.Nitf21Image)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr path_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_proto_2fpalantir_2fprocessing_2dservice_2dv2_2eproto;
};
// -------------------------------------------------------------------

class DigitalGlobeMetadata PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:aip.processor.v2.DigitalGlobeMetadata) */ {
 public:
  inline DigitalGlobeMetadata() : DigitalGlobeMetadata(nullptr) {}
  virtual ~DigitalGlobeMetadata();

  DigitalGlobeMetadata(const DigitalGlobeMetadata& from);
  DigitalGlobeMetadata(DigitalGlobeMetadata&& from) noexcept
    : DigitalGlobeMetadata() {
    *this = ::std::move(from);
  }

  inline DigitalGlobeMetadata& operator=(const DigitalGlobeMetadata& from) {
    CopyFrom(from);
    return *this;
  }
  inline DigitalGlobeMetadata& operator=(DigitalGlobeMetadata&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const DigitalGlobeMetadata& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DigitalGlobeMetadata* internal_default_instance() {
    return reinterpret_cast<const DigitalGlobeMetadata*>(
               &_DigitalGlobeMetadata_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    32;

  friend void swap(DigitalGlobeMetadata& a, DigitalGlobeMetadata& b) {
    a.Swap(&b);
  }
  inline void Swap(DigitalGlobeMetadata* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DigitalGlobeMetadata* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline DigitalGlobeMetadata* New() const final {
    return CreateMaybeMessage<DigitalGlobeMetadata>(nullptr);
  }

  DigitalGlobeMetadata* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<DigitalGlobeMetadata>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const DigitalGlobeMetadata& from);
  void MergeFrom(const DigitalGlobeMetadata& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DigitalGlobeMetadata* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "aip.processor.v2.DigitalGlobeMetadata";
  }
  protected:
  explicit DigitalGlobeMetadata(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_proto_2fpalantir_2fprocessing_2dservice_2dv2_2eproto);
    return ::descriptor_table_proto_2fpalantir_2fprocessing_2dservice_2dv2_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFeatureIdFieldNumber = 1,
    kSourceFieldNumber = 3,
    kProductTypeFieldNumber = 6,
    kTopLeftFieldNumber = 11,
    kTopRightFieldNumber = 12,
    kBottomRightFieldNumber = 13,
    kBottomLeftFieldNumber = 14,
    kOffNadirDegreesFieldNumber = 7,
    kSunElevationDegreesFieldNumber = 8,
    kSunAzimuthDegreesFieldNumber = 9,
    kGroundSampleDistanceCentimetersFieldNumber = 10,
    kNiirsFieldNumber = 4,
  };
  // string feature_id = 1;
  void clear_feature_id();
  const std::string& feature_id() const;
  void set_feature_id(const std::string& value);
  void set_feature_id(std::string&& value);
  void set_feature_id(const char* value);
  void set_feature_id(const char* value, size_t size);
  std::string* mutable_feature_id();
  std::string* release_feature_id();
  void set_allocated_feature_id(std::string* feature_id);
  private:
  const std::string& _internal_feature_id() const;
  void _internal_set_feature_id(const std::string& value);
  std::string* _internal_mutable_feature_id();
  public:

  // string source = 3;
  void clear_source();
  const std::string& source() const;
  void set_source(const std::string& value);
  void set_source(std::string&& value);
  void set_source(const char* value);
  void set_source(const char* value, size_t size);
  std::string* mutable_source();
  std::string* release_source();
  void set_allocated_source(std::string* source);
  private:
  const std::string& _internal_source() const;
  void _internal_set_source(const std::string& value);
  std::string* _internal_mutable_source();
  public:

  // string product_type = 6;
  void clear_product_type();
  const std::string& product_type() const;
  void set_product_type(const std::string& value);
  void set_product_type(std::string&& value);
  void set_product_type(const char* value);
  void set_product_type(const char* value, size_t size);
  std::string* mutable_product_type();
  std::string* release_product_type();
  void set_allocated_product_type(std::string* product_type);
  private:
  const std::string& _internal_product_type() const;
  void _internal_set_product_type(const std::string& value);
  std::string* _internal_mutable_product_type();
  public:

  // .aip.processor.v2.GeoCoordinate top_left = 11;
  bool has_top_left() const;
  private:
  bool _internal_has_top_left() const;
  public:
  void clear_top_left();
  const ::aip::processor::v2::GeoCoordinate& top_left() const;
  ::aip::processor::v2::GeoCoordinate* release_top_left();
  ::aip::processor::v2::GeoCoordinate* mutable_top_left();
  void set_allocated_top_left(::aip::processor::v2::GeoCoordinate* top_left);
  private:
  const ::aip::processor::v2::GeoCoordinate& _internal_top_left() const;
  ::aip::processor::v2::GeoCoordinate* _internal_mutable_top_left();
  public:
  void unsafe_arena_set_allocated_top_left(
      ::aip::processor::v2::GeoCoordinate* top_left);
  ::aip::processor::v2::GeoCoordinate* unsafe_arena_release_top_left();

  // .aip.processor.v2.GeoCoordinate top_right = 12;
  bool has_top_right() const;
  private:
  bool _internal_has_top_right() const;
  public:
  void clear_top_right();
  const ::aip::processor::v2::GeoCoordinate& top_right() const;
  ::aip::processor::v2::GeoCoordinate* release_top_right();
  ::aip::processor::v2::GeoCoordinate* mutable_top_right();
  void set_allocated_top_right(::aip::processor::v2::GeoCoordinate* top_right);
  private:
  const ::aip::processor::v2::GeoCoordinate& _internal_top_right() const;
  ::aip::processor::v2::GeoCoordinate* _internal_mutable_top_right();
  public:
  void unsafe_arena_set_allocated_top_right(
      ::aip::processor::v2::GeoCoordinate* top_right);
  ::aip::processor::v2::GeoCoordinate* unsafe_arena_release_top_right();

  // .aip.processor.v2.GeoCoordinate bottom_right = 13;
  bool has_bottom_right() const;
  private:
  bool _internal_has_bottom_right() const;
  public:
  void clear_bottom_right();
  const ::aip::processor::v2::GeoCoordinate& bottom_right() const;
  ::aip::processor::v2::GeoCoordinate* release_bottom_right();
  ::aip::processor::v2::GeoCoordinate* mutable_bottom_right();
  void set_allocated_bottom_right(::aip::processor::v2::GeoCoordinate* bottom_right);
  private:
  const ::aip::processor::v2::GeoCoordinate& _internal_bottom_right() const;
  ::aip::processor::v2::GeoCoordinate* _internal_mutable_bottom_right();
  public:
  void unsafe_arena_set_allocated_bottom_right(
      ::aip::processor::v2::GeoCoordinate* bottom_right);
  ::aip::processor::v2::GeoCoordinate* unsafe_arena_release_bottom_right();

  // .aip.processor.v2.GeoCoordinate bottom_left = 14;
  bool has_bottom_left() const;
  private:
  bool _internal_has_bottom_left() const;
  public:
  void clear_bottom_left();
  const ::aip::processor::v2::GeoCoordinate& bottom_left() const;
  ::aip::processor::v2::GeoCoordinate* release_bottom_left();
  ::aip::processor::v2::GeoCoordinate* mutable_bottom_left();
  void set_allocated_bottom_left(::aip::processor::v2::GeoCoordinate* bottom_left);
  private:
  const ::aip::processor::v2::GeoCoordinate& _internal_bottom_left() const;
  ::aip::processor::v2::GeoCoordinate* _internal_mutable_bottom_left();
  public:
  void unsafe_arena_set_allocated_bottom_left(
      ::aip::processor::v2::GeoCoordinate* bottom_left);
  ::aip::processor::v2::GeoCoordinate* unsafe_arena_release_bottom_left();

  // double off_nadir_degrees = 7;
  void clear_off_nadir_degrees();
  double off_nadir_degrees() const;
  void set_off_nadir_degrees(double value);
  private:
  double _internal_off_nadir_degrees() const;
  void _internal_set_off_nadir_degrees(double value);
  public:

  // double sun_elevation_degrees = 8;
  void clear_sun_elevation_degrees();
  double sun_elevation_degrees() const;
  void set_sun_elevation_degrees(double value);
  private:
  double _internal_sun_elevation_degrees() const;
  void _internal_set_sun_elevation_degrees(double value);
  public:

  // double sun_azimuth_degrees = 9;
  void clear_sun_azimuth_degrees();
  double sun_azimuth_degrees() const;
  void set_sun_azimuth_degrees(double value);
  private:
  double _internal_sun_azimuth_degrees() const;
  void _internal_set_sun_azimuth_degrees(double value);
  public:

  // uint64 ground_sample_distance_centimeters = 10;
  void clear_ground_sample_distance_centimeters();
  ::PROTOBUF_NAMESPACE_ID::uint64 ground_sample_distance_centimeters() const;
  void set_ground_sample_distance_centimeters(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_ground_sample_distance_centimeters() const;
  void _internal_set_ground_sample_distance_centimeters(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // uint32 niirs = 4;
  void clear_niirs();
  ::PROTOBUF_NAMESPACE_ID::uint32 niirs() const;
  void set_niirs(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_niirs() const;
  void _internal_set_niirs(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:aip.processor.v2.DigitalGlobeMetadata)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr feature_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr source_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr product_type_;
  ::aip::processor::v2::GeoCoordinate* top_left_;
  ::aip::processor::v2::GeoCoordinate* top_right_;
  ::aip::processor::v2::GeoCoordinate* bottom_right_;
  ::aip::processor::v2::GeoCoordinate* bottom_left_;
  double off_nadir_degrees_;
  double sun_elevation_degrees_;
  double sun_azimuth_degrees_;
  ::PROTOBUF_NAMESPACE_ID::uint64 ground_sample_distance_centimeters_;
  ::PROTOBUF_NAMESPACE_ID::uint32 niirs_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_proto_2fpalantir_2fprocessing_2dservice_2dv2_2eproto;
};
// -------------------------------------------------------------------

class ProviderMetadata PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:aip.processor.v2.ProviderMetadata) */ {
 public:
  inline ProviderMetadata() : ProviderMetadata(nullptr) {}
  virtual ~ProviderMetadata();

  ProviderMetadata(const ProviderMetadata& from);
  ProviderMetadata(ProviderMetadata&& from) noexcept
    : ProviderMetadata() {
    *this = ::std::move(from);
  }

  inline ProviderMetadata& operator=(const ProviderMetadata& from) {
    CopyFrom(from);
    return *this;
  }
  inline ProviderMetadata& operator=(ProviderMetadata&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ProviderMetadata& default_instance();

  enum MetadataCase {
    kDigitalGlobe = 1,
    METADATA_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ProviderMetadata* internal_default_instance() {
    return reinterpret_cast<const ProviderMetadata*>(
               &_ProviderMetadata_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    33;

  friend void swap(ProviderMetadata& a, ProviderMetadata& b) {
    a.Swap(&b);
  }
  inline void Swap(ProviderMetadata* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ProviderMetadata* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ProviderMetadata* New() const final {
    return CreateMaybeMessage<ProviderMetadata>(nullptr);
  }

  ProviderMetadata* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ProviderMetadata>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ProviderMetadata& from);
  void MergeFrom(const ProviderMetadata& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ProviderMetadata* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "aip.processor.v2.ProviderMetadata";
  }
  protected:
  explicit ProviderMetadata(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_proto_2fpalantir_2fprocessing_2dservice_2dv2_2eproto);
    return ::descriptor_table_proto_2fpalantir_2fprocessing_2dservice_2dv2_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDigitalGlobeFieldNumber = 1,
  };
  // .aip.processor.v2.DigitalGlobeMetadata digital_globe = 1;
  bool has_digital_globe() const;
  private:
  bool _internal_has_digital_globe() const;
  public:
  void clear_digital_globe();
  const ::aip::processor::v2::DigitalGlobeMetadata& digital_globe() const;
  ::aip::processor::v2::DigitalGlobeMetadata* release_digital_globe();
  ::aip::processor::v2::DigitalGlobeMetadata* mutable_digital_globe();
  void set_allocated_digital_globe(::aip::processor::v2::DigitalGlobeMetadata* digital_globe);
  private:
  const ::aip::processor::v2::DigitalGlobeMetadata& _internal_digital_globe() const;
  ::aip::processor::v2::DigitalGlobeMetadata* _internal_mutable_digital_globe();
  public:
  void unsafe_arena_set_allocated_digital_globe(
      ::aip::processor::v2::DigitalGlobeMetadata* digital_globe);
  ::aip::processor::v2::DigitalGlobeMetadata* unsafe_arena_release_digital_globe();

  void clear_metadata();
  MetadataCase metadata_case() const;
  // @@protoc_insertion_point(class_scope:aip.processor.v2.ProviderMetadata)
 private:
  class _Internal;
  void set_has_digital_globe();

  inline bool has_metadata() const;
  inline void clear_has_metadata();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  union MetadataUnion {
    MetadataUnion() {}
    ::aip::processor::v2::DigitalGlobeMetadata* digital_globe_;
  } metadata_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint32 _oneof_case_[1];

  friend struct ::TableStruct_proto_2fpalantir_2fprocessing_2dservice_2dv2_2eproto;
};
// -------------------------------------------------------------------

class UasMetadata PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:aip.processor.v2.UasMetadata) */ {
 public:
  inline UasMetadata() : UasMetadata(nullptr) {}
  virtual ~UasMetadata();

  UasMetadata(const UasMetadata& from);
  UasMetadata(UasMetadata&& from) noexcept
    : UasMetadata() {
    *this = ::std::move(from);
  }

  inline UasMetadata& operator=(const UasMetadata& from) {
    CopyFrom(from);
    return *this;
  }
  inline UasMetadata& operator=(UasMetadata&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const UasMetadata& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const UasMetadata* internal_default_instance() {
    return reinterpret_cast<const UasMetadata*>(
               &_UasMetadata_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    34;

  friend void swap(UasMetadata& a, UasMetadata& b) {
    a.Swap(&b);
  }
  inline void Swap(UasMetadata* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UasMetadata* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline UasMetadata* New() const final {
    return CreateMaybeMessage<UasMetadata>(nullptr);
  }

  UasMetadata* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<UasMetadata>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const UasMetadata& from);
  void MergeFrom(const UasMetadata& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UasMetadata* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "aip.processor.v2.UasMetadata";
  }
  protected:
  explicit UasMetadata(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_proto_2fpalantir_2fprocessing_2dservice_2dv2_2eproto);
    return ::descriptor_table_proto_2fpalantir_2fprocessing_2dservice_2dv2_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kImageSourceSensorFieldNumber = 21,
    kProviderMetadataFieldNumber = 22,
    kPlatformHeadingAngleFieldNumber = 5,
    kPlatformPitchAngleFieldNumber = 6,
    kPlatformRollAngleFieldNumber = 7,
    kSensorHorizontalFovFieldNumber = 16,
    kSensorLatitudeFieldNumber = 13,
    kSensorLongitudeFieldNumber = 14,
    kSensorVerticalFovFieldNumber = 17,
    kSensorTrueAltitudeFieldNumber = 15,
    kSensorRelativeAzimuthAngleFieldNumber = 18,
    kSensorRelativeElevationAngleFieldNumber = 19,
    kSensorRelativeRollAngleFieldNumber = 20,
  };
  // string image_source_sensor = 21;
  void clear_image_source_sensor();
  const std::string& image_source_sensor() const;
  void set_image_source_sensor(const std::string& value);
  void set_image_source_sensor(std::string&& value);
  void set_image_source_sensor(const char* value);
  void set_image_source_sensor(const char* value, size_t size);
  std::string* mutable_image_source_sensor();
  std::string* release_image_source_sensor();
  void set_allocated_image_source_sensor(std::string* image_source_sensor);
  private:
  const std::string& _internal_image_source_sensor() const;
  void _internal_set_image_source_sensor(const std::string& value);
  std::string* _internal_mutable_image_source_sensor();
  public:

  // .aip.processor.v2.ProviderMetadata provider_metadata = 22;
  bool has_provider_metadata() const;
  private:
  bool _internal_has_provider_metadata() const;
  public:
  void clear_provider_metadata();
  const ::aip::processor::v2::ProviderMetadata& provider_metadata() const;
  ::aip::processor::v2::ProviderMetadata* release_provider_metadata();
  ::aip::processor::v2::ProviderMetadata* mutable_provider_metadata();
  void set_allocated_provider_metadata(::aip::processor::v2::ProviderMetadata* provider_metadata);
  private:
  const ::aip::processor::v2::ProviderMetadata& _internal_provider_metadata() const;
  ::aip::processor::v2::ProviderMetadata* _internal_mutable_provider_metadata();
  public:
  void unsafe_arena_set_allocated_provider_metadata(
      ::aip::processor::v2::ProviderMetadata* provider_metadata);
  ::aip::processor::v2::ProviderMetadata* unsafe_arena_release_provider_metadata();

  // float platform_heading_angle = 5;
  void clear_platform_heading_angle();
  float platform_heading_angle() const;
  void set_platform_heading_angle(float value);
  private:
  float _internal_platform_heading_angle() const;
  void _internal_set_platform_heading_angle(float value);
  public:

  // float platform_pitch_angle = 6;
  void clear_platform_pitch_angle();
  float platform_pitch_angle() const;
  void set_platform_pitch_angle(float value);
  private:
  float _internal_platform_pitch_angle() const;
  void _internal_set_platform_pitch_angle(float value);
  public:

  // float platform_roll_angle = 7;
  void clear_platform_roll_angle();
  float platform_roll_angle() const;
  void set_platform_roll_angle(float value);
  private:
  float _internal_platform_roll_angle() const;
  void _internal_set_platform_roll_angle(float value);
  public:

  // float sensor_horizontal_fov = 16;
  void clear_sensor_horizontal_fov();
  float sensor_horizontal_fov() const;
  void set_sensor_horizontal_fov(float value);
  private:
  float _internal_sensor_horizontal_fov() const;
  void _internal_set_sensor_horizontal_fov(float value);
  public:

  // double sensor_latitude = 13;
  void clear_sensor_latitude();
  double sensor_latitude() const;
  void set_sensor_latitude(double value);
  private:
  double _internal_sensor_latitude() const;
  void _internal_set_sensor_latitude(double value);
  public:

  // double sensor_longitude = 14;
  void clear_sensor_longitude();
  double sensor_longitude() const;
  void set_sensor_longitude(double value);
  private:
  double _internal_sensor_longitude() const;
  void _internal_set_sensor_longitude(double value);
  public:

  // float sensor_vertical_fov = 17;
  void clear_sensor_vertical_fov();
  float sensor_vertical_fov() const;
  void set_sensor_vertical_fov(float value);
  private:
  float _internal_sensor_vertical_fov() const;
  void _internal_set_sensor_vertical_fov(float value);
  public:

  // double sensor_true_altitude = 15;
  void clear_sensor_true_altitude();
  double sensor_true_altitude() const;
  void set_sensor_true_altitude(double value);
  private:
  double _internal_sensor_true_altitude() const;
  void _internal_set_sensor_true_altitude(double value);
  public:

  // double sensor_relative_azimuth_angle = 18;
  void clear_sensor_relative_azimuth_angle();
  double sensor_relative_azimuth_angle() const;
  void set_sensor_relative_azimuth_angle(double value);
  private:
  double _internal_sensor_relative_azimuth_angle() const;
  void _internal_set_sensor_relative_azimuth_angle(double value);
  public:

  // double sensor_relative_elevation_angle = 19;
  void clear_sensor_relative_elevation_angle();
  double sensor_relative_elevation_angle() const;
  void set_sensor_relative_elevation_angle(double value);
  private:
  double _internal_sensor_relative_elevation_angle() const;
  void _internal_set_sensor_relative_elevation_angle(double value);
  public:

  // double sensor_relative_roll_angle = 20;
  void clear_sensor_relative_roll_angle();
  double sensor_relative_roll_angle() const;
  void set_sensor_relative_roll_angle(double value);
  private:
  double _internal_sensor_relative_roll_angle() const;
  void _internal_set_sensor_relative_roll_angle(double value);
  public:

  // @@protoc_insertion_point(class_scope:aip.processor.v2.UasMetadata)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr image_source_sensor_;
  ::aip::processor::v2::ProviderMetadata* provider_metadata_;
  float platform_heading_angle_;
  float platform_pitch_angle_;
  float platform_roll_angle_;
  float sensor_horizontal_fov_;
  double sensor_latitude_;
  double sensor_longitude_;
  float sensor_vertical_fov_;
  double sensor_true_altitude_;
  double sensor_relative_azimuth_angle_;
  double sensor_relative_elevation_angle_;
  double sensor_relative_roll_angle_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_proto_2fpalantir_2fprocessing_2dservice_2dv2_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// ProcessorV2Config

// .aip.processor.v2.ImageFormat image_format = 1;
inline void ProcessorV2Config::clear_image_format() {
  image_format_ = 0;
}
inline ::aip::processor::v2::ImageFormat ProcessorV2Config::_internal_image_format() const {
  return static_cast< ::aip::processor::v2::ImageFormat >(image_format_);
}
inline ::aip::processor::v2::ImageFormat ProcessorV2Config::image_format() const {
  // @@protoc_insertion_point(field_get:aip.processor.v2.ProcessorV2Config.image_format)
  return _internal_image_format();
}
inline void ProcessorV2Config::_internal_set_image_format(::aip::processor::v2::ImageFormat value) {
  
  image_format_ = value;
}
inline void ProcessorV2Config::set_image_format(::aip::processor::v2::ImageFormat value) {
  _internal_set_image_format(value);
  // @@protoc_insertion_point(field_set:aip.processor.v2.ProcessorV2Config.image_format)
}

// repeated .aip.processor.v2.ProcessorV2Config.Capability capabilities = 2;
inline int ProcessorV2Config::_internal_capabilities_size() const {
  return capabilities_.size();
}
inline int ProcessorV2Config::capabilities_size() const {
  return _internal_capabilities_size();
}
inline void ProcessorV2Config::clear_capabilities() {
  capabilities_.Clear();
}
inline ::aip::processor::v2::ProcessorV2Config_Capability ProcessorV2Config::_internal_capabilities(int index) const {
  return static_cast< ::aip::processor::v2::ProcessorV2Config_Capability >(capabilities_.Get(index));
}
inline ::aip::processor::v2::ProcessorV2Config_Capability ProcessorV2Config::capabilities(int index) const {
  // @@protoc_insertion_point(field_get:aip.processor.v2.ProcessorV2Config.capabilities)
  return _internal_capabilities(index);
}
inline void ProcessorV2Config::set_capabilities(int index, ::aip::processor::v2::ProcessorV2Config_Capability value) {
  capabilities_.Set(index, value);
  // @@protoc_insertion_point(field_set:aip.processor.v2.ProcessorV2Config.capabilities)
}
inline void ProcessorV2Config::_internal_add_capabilities(::aip::processor::v2::ProcessorV2Config_Capability value) {
  capabilities_.Add(value);
}
inline void ProcessorV2Config::add_capabilities(::aip::processor::v2::ProcessorV2Config_Capability value) {
  // @@protoc_insertion_point(field_add:aip.processor.v2.ProcessorV2Config.capabilities)
  _internal_add_capabilities(value);
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>&
ProcessorV2Config::capabilities() const {
  // @@protoc_insertion_point(field_list:aip.processor.v2.ProcessorV2Config.capabilities)
  return capabilities_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>*
ProcessorV2Config::_internal_mutable_capabilities() {
  return &capabilities_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>*
ProcessorV2Config::mutable_capabilities() {
  // @@protoc_insertion_point(field_mutable_list:aip.processor.v2.ProcessorV2Config.capabilities)
  return _internal_mutable_capabilities();
}

// -------------------------------------------------------------------

// RequestHeader

// .aip.processor.v2.Identifier identifier = 1;
inline bool RequestHeader::_internal_has_identifier() const {
  return this != internal_default_instance() && identifier_ != nullptr;
}
inline bool RequestHeader::has_identifier() const {
  return _internal_has_identifier();
}
inline void RequestHeader::clear_identifier() {
  if (GetArena() == nullptr && identifier_ != nullptr) {
    delete identifier_;
  }
  identifier_ = nullptr;
}
inline const ::aip::processor::v2::Identifier& RequestHeader::_internal_identifier() const {
  const ::aip::processor::v2::Identifier* p = identifier_;
  return p != nullptr ? *p : *reinterpret_cast<const ::aip::processor::v2::Identifier*>(
      &::aip::processor::v2::_Identifier_default_instance_);
}
inline const ::aip::processor::v2::Identifier& RequestHeader::identifier() const {
  // @@protoc_insertion_point(field_get:aip.processor.v2.RequestHeader.identifier)
  return _internal_identifier();
}
inline void RequestHeader::unsafe_arena_set_allocated_identifier(
    ::aip::processor::v2::Identifier* identifier) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(identifier_);
  }
  identifier_ = identifier;
  if (identifier) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:aip.processor.v2.RequestHeader.identifier)
}
inline ::aip::processor::v2::Identifier* RequestHeader::release_identifier() {
  
  ::aip::processor::v2::Identifier* temp = identifier_;
  identifier_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::aip::processor::v2::Identifier* RequestHeader::unsafe_arena_release_identifier() {
  // @@protoc_insertion_point(field_release:aip.processor.v2.RequestHeader.identifier)
  
  ::aip::processor::v2::Identifier* temp = identifier_;
  identifier_ = nullptr;
  return temp;
}
inline ::aip::processor::v2::Identifier* RequestHeader::_internal_mutable_identifier() {
  
  if (identifier_ == nullptr) {
    auto* p = CreateMaybeMessage<::aip::processor::v2::Identifier>(GetArena());
    identifier_ = p;
  }
  return identifier_;
}
inline ::aip::processor::v2::Identifier* RequestHeader::mutable_identifier() {
  // @@protoc_insertion_point(field_mutable:aip.processor.v2.RequestHeader.identifier)
  return _internal_mutable_identifier();
}
inline void RequestHeader::set_allocated_identifier(::aip::processor::v2::Identifier* identifier) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete identifier_;
  }
  if (identifier) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(identifier);
    if (message_arena != submessage_arena) {
      identifier = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, identifier, submessage_arena);
    }
    
  } else {
    
  }
  identifier_ = identifier;
  // @@protoc_insertion_point(field_set_allocated:aip.processor.v2.RequestHeader.identifier)
}

// .google.protobuf.Duration deadline = 2;
inline bool RequestHeader::_internal_has_deadline() const {
  return this != internal_default_instance() && deadline_ != nullptr;
}
inline bool RequestHeader::has_deadline() const {
  return _internal_has_deadline();
}
inline const PROTOBUF_NAMESPACE_ID::Duration& RequestHeader::_internal_deadline() const {
  const PROTOBUF_NAMESPACE_ID::Duration* p = deadline_;
  return p != nullptr ? *p : *reinterpret_cast<const PROTOBUF_NAMESPACE_ID::Duration*>(
      &PROTOBUF_NAMESPACE_ID::_Duration_default_instance_);
}
inline const PROTOBUF_NAMESPACE_ID::Duration& RequestHeader::deadline() const {
  // @@protoc_insertion_point(field_get:aip.processor.v2.RequestHeader.deadline)
  return _internal_deadline();
}
inline void RequestHeader::unsafe_arena_set_allocated_deadline(
    PROTOBUF_NAMESPACE_ID::Duration* deadline) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(deadline_);
  }
  deadline_ = deadline;
  if (deadline) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:aip.processor.v2.RequestHeader.deadline)
}
inline PROTOBUF_NAMESPACE_ID::Duration* RequestHeader::release_deadline() {
  
  PROTOBUF_NAMESPACE_ID::Duration* temp = deadline_;
  deadline_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline PROTOBUF_NAMESPACE_ID::Duration* RequestHeader::unsafe_arena_release_deadline() {
  // @@protoc_insertion_point(field_release:aip.processor.v2.RequestHeader.deadline)
  
  PROTOBUF_NAMESPACE_ID::Duration* temp = deadline_;
  deadline_ = nullptr;
  return temp;
}
inline PROTOBUF_NAMESPACE_ID::Duration* RequestHeader::_internal_mutable_deadline() {
  
  if (deadline_ == nullptr) {
    auto* p = CreateMaybeMessage<PROTOBUF_NAMESPACE_ID::Duration>(GetArena());
    deadline_ = p;
  }
  return deadline_;
}
inline PROTOBUF_NAMESPACE_ID::Duration* RequestHeader::mutable_deadline() {
  // @@protoc_insertion_point(field_mutable:aip.processor.v2.RequestHeader.deadline)
  return _internal_mutable_deadline();
}
inline void RequestHeader::set_allocated_deadline(PROTOBUF_NAMESPACE_ID::Duration* deadline) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(deadline_);
  }
  if (deadline) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(deadline)->GetArena();
    if (message_arena != submessage_arena) {
      deadline = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, deadline, submessage_arena);
    }
    
  } else {
    
  }
  deadline_ = deadline;
  // @@protoc_insertion_point(field_set_allocated:aip.processor.v2.RequestHeader.deadline)
}

// .aip.processor.v2.Timestamp timestamp = 3;
inline bool RequestHeader::_internal_has_timestamp() const {
  return this != internal_default_instance() && timestamp_ != nullptr;
}
inline bool RequestHeader::has_timestamp() const {
  return _internal_has_timestamp();
}
inline void RequestHeader::clear_timestamp() {
  if (GetArena() == nullptr && timestamp_ != nullptr) {
    delete timestamp_;
  }
  timestamp_ = nullptr;
}
inline const ::aip::processor::v2::Timestamp& RequestHeader::_internal_timestamp() const {
  const ::aip::processor::v2::Timestamp* p = timestamp_;
  return p != nullptr ? *p : *reinterpret_cast<const ::aip::processor::v2::Timestamp*>(
      &::aip::processor::v2::_Timestamp_default_instance_);
}
inline const ::aip::processor::v2::Timestamp& RequestHeader::timestamp() const {
  // @@protoc_insertion_point(field_get:aip.processor.v2.RequestHeader.timestamp)
  return _internal_timestamp();
}
inline void RequestHeader::unsafe_arena_set_allocated_timestamp(
    ::aip::processor::v2::Timestamp* timestamp) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(timestamp_);
  }
  timestamp_ = timestamp;
  if (timestamp) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:aip.processor.v2.RequestHeader.timestamp)
}
inline ::aip::processor::v2::Timestamp* RequestHeader::release_timestamp() {
  
  ::aip::processor::v2::Timestamp* temp = timestamp_;
  timestamp_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::aip::processor::v2::Timestamp* RequestHeader::unsafe_arena_release_timestamp() {
  // @@protoc_insertion_point(field_release:aip.processor.v2.RequestHeader.timestamp)
  
  ::aip::processor::v2::Timestamp* temp = timestamp_;
  timestamp_ = nullptr;
  return temp;
}
inline ::aip::processor::v2::Timestamp* RequestHeader::_internal_mutable_timestamp() {
  
  if (timestamp_ == nullptr) {
    auto* p = CreateMaybeMessage<::aip::processor::v2::Timestamp>(GetArena());
    timestamp_ = p;
  }
  return timestamp_;
}
inline ::aip::processor::v2::Timestamp* RequestHeader::mutable_timestamp() {
  // @@protoc_insertion_point(field_mutable:aip.processor.v2.RequestHeader.timestamp)
  return _internal_mutable_timestamp();
}
inline void RequestHeader::set_allocated_timestamp(::aip::processor::v2::Timestamp* timestamp) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete timestamp_;
  }
  if (timestamp) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(timestamp);
    if (message_arena != submessage_arena) {
      timestamp = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, timestamp, submessage_arena);
    }
    
  } else {
    
  }
  timestamp_ = timestamp;
  // @@protoc_insertion_point(field_set_allocated:aip.processor.v2.RequestHeader.timestamp)
}

// -------------------------------------------------------------------

// Identifier

// uint64 stream_id = 1;
inline void Identifier::clear_stream_id() {
  stream_id_ = PROTOBUF_ULONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 Identifier::_internal_stream_id() const {
  return stream_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 Identifier::stream_id() const {
  // @@protoc_insertion_point(field_get:aip.processor.v2.Identifier.stream_id)
  return _internal_stream_id();
}
inline void Identifier::_internal_set_stream_id(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  stream_id_ = value;
}
inline void Identifier::set_stream_id(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_stream_id(value);
  // @@protoc_insertion_point(field_set:aip.processor.v2.Identifier.stream_id)
}

// uint64 frame_id = 2;
inline void Identifier::clear_frame_id() {
  frame_id_ = PROTOBUF_ULONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 Identifier::_internal_frame_id() const {
  return frame_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 Identifier::frame_id() const {
  // @@protoc_insertion_point(field_get:aip.processor.v2.Identifier.frame_id)
  return _internal_frame_id();
}
inline void Identifier::_internal_set_frame_id(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  frame_id_ = value;
}
inline void Identifier::set_frame_id(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_frame_id(value);
  // @@protoc_insertion_point(field_set:aip.processor.v2.Identifier.frame_id)
}

// -------------------------------------------------------------------

// Timestamp

// uint64 nanos = 1;
inline void Timestamp::clear_nanos() {
  nanos_ = PROTOBUF_ULONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 Timestamp::_internal_nanos() const {
  return nanos_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 Timestamp::nanos() const {
  // @@protoc_insertion_point(field_get:aip.processor.v2.Timestamp.nanos)
  return _internal_nanos();
}
inline void Timestamp::_internal_set_nanos(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  nanos_ = value;
}
inline void Timestamp::set_nanos(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_nanos(value);
  // @@protoc_insertion_point(field_set:aip.processor.v2.Timestamp.nanos)
}

// -------------------------------------------------------------------

// GeoRegistrationRequest

// .aip.processor.v2.RequestHeader header = 1;
inline bool GeoRegistrationRequest::_internal_has_header() const {
  return this != internal_default_instance() && header_ != nullptr;
}
inline bool GeoRegistrationRequest::has_header() const {
  return _internal_has_header();
}
inline void GeoRegistrationRequest::clear_header() {
  if (GetArena() == nullptr && header_ != nullptr) {
    delete header_;
  }
  header_ = nullptr;
}
inline const ::aip::processor::v2::RequestHeader& GeoRegistrationRequest::_internal_header() const {
  const ::aip::processor::v2::RequestHeader* p = header_;
  return p != nullptr ? *p : *reinterpret_cast<const ::aip::processor::v2::RequestHeader*>(
      &::aip::processor::v2::_RequestHeader_default_instance_);
}
inline const ::aip::processor::v2::RequestHeader& GeoRegistrationRequest::header() const {
  // @@protoc_insertion_point(field_get:aip.processor.v2.GeoRegistrationRequest.header)
  return _internal_header();
}
inline void GeoRegistrationRequest::unsafe_arena_set_allocated_header(
    ::aip::processor::v2::RequestHeader* header) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header_);
  }
  header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:aip.processor.v2.GeoRegistrationRequest.header)
}
inline ::aip::processor::v2::RequestHeader* GeoRegistrationRequest::release_header() {
  
  ::aip::processor::v2::RequestHeader* temp = header_;
  header_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::aip::processor::v2::RequestHeader* GeoRegistrationRequest::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:aip.processor.v2.GeoRegistrationRequest.header)
  
  ::aip::processor::v2::RequestHeader* temp = header_;
  header_ = nullptr;
  return temp;
}
inline ::aip::processor::v2::RequestHeader* GeoRegistrationRequest::_internal_mutable_header() {
  
  if (header_ == nullptr) {
    auto* p = CreateMaybeMessage<::aip::processor::v2::RequestHeader>(GetArena());
    header_ = p;
  }
  return header_;
}
inline ::aip::processor::v2::RequestHeader* GeoRegistrationRequest::mutable_header() {
  // @@protoc_insertion_point(field_mutable:aip.processor.v2.GeoRegistrationRequest.header)
  return _internal_mutable_header();
}
inline void GeoRegistrationRequest::set_allocated_header(::aip::processor::v2::RequestHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete header_;
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(header);
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:aip.processor.v2.GeoRegistrationRequest.header)
}

// .aip.processor.v2.Frame frame = 2;
inline bool GeoRegistrationRequest::_internal_has_frame() const {
  return this != internal_default_instance() && frame_ != nullptr;
}
inline bool GeoRegistrationRequest::has_frame() const {
  return _internal_has_frame();
}
inline void GeoRegistrationRequest::clear_frame() {
  if (GetArena() == nullptr && frame_ != nullptr) {
    delete frame_;
  }
  frame_ = nullptr;
}
inline const ::aip::processor::v2::Frame& GeoRegistrationRequest::_internal_frame() const {
  const ::aip::processor::v2::Frame* p = frame_;
  return p != nullptr ? *p : *reinterpret_cast<const ::aip::processor::v2::Frame*>(
      &::aip::processor::v2::_Frame_default_instance_);
}
inline const ::aip::processor::v2::Frame& GeoRegistrationRequest::frame() const {
  // @@protoc_insertion_point(field_get:aip.processor.v2.GeoRegistrationRequest.frame)
  return _internal_frame();
}
inline void GeoRegistrationRequest::unsafe_arena_set_allocated_frame(
    ::aip::processor::v2::Frame* frame) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(frame_);
  }
  frame_ = frame;
  if (frame) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:aip.processor.v2.GeoRegistrationRequest.frame)
}
inline ::aip::processor::v2::Frame* GeoRegistrationRequest::release_frame() {
  
  ::aip::processor::v2::Frame* temp = frame_;
  frame_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::aip::processor::v2::Frame* GeoRegistrationRequest::unsafe_arena_release_frame() {
  // @@protoc_insertion_point(field_release:aip.processor.v2.GeoRegistrationRequest.frame)
  
  ::aip::processor::v2::Frame* temp = frame_;
  frame_ = nullptr;
  return temp;
}
inline ::aip::processor::v2::Frame* GeoRegistrationRequest::_internal_mutable_frame() {
  
  if (frame_ == nullptr) {
    auto* p = CreateMaybeMessage<::aip::processor::v2::Frame>(GetArena());
    frame_ = p;
  }
  return frame_;
}
inline ::aip::processor::v2::Frame* GeoRegistrationRequest::mutable_frame() {
  // @@protoc_insertion_point(field_mutable:aip.processor.v2.GeoRegistrationRequest.frame)
  return _internal_mutable_frame();
}
inline void GeoRegistrationRequest::set_allocated_frame(::aip::processor::v2::Frame* frame) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete frame_;
  }
  if (frame) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(frame);
    if (message_arena != submessage_arena) {
      frame = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, frame, submessage_arena);
    }
    
  } else {
    
  }
  frame_ = frame;
  // @@protoc_insertion_point(field_set_allocated:aip.processor.v2.GeoRegistrationRequest.frame)
}

// -------------------------------------------------------------------

// GeoRegistrationResponse

// .aip.processor.v2.Identifier identifier = 1;
inline bool GeoRegistrationResponse::_internal_has_identifier() const {
  return this != internal_default_instance() && identifier_ != nullptr;
}
inline bool GeoRegistrationResponse::has_identifier() const {
  return _internal_has_identifier();
}
inline void GeoRegistrationResponse::clear_identifier() {
  if (GetArena() == nullptr && identifier_ != nullptr) {
    delete identifier_;
  }
  identifier_ = nullptr;
}
inline const ::aip::processor::v2::Identifier& GeoRegistrationResponse::_internal_identifier() const {
  const ::aip::processor::v2::Identifier* p = identifier_;
  return p != nullptr ? *p : *reinterpret_cast<const ::aip::processor::v2::Identifier*>(
      &::aip::processor::v2::_Identifier_default_instance_);
}
inline const ::aip::processor::v2::Identifier& GeoRegistrationResponse::identifier() const {
  // @@protoc_insertion_point(field_get:aip.processor.v2.GeoRegistrationResponse.identifier)
  return _internal_identifier();
}
inline void GeoRegistrationResponse::unsafe_arena_set_allocated_identifier(
    ::aip::processor::v2::Identifier* identifier) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(identifier_);
  }
  identifier_ = identifier;
  if (identifier) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:aip.processor.v2.GeoRegistrationResponse.identifier)
}
inline ::aip::processor::v2::Identifier* GeoRegistrationResponse::release_identifier() {
  
  ::aip::processor::v2::Identifier* temp = identifier_;
  identifier_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::aip::processor::v2::Identifier* GeoRegistrationResponse::unsafe_arena_release_identifier() {
  // @@protoc_insertion_point(field_release:aip.processor.v2.GeoRegistrationResponse.identifier)
  
  ::aip::processor::v2::Identifier* temp = identifier_;
  identifier_ = nullptr;
  return temp;
}
inline ::aip::processor::v2::Identifier* GeoRegistrationResponse::_internal_mutable_identifier() {
  
  if (identifier_ == nullptr) {
    auto* p = CreateMaybeMessage<::aip::processor::v2::Identifier>(GetArena());
    identifier_ = p;
  }
  return identifier_;
}
inline ::aip::processor::v2::Identifier* GeoRegistrationResponse::mutable_identifier() {
  // @@protoc_insertion_point(field_mutable:aip.processor.v2.GeoRegistrationResponse.identifier)
  return _internal_mutable_identifier();
}
inline void GeoRegistrationResponse::set_allocated_identifier(::aip::processor::v2::Identifier* identifier) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete identifier_;
  }
  if (identifier) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(identifier);
    if (message_arena != submessage_arena) {
      identifier = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, identifier, submessage_arena);
    }
    
  } else {
    
  }
  identifier_ = identifier;
  // @@protoc_insertion_point(field_set_allocated:aip.processor.v2.GeoRegistrationResponse.identifier)
}

// .aip.processor.v2.GeoRegistration geo_registration = 2;
inline bool GeoRegistrationResponse::_internal_has_geo_registration() const {
  return this != internal_default_instance() && geo_registration_ != nullptr;
}
inline bool GeoRegistrationResponse::has_geo_registration() const {
  return _internal_has_geo_registration();
}
inline void GeoRegistrationResponse::clear_geo_registration() {
  if (GetArena() == nullptr && geo_registration_ != nullptr) {
    delete geo_registration_;
  }
  geo_registration_ = nullptr;
}
inline const ::aip::processor::v2::GeoRegistration& GeoRegistrationResponse::_internal_geo_registration() const {
  const ::aip::processor::v2::GeoRegistration* p = geo_registration_;
  return p != nullptr ? *p : *reinterpret_cast<const ::aip::processor::v2::GeoRegistration*>(
      &::aip::processor::v2::_GeoRegistration_default_instance_);
}
inline const ::aip::processor::v2::GeoRegistration& GeoRegistrationResponse::geo_registration() const {
  // @@protoc_insertion_point(field_get:aip.processor.v2.GeoRegistrationResponse.geo_registration)
  return _internal_geo_registration();
}
inline void GeoRegistrationResponse::unsafe_arena_set_allocated_geo_registration(
    ::aip::processor::v2::GeoRegistration* geo_registration) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(geo_registration_);
  }
  geo_registration_ = geo_registration;
  if (geo_registration) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:aip.processor.v2.GeoRegistrationResponse.geo_registration)
}
inline ::aip::processor::v2::GeoRegistration* GeoRegistrationResponse::release_geo_registration() {
  
  ::aip::processor::v2::GeoRegistration* temp = geo_registration_;
  geo_registration_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::aip::processor::v2::GeoRegistration* GeoRegistrationResponse::unsafe_arena_release_geo_registration() {
  // @@protoc_insertion_point(field_release:aip.processor.v2.GeoRegistrationResponse.geo_registration)
  
  ::aip::processor::v2::GeoRegistration* temp = geo_registration_;
  geo_registration_ = nullptr;
  return temp;
}
inline ::aip::processor::v2::GeoRegistration* GeoRegistrationResponse::_internal_mutable_geo_registration() {
  
  if (geo_registration_ == nullptr) {
    auto* p = CreateMaybeMessage<::aip::processor::v2::GeoRegistration>(GetArena());
    geo_registration_ = p;
  }
  return geo_registration_;
}
inline ::aip::processor::v2::GeoRegistration* GeoRegistrationResponse::mutable_geo_registration() {
  // @@protoc_insertion_point(field_mutable:aip.processor.v2.GeoRegistrationResponse.geo_registration)
  return _internal_mutable_geo_registration();
}
inline void GeoRegistrationResponse::set_allocated_geo_registration(::aip::processor::v2::GeoRegistration* geo_registration) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete geo_registration_;
  }
  if (geo_registration) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(geo_registration);
    if (message_arena != submessage_arena) {
      geo_registration = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, geo_registration, submessage_arena);
    }
    
  } else {
    
  }
  geo_registration_ = geo_registration;
  // @@protoc_insertion_point(field_set_allocated:aip.processor.v2.GeoRegistrationResponse.geo_registration)
}

// -------------------------------------------------------------------

// InferenceRequest

// .aip.processor.v2.RequestHeader header = 1;
inline bool InferenceRequest::_internal_has_header() const {
  return this != internal_default_instance() && header_ != nullptr;
}
inline bool InferenceRequest::has_header() const {
  return _internal_has_header();
}
inline void InferenceRequest::clear_header() {
  if (GetArena() == nullptr && header_ != nullptr) {
    delete header_;
  }
  header_ = nullptr;
}
inline const ::aip::processor::v2::RequestHeader& InferenceRequest::_internal_header() const {
  const ::aip::processor::v2::RequestHeader* p = header_;
  return p != nullptr ? *p : *reinterpret_cast<const ::aip::processor::v2::RequestHeader*>(
      &::aip::processor::v2::_RequestHeader_default_instance_);
}
inline const ::aip::processor::v2::RequestHeader& InferenceRequest::header() const {
  // @@protoc_insertion_point(field_get:aip.processor.v2.InferenceRequest.header)
  return _internal_header();
}
inline void InferenceRequest::unsafe_arena_set_allocated_header(
    ::aip::processor::v2::RequestHeader* header) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header_);
  }
  header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:aip.processor.v2.InferenceRequest.header)
}
inline ::aip::processor::v2::RequestHeader* InferenceRequest::release_header() {
  
  ::aip::processor::v2::RequestHeader* temp = header_;
  header_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::aip::processor::v2::RequestHeader* InferenceRequest::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:aip.processor.v2.InferenceRequest.header)
  
  ::aip::processor::v2::RequestHeader* temp = header_;
  header_ = nullptr;
  return temp;
}
inline ::aip::processor::v2::RequestHeader* InferenceRequest::_internal_mutable_header() {
  
  if (header_ == nullptr) {
    auto* p = CreateMaybeMessage<::aip::processor::v2::RequestHeader>(GetArena());
    header_ = p;
  }
  return header_;
}
inline ::aip::processor::v2::RequestHeader* InferenceRequest::mutable_header() {
  // @@protoc_insertion_point(field_mutable:aip.processor.v2.InferenceRequest.header)
  return _internal_mutable_header();
}
inline void InferenceRequest::set_allocated_header(::aip::processor::v2::RequestHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete header_;
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(header);
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:aip.processor.v2.InferenceRequest.header)
}

// .aip.processor.v2.Frame frame = 2;
inline bool InferenceRequest::_internal_has_frame() const {
  return this != internal_default_instance() && frame_ != nullptr;
}
inline bool InferenceRequest::has_frame() const {
  return _internal_has_frame();
}
inline void InferenceRequest::clear_frame() {
  if (GetArena() == nullptr && frame_ != nullptr) {
    delete frame_;
  }
  frame_ = nullptr;
}
inline const ::aip::processor::v2::Frame& InferenceRequest::_internal_frame() const {
  const ::aip::processor::v2::Frame* p = frame_;
  return p != nullptr ? *p : *reinterpret_cast<const ::aip::processor::v2::Frame*>(
      &::aip::processor::v2::_Frame_default_instance_);
}
inline const ::aip::processor::v2::Frame& InferenceRequest::frame() const {
  // @@protoc_insertion_point(field_get:aip.processor.v2.InferenceRequest.frame)
  return _internal_frame();
}
inline void InferenceRequest::unsafe_arena_set_allocated_frame(
    ::aip::processor::v2::Frame* frame) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(frame_);
  }
  frame_ = frame;
  if (frame) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:aip.processor.v2.InferenceRequest.frame)
}
inline ::aip::processor::v2::Frame* InferenceRequest::release_frame() {
  
  ::aip::processor::v2::Frame* temp = frame_;
  frame_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::aip::processor::v2::Frame* InferenceRequest::unsafe_arena_release_frame() {
  // @@protoc_insertion_point(field_release:aip.processor.v2.InferenceRequest.frame)
  
  ::aip::processor::v2::Frame* temp = frame_;
  frame_ = nullptr;
  return temp;
}
inline ::aip::processor::v2::Frame* InferenceRequest::_internal_mutable_frame() {
  
  if (frame_ == nullptr) {
    auto* p = CreateMaybeMessage<::aip::processor::v2::Frame>(GetArena());
    frame_ = p;
  }
  return frame_;
}
inline ::aip::processor::v2::Frame* InferenceRequest::mutable_frame() {
  // @@protoc_insertion_point(field_mutable:aip.processor.v2.InferenceRequest.frame)
  return _internal_mutable_frame();
}
inline void InferenceRequest::set_allocated_frame(::aip::processor::v2::Frame* frame) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete frame_;
  }
  if (frame) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(frame);
    if (message_arena != submessage_arena) {
      frame = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, frame, submessage_arena);
    }
    
  } else {
    
  }
  frame_ = frame;
  // @@protoc_insertion_point(field_set_allocated:aip.processor.v2.InferenceRequest.frame)
}

// -------------------------------------------------------------------

// InferenceResponse

// .aip.processor.v2.Identifier identifier = 1;
inline bool InferenceResponse::_internal_has_identifier() const {
  return this != internal_default_instance() && identifier_ != nullptr;
}
inline bool InferenceResponse::has_identifier() const {
  return _internal_has_identifier();
}
inline void InferenceResponse::clear_identifier() {
  if (GetArena() == nullptr && identifier_ != nullptr) {
    delete identifier_;
  }
  identifier_ = nullptr;
}
inline const ::aip::processor::v2::Identifier& InferenceResponse::_internal_identifier() const {
  const ::aip::processor::v2::Identifier* p = identifier_;
  return p != nullptr ? *p : *reinterpret_cast<const ::aip::processor::v2::Identifier*>(
      &::aip::processor::v2::_Identifier_default_instance_);
}
inline const ::aip::processor::v2::Identifier& InferenceResponse::identifier() const {
  // @@protoc_insertion_point(field_get:aip.processor.v2.InferenceResponse.identifier)
  return _internal_identifier();
}
inline void InferenceResponse::unsafe_arena_set_allocated_identifier(
    ::aip::processor::v2::Identifier* identifier) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(identifier_);
  }
  identifier_ = identifier;
  if (identifier) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:aip.processor.v2.InferenceResponse.identifier)
}
inline ::aip::processor::v2::Identifier* InferenceResponse::release_identifier() {
  
  ::aip::processor::v2::Identifier* temp = identifier_;
  identifier_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::aip::processor::v2::Identifier* InferenceResponse::unsafe_arena_release_identifier() {
  // @@protoc_insertion_point(field_release:aip.processor.v2.InferenceResponse.identifier)
  
  ::aip::processor::v2::Identifier* temp = identifier_;
  identifier_ = nullptr;
  return temp;
}
inline ::aip::processor::v2::Identifier* InferenceResponse::_internal_mutable_identifier() {
  
  if (identifier_ == nullptr) {
    auto* p = CreateMaybeMessage<::aip::processor::v2::Identifier>(GetArena());
    identifier_ = p;
  }
  return identifier_;
}
inline ::aip::processor::v2::Identifier* InferenceResponse::mutable_identifier() {
  // @@protoc_insertion_point(field_mutable:aip.processor.v2.InferenceResponse.identifier)
  return _internal_mutable_identifier();
}
inline void InferenceResponse::set_allocated_identifier(::aip::processor::v2::Identifier* identifier) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete identifier_;
  }
  if (identifier) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(identifier);
    if (message_arena != submessage_arena) {
      identifier = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, identifier, submessage_arena);
    }
    
  } else {
    
  }
  identifier_ = identifier;
  // @@protoc_insertion_point(field_set_allocated:aip.processor.v2.InferenceResponse.identifier)
}

// .aip.processor.v2.Inferences inferences = 2;
inline bool InferenceResponse::_internal_has_inferences() const {
  return this != internal_default_instance() && inferences_ != nullptr;
}
inline bool InferenceResponse::has_inferences() const {
  return _internal_has_inferences();
}
inline void InferenceResponse::clear_inferences() {
  if (GetArena() == nullptr && inferences_ != nullptr) {
    delete inferences_;
  }
  inferences_ = nullptr;
}
inline const ::aip::processor::v2::Inferences& InferenceResponse::_internal_inferences() const {
  const ::aip::processor::v2::Inferences* p = inferences_;
  return p != nullptr ? *p : *reinterpret_cast<const ::aip::processor::v2::Inferences*>(
      &::aip::processor::v2::_Inferences_default_instance_);
}
inline const ::aip::processor::v2::Inferences& InferenceResponse::inferences() const {
  // @@protoc_insertion_point(field_get:aip.processor.v2.InferenceResponse.inferences)
  return _internal_inferences();
}
inline void InferenceResponse::unsafe_arena_set_allocated_inferences(
    ::aip::processor::v2::Inferences* inferences) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(inferences_);
  }
  inferences_ = inferences;
  if (inferences) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:aip.processor.v2.InferenceResponse.inferences)
}
inline ::aip::processor::v2::Inferences* InferenceResponse::release_inferences() {
  
  ::aip::processor::v2::Inferences* temp = inferences_;
  inferences_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::aip::processor::v2::Inferences* InferenceResponse::unsafe_arena_release_inferences() {
  // @@protoc_insertion_point(field_release:aip.processor.v2.InferenceResponse.inferences)
  
  ::aip::processor::v2::Inferences* temp = inferences_;
  inferences_ = nullptr;
  return temp;
}
inline ::aip::processor::v2::Inferences* InferenceResponse::_internal_mutable_inferences() {
  
  if (inferences_ == nullptr) {
    auto* p = CreateMaybeMessage<::aip::processor::v2::Inferences>(GetArena());
    inferences_ = p;
  }
  return inferences_;
}
inline ::aip::processor::v2::Inferences* InferenceResponse::mutable_inferences() {
  // @@protoc_insertion_point(field_mutable:aip.processor.v2.InferenceResponse.inferences)
  return _internal_mutable_inferences();
}
inline void InferenceResponse::set_allocated_inferences(::aip::processor::v2::Inferences* inferences) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete inferences_;
  }
  if (inferences) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(inferences);
    if (message_arena != submessage_arena) {
      inferences = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, inferences, submessage_arena);
    }
    
  } else {
    
  }
  inferences_ = inferences;
  // @@protoc_insertion_point(field_set_allocated:aip.processor.v2.InferenceResponse.inferences)
}

// -------------------------------------------------------------------

// TrackRequest

// .aip.processor.v2.RequestHeader header = 1;
inline bool TrackRequest::_internal_has_header() const {
  return this != internal_default_instance() && header_ != nullptr;
}
inline bool TrackRequest::has_header() const {
  return _internal_has_header();
}
inline void TrackRequest::clear_header() {
  if (GetArena() == nullptr && header_ != nullptr) {
    delete header_;
  }
  header_ = nullptr;
}
inline const ::aip::processor::v2::RequestHeader& TrackRequest::_internal_header() const {
  const ::aip::processor::v2::RequestHeader* p = header_;
  return p != nullptr ? *p : *reinterpret_cast<const ::aip::processor::v2::RequestHeader*>(
      &::aip::processor::v2::_RequestHeader_default_instance_);
}
inline const ::aip::processor::v2::RequestHeader& TrackRequest::header() const {
  // @@protoc_insertion_point(field_get:aip.processor.v2.TrackRequest.header)
  return _internal_header();
}
inline void TrackRequest::unsafe_arena_set_allocated_header(
    ::aip::processor::v2::RequestHeader* header) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header_);
  }
  header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:aip.processor.v2.TrackRequest.header)
}
inline ::aip::processor::v2::RequestHeader* TrackRequest::release_header() {
  
  ::aip::processor::v2::RequestHeader* temp = header_;
  header_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::aip::processor::v2::RequestHeader* TrackRequest::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:aip.processor.v2.TrackRequest.header)
  
  ::aip::processor::v2::RequestHeader* temp = header_;
  header_ = nullptr;
  return temp;
}
inline ::aip::processor::v2::RequestHeader* TrackRequest::_internal_mutable_header() {
  
  if (header_ == nullptr) {
    auto* p = CreateMaybeMessage<::aip::processor::v2::RequestHeader>(GetArena());
    header_ = p;
  }
  return header_;
}
inline ::aip::processor::v2::RequestHeader* TrackRequest::mutable_header() {
  // @@protoc_insertion_point(field_mutable:aip.processor.v2.TrackRequest.header)
  return _internal_mutable_header();
}
inline void TrackRequest::set_allocated_header(::aip::processor::v2::RequestHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete header_;
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(header);
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:aip.processor.v2.TrackRequest.header)
}

// .aip.processor.v2.Frame frame = 2;
inline bool TrackRequest::_internal_has_frame() const {
  return this != internal_default_instance() && frame_ != nullptr;
}
inline bool TrackRequest::has_frame() const {
  return _internal_has_frame();
}
inline void TrackRequest::clear_frame() {
  if (GetArena() == nullptr && frame_ != nullptr) {
    delete frame_;
  }
  frame_ = nullptr;
}
inline const ::aip::processor::v2::Frame& TrackRequest::_internal_frame() const {
  const ::aip::processor::v2::Frame* p = frame_;
  return p != nullptr ? *p : *reinterpret_cast<const ::aip::processor::v2::Frame*>(
      &::aip::processor::v2::_Frame_default_instance_);
}
inline const ::aip::processor::v2::Frame& TrackRequest::frame() const {
  // @@protoc_insertion_point(field_get:aip.processor.v2.TrackRequest.frame)
  return _internal_frame();
}
inline void TrackRequest::unsafe_arena_set_allocated_frame(
    ::aip::processor::v2::Frame* frame) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(frame_);
  }
  frame_ = frame;
  if (frame) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:aip.processor.v2.TrackRequest.frame)
}
inline ::aip::processor::v2::Frame* TrackRequest::release_frame() {
  
  ::aip::processor::v2::Frame* temp = frame_;
  frame_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::aip::processor::v2::Frame* TrackRequest::unsafe_arena_release_frame() {
  // @@protoc_insertion_point(field_release:aip.processor.v2.TrackRequest.frame)
  
  ::aip::processor::v2::Frame* temp = frame_;
  frame_ = nullptr;
  return temp;
}
inline ::aip::processor::v2::Frame* TrackRequest::_internal_mutable_frame() {
  
  if (frame_ == nullptr) {
    auto* p = CreateMaybeMessage<::aip::processor::v2::Frame>(GetArena());
    frame_ = p;
  }
  return frame_;
}
inline ::aip::processor::v2::Frame* TrackRequest::mutable_frame() {
  // @@protoc_insertion_point(field_mutable:aip.processor.v2.TrackRequest.frame)
  return _internal_mutable_frame();
}
inline void TrackRequest::set_allocated_frame(::aip::processor::v2::Frame* frame) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete frame_;
  }
  if (frame) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(frame);
    if (message_arena != submessage_arena) {
      frame = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, frame, submessage_arena);
    }
    
  } else {
    
  }
  frame_ = frame;
  // @@protoc_insertion_point(field_set_allocated:aip.processor.v2.TrackRequest.frame)
}

// .aip.processor.v2.Inferences inferences = 3;
inline bool TrackRequest::_internal_has_inferences() const {
  return maybe_inferences_case() == kInferences;
}
inline bool TrackRequest::has_inferences() const {
  return _internal_has_inferences();
}
inline void TrackRequest::set_has_inferences() {
  _oneof_case_[0] = kInferences;
}
inline void TrackRequest::clear_inferences() {
  if (_internal_has_inferences()) {
    if (GetArena() == nullptr) {
      delete maybe_inferences_.inferences_;
    }
    clear_has_maybe_inferences();
  }
}
inline ::aip::processor::v2::Inferences* TrackRequest::release_inferences() {
  // @@protoc_insertion_point(field_release:aip.processor.v2.TrackRequest.inferences)
  if (_internal_has_inferences()) {
    clear_has_maybe_inferences();
      ::aip::processor::v2::Inferences* temp = maybe_inferences_.inferences_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    maybe_inferences_.inferences_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::aip::processor::v2::Inferences& TrackRequest::_internal_inferences() const {
  return _internal_has_inferences()
      ? *maybe_inferences_.inferences_
      : *reinterpret_cast< ::aip::processor::v2::Inferences*>(&::aip::processor::v2::_Inferences_default_instance_);
}
inline const ::aip::processor::v2::Inferences& TrackRequest::inferences() const {
  // @@protoc_insertion_point(field_get:aip.processor.v2.TrackRequest.inferences)
  return _internal_inferences();
}
inline ::aip::processor::v2::Inferences* TrackRequest::unsafe_arena_release_inferences() {
  // @@protoc_insertion_point(field_unsafe_arena_release:aip.processor.v2.TrackRequest.inferences)
  if (_internal_has_inferences()) {
    clear_has_maybe_inferences();
    ::aip::processor::v2::Inferences* temp = maybe_inferences_.inferences_;
    maybe_inferences_.inferences_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void TrackRequest::unsafe_arena_set_allocated_inferences(::aip::processor::v2::Inferences* inferences) {
  clear_maybe_inferences();
  if (inferences) {
    set_has_inferences();
    maybe_inferences_.inferences_ = inferences;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:aip.processor.v2.TrackRequest.inferences)
}
inline ::aip::processor::v2::Inferences* TrackRequest::_internal_mutable_inferences() {
  if (!_internal_has_inferences()) {
    clear_maybe_inferences();
    set_has_inferences();
    maybe_inferences_.inferences_ = CreateMaybeMessage< ::aip::processor::v2::Inferences >(GetArena());
  }
  return maybe_inferences_.inferences_;
}
inline ::aip::processor::v2::Inferences* TrackRequest::mutable_inferences() {
  // @@protoc_insertion_point(field_mutable:aip.processor.v2.TrackRequest.inferences)
  return _internal_mutable_inferences();
}

// .aip.processor.v2.GeoRegistration geo_registration = 4;
inline bool TrackRequest::_internal_has_geo_registration() const {
  return maybe_geo_registration_case() == kGeoRegistration;
}
inline bool TrackRequest::has_geo_registration() const {
  return _internal_has_geo_registration();
}
inline void TrackRequest::set_has_geo_registration() {
  _oneof_case_[1] = kGeoRegistration;
}
inline void TrackRequest::clear_geo_registration() {
  if (_internal_has_geo_registration()) {
    if (GetArena() == nullptr) {
      delete maybe_geo_registration_.geo_registration_;
    }
    clear_has_maybe_geo_registration();
  }
}
inline ::aip::processor::v2::GeoRegistration* TrackRequest::release_geo_registration() {
  // @@protoc_insertion_point(field_release:aip.processor.v2.TrackRequest.geo_registration)
  if (_internal_has_geo_registration()) {
    clear_has_maybe_geo_registration();
      ::aip::processor::v2::GeoRegistration* temp = maybe_geo_registration_.geo_registration_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    maybe_geo_registration_.geo_registration_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::aip::processor::v2::GeoRegistration& TrackRequest::_internal_geo_registration() const {
  return _internal_has_geo_registration()
      ? *maybe_geo_registration_.geo_registration_
      : *reinterpret_cast< ::aip::processor::v2::GeoRegistration*>(&::aip::processor::v2::_GeoRegistration_default_instance_);
}
inline const ::aip::processor::v2::GeoRegistration& TrackRequest::geo_registration() const {
  // @@protoc_insertion_point(field_get:aip.processor.v2.TrackRequest.geo_registration)
  return _internal_geo_registration();
}
inline ::aip::processor::v2::GeoRegistration* TrackRequest::unsafe_arena_release_geo_registration() {
  // @@protoc_insertion_point(field_unsafe_arena_release:aip.processor.v2.TrackRequest.geo_registration)
  if (_internal_has_geo_registration()) {
    clear_has_maybe_geo_registration();
    ::aip::processor::v2::GeoRegistration* temp = maybe_geo_registration_.geo_registration_;
    maybe_geo_registration_.geo_registration_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void TrackRequest::unsafe_arena_set_allocated_geo_registration(::aip::processor::v2::GeoRegistration* geo_registration) {
  clear_maybe_geo_registration();
  if (geo_registration) {
    set_has_geo_registration();
    maybe_geo_registration_.geo_registration_ = geo_registration;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:aip.processor.v2.TrackRequest.geo_registration)
}
inline ::aip::processor::v2::GeoRegistration* TrackRequest::_internal_mutable_geo_registration() {
  if (!_internal_has_geo_registration()) {
    clear_maybe_geo_registration();
    set_has_geo_registration();
    maybe_geo_registration_.geo_registration_ = CreateMaybeMessage< ::aip::processor::v2::GeoRegistration >(GetArena());
  }
  return maybe_geo_registration_.geo_registration_;
}
inline ::aip::processor::v2::GeoRegistration* TrackRequest::mutable_geo_registration() {
  // @@protoc_insertion_point(field_mutable:aip.processor.v2.TrackRequest.geo_registration)
  return _internal_mutable_geo_registration();
}

inline bool TrackRequest::has_maybe_inferences() const {
  return maybe_inferences_case() != MAYBE_INFERENCES_NOT_SET;
}
inline void TrackRequest::clear_has_maybe_inferences() {
  _oneof_case_[0] = MAYBE_INFERENCES_NOT_SET;
}
inline bool TrackRequest::has_maybe_geo_registration() const {
  return maybe_geo_registration_case() != MAYBE_GEO_REGISTRATION_NOT_SET;
}
inline void TrackRequest::clear_has_maybe_geo_registration() {
  _oneof_case_[1] = MAYBE_GEO_REGISTRATION_NOT_SET;
}
inline TrackRequest::MaybeInferencesCase TrackRequest::maybe_inferences_case() const {
  return TrackRequest::MaybeInferencesCase(_oneof_case_[0]);
}
inline TrackRequest::MaybeGeoRegistrationCase TrackRequest::maybe_geo_registration_case() const {
  return TrackRequest::MaybeGeoRegistrationCase(_oneof_case_[1]);
}
// -------------------------------------------------------------------

// GeoRegistration

// .aip.processor.v2.Lattice lattice = 1;
inline bool GeoRegistration::_internal_has_lattice() const {
  return this != internal_default_instance() && lattice_ != nullptr;
}
inline bool GeoRegistration::has_lattice() const {
  return _internal_has_lattice();
}
inline void GeoRegistration::clear_lattice() {
  if (GetArena() == nullptr && lattice_ != nullptr) {
    delete lattice_;
  }
  lattice_ = nullptr;
}
inline const ::aip::processor::v2::Lattice& GeoRegistration::_internal_lattice() const {
  const ::aip::processor::v2::Lattice* p = lattice_;
  return p != nullptr ? *p : *reinterpret_cast<const ::aip::processor::v2::Lattice*>(
      &::aip::processor::v2::_Lattice_default_instance_);
}
inline const ::aip::processor::v2::Lattice& GeoRegistration::lattice() const {
  // @@protoc_insertion_point(field_get:aip.processor.v2.GeoRegistration.lattice)
  return _internal_lattice();
}
inline void GeoRegistration::unsafe_arena_set_allocated_lattice(
    ::aip::processor::v2::Lattice* lattice) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(lattice_);
  }
  lattice_ = lattice;
  if (lattice) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:aip.processor.v2.GeoRegistration.lattice)
}
inline ::aip::processor::v2::Lattice* GeoRegistration::release_lattice() {
  
  ::aip::processor::v2::Lattice* temp = lattice_;
  lattice_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::aip::processor::v2::Lattice* GeoRegistration::unsafe_arena_release_lattice() {
  // @@protoc_insertion_point(field_release:aip.processor.v2.GeoRegistration.lattice)
  
  ::aip::processor::v2::Lattice* temp = lattice_;
  lattice_ = nullptr;
  return temp;
}
inline ::aip::processor::v2::Lattice* GeoRegistration::_internal_mutable_lattice() {
  
  if (lattice_ == nullptr) {
    auto* p = CreateMaybeMessage<::aip::processor::v2::Lattice>(GetArena());
    lattice_ = p;
  }
  return lattice_;
}
inline ::aip::processor::v2::Lattice* GeoRegistration::mutable_lattice() {
  // @@protoc_insertion_point(field_mutable:aip.processor.v2.GeoRegistration.lattice)
  return _internal_mutable_lattice();
}
inline void GeoRegistration::set_allocated_lattice(::aip::processor::v2::Lattice* lattice) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete lattice_;
  }
  if (lattice) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(lattice);
    if (message_arena != submessage_arena) {
      lattice = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, lattice, submessage_arena);
    }
    
  } else {
    
  }
  lattice_ = lattice;
  // @@protoc_insertion_point(field_set_allocated:aip.processor.v2.GeoRegistration.lattice)
}

// double confidence = 2;
inline void GeoRegistration::clear_confidence() {
  confidence_ = 0;
}
inline double GeoRegistration::_internal_confidence() const {
  return confidence_;
}
inline double GeoRegistration::confidence() const {
  // @@protoc_insertion_point(field_get:aip.processor.v2.GeoRegistration.confidence)
  return _internal_confidence();
}
inline void GeoRegistration::_internal_set_confidence(double value) {
  
  confidence_ = value;
}
inline void GeoRegistration::set_confidence(double value) {
  _internal_set_confidence(value);
  // @@protoc_insertion_point(field_set:aip.processor.v2.GeoRegistration.confidence)
}

// .aip.processor.v2.UasMetadata updatedMetadata = 3;
inline bool GeoRegistration::_internal_has_updatedmetadata() const {
  return this != internal_default_instance() && updatedmetadata_ != nullptr;
}
inline bool GeoRegistration::has_updatedmetadata() const {
  return _internal_has_updatedmetadata();
}
inline void GeoRegistration::clear_updatedmetadata() {
  if (GetArena() == nullptr && updatedmetadata_ != nullptr) {
    delete updatedmetadata_;
  }
  updatedmetadata_ = nullptr;
}
inline const ::aip::processor::v2::UasMetadata& GeoRegistration::_internal_updatedmetadata() const {
  const ::aip::processor::v2::UasMetadata* p = updatedmetadata_;
  return p != nullptr ? *p : *reinterpret_cast<const ::aip::processor::v2::UasMetadata*>(
      &::aip::processor::v2::_UasMetadata_default_instance_);
}
inline const ::aip::processor::v2::UasMetadata& GeoRegistration::updatedmetadata() const {
  // @@protoc_insertion_point(field_get:aip.processor.v2.GeoRegistration.updatedMetadata)
  return _internal_updatedmetadata();
}
inline void GeoRegistration::unsafe_arena_set_allocated_updatedmetadata(
    ::aip::processor::v2::UasMetadata* updatedmetadata) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(updatedmetadata_);
  }
  updatedmetadata_ = updatedmetadata;
  if (updatedmetadata) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:aip.processor.v2.GeoRegistration.updatedMetadata)
}
inline ::aip::processor::v2::UasMetadata* GeoRegistration::release_updatedmetadata() {
  
  ::aip::processor::v2::UasMetadata* temp = updatedmetadata_;
  updatedmetadata_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::aip::processor::v2::UasMetadata* GeoRegistration::unsafe_arena_release_updatedmetadata() {
  // @@protoc_insertion_point(field_release:aip.processor.v2.GeoRegistration.updatedMetadata)
  
  ::aip::processor::v2::UasMetadata* temp = updatedmetadata_;
  updatedmetadata_ = nullptr;
  return temp;
}
inline ::aip::processor::v2::UasMetadata* GeoRegistration::_internal_mutable_updatedmetadata() {
  
  if (updatedmetadata_ == nullptr) {
    auto* p = CreateMaybeMessage<::aip::processor::v2::UasMetadata>(GetArena());
    updatedmetadata_ = p;
  }
  return updatedmetadata_;
}
inline ::aip::processor::v2::UasMetadata* GeoRegistration::mutable_updatedmetadata() {
  // @@protoc_insertion_point(field_mutable:aip.processor.v2.GeoRegistration.updatedMetadata)
  return _internal_mutable_updatedmetadata();
}
inline void GeoRegistration::set_allocated_updatedmetadata(::aip::processor::v2::UasMetadata* updatedmetadata) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete updatedmetadata_;
  }
  if (updatedmetadata) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(updatedmetadata);
    if (message_arena != submessage_arena) {
      updatedmetadata = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, updatedmetadata, submessage_arena);
    }
    
  } else {
    
  }
  updatedmetadata_ = updatedmetadata;
  // @@protoc_insertion_point(field_set_allocated:aip.processor.v2.GeoRegistration.updatedMetadata)
}

// -------------------------------------------------------------------

// Inferences

// repeated .aip.processor.v2.Inference inference = 1;
inline int Inferences::_internal_inference_size() const {
  return inference_.size();
}
inline int Inferences::inference_size() const {
  return _internal_inference_size();
}
inline void Inferences::clear_inference() {
  inference_.Clear();
}
inline ::aip::processor::v2::Inference* Inferences::mutable_inference(int index) {
  // @@protoc_insertion_point(field_mutable:aip.processor.v2.Inferences.inference)
  return inference_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::aip::processor::v2::Inference >*
Inferences::mutable_inference() {
  // @@protoc_insertion_point(field_mutable_list:aip.processor.v2.Inferences.inference)
  return &inference_;
}
inline const ::aip::processor::v2::Inference& Inferences::_internal_inference(int index) const {
  return inference_.Get(index);
}
inline const ::aip::processor::v2::Inference& Inferences::inference(int index) const {
  // @@protoc_insertion_point(field_get:aip.processor.v2.Inferences.inference)
  return _internal_inference(index);
}
inline ::aip::processor::v2::Inference* Inferences::_internal_add_inference() {
  return inference_.Add();
}
inline ::aip::processor::v2::Inference* Inferences::add_inference() {
  // @@protoc_insertion_point(field_add:aip.processor.v2.Inferences.inference)
  return _internal_add_inference();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::aip::processor::v2::Inference >&
Inferences::inference() const {
  // @@protoc_insertion_point(field_list:aip.processor.v2.Inferences.inference)
  return inference_;
}

// -------------------------------------------------------------------

// Inference

// string inferenceId = 1;
inline void Inference::clear_inferenceid() {
  inferenceid_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& Inference::inferenceid() const {
  // @@protoc_insertion_point(field_get:aip.processor.v2.Inference.inferenceId)
  return _internal_inferenceid();
}
inline void Inference::set_inferenceid(const std::string& value) {
  _internal_set_inferenceid(value);
  // @@protoc_insertion_point(field_set:aip.processor.v2.Inference.inferenceId)
}
inline std::string* Inference::mutable_inferenceid() {
  // @@protoc_insertion_point(field_mutable:aip.processor.v2.Inference.inferenceId)
  return _internal_mutable_inferenceid();
}
inline const std::string& Inference::_internal_inferenceid() const {
  return inferenceid_.Get();
}
inline void Inference::_internal_set_inferenceid(const std::string& value) {
  
  inferenceid_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void Inference::set_inferenceid(std::string&& value) {
  
  inferenceid_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:aip.processor.v2.Inference.inferenceId)
}
inline void Inference::set_inferenceid(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  inferenceid_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:aip.processor.v2.Inference.inferenceId)
}
inline void Inference::set_inferenceid(const char* value,
    size_t size) {
  
  inferenceid_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:aip.processor.v2.Inference.inferenceId)
}
inline std::string* Inference::_internal_mutable_inferenceid() {
  
  return inferenceid_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* Inference::release_inferenceid() {
  // @@protoc_insertion_point(field_release:aip.processor.v2.Inference.inferenceId)
  return inferenceid_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void Inference::set_allocated_inferenceid(std::string* inferenceid) {
  if (inferenceid != nullptr) {
    
  } else {
    
  }
  inferenceid_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), inferenceid,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:aip.processor.v2.Inference.inferenceId)
}

// .aip.processor.v2.BoundingBox box = 2;
inline bool Inference::_internal_has_box() const {
  return inference_case() == kBox;
}
inline bool Inference::has_box() const {
  return _internal_has_box();
}
inline void Inference::set_has_box() {
  _oneof_case_[0] = kBox;
}
inline void Inference::clear_box() {
  if (_internal_has_box()) {
    if (GetArena() == nullptr) {
      delete inference_.box_;
    }
    clear_has_inference();
  }
}
inline ::aip::processor::v2::BoundingBox* Inference::release_box() {
  // @@protoc_insertion_point(field_release:aip.processor.v2.Inference.box)
  if (_internal_has_box()) {
    clear_has_inference();
      ::aip::processor::v2::BoundingBox* temp = inference_.box_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    inference_.box_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::aip::processor::v2::BoundingBox& Inference::_internal_box() const {
  return _internal_has_box()
      ? *inference_.box_
      : *reinterpret_cast< ::aip::processor::v2::BoundingBox*>(&::aip::processor::v2::_BoundingBox_default_instance_);
}
inline const ::aip::processor::v2::BoundingBox& Inference::box() const {
  // @@protoc_insertion_point(field_get:aip.processor.v2.Inference.box)
  return _internal_box();
}
inline ::aip::processor::v2::BoundingBox* Inference::unsafe_arena_release_box() {
  // @@protoc_insertion_point(field_unsafe_arena_release:aip.processor.v2.Inference.box)
  if (_internal_has_box()) {
    clear_has_inference();
    ::aip::processor::v2::BoundingBox* temp = inference_.box_;
    inference_.box_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Inference::unsafe_arena_set_allocated_box(::aip::processor::v2::BoundingBox* box) {
  clear_inference();
  if (box) {
    set_has_box();
    inference_.box_ = box;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:aip.processor.v2.Inference.box)
}
inline ::aip::processor::v2::BoundingBox* Inference::_internal_mutable_box() {
  if (!_internal_has_box()) {
    clear_inference();
    set_has_box();
    inference_.box_ = CreateMaybeMessage< ::aip::processor::v2::BoundingBox >(GetArena());
  }
  return inference_.box_;
}
inline ::aip::processor::v2::BoundingBox* Inference::mutable_box() {
  // @@protoc_insertion_point(field_mutable:aip.processor.v2.Inference.box)
  return _internal_mutable_box();
}

// .aip.processor.v2.BoundingPolygon polygon = 3;
inline bool Inference::_internal_has_polygon() const {
  return inference_case() == kPolygon;
}
inline bool Inference::has_polygon() const {
  return _internal_has_polygon();
}
inline void Inference::set_has_polygon() {
  _oneof_case_[0] = kPolygon;
}
inline void Inference::clear_polygon() {
  if (_internal_has_polygon()) {
    if (GetArena() == nullptr) {
      delete inference_.polygon_;
    }
    clear_has_inference();
  }
}
inline ::aip::processor::v2::BoundingPolygon* Inference::release_polygon() {
  // @@protoc_insertion_point(field_release:aip.processor.v2.Inference.polygon)
  if (_internal_has_polygon()) {
    clear_has_inference();
      ::aip::processor::v2::BoundingPolygon* temp = inference_.polygon_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    inference_.polygon_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::aip::processor::v2::BoundingPolygon& Inference::_internal_polygon() const {
  return _internal_has_polygon()
      ? *inference_.polygon_
      : *reinterpret_cast< ::aip::processor::v2::BoundingPolygon*>(&::aip::processor::v2::_BoundingPolygon_default_instance_);
}
inline const ::aip::processor::v2::BoundingPolygon& Inference::polygon() const {
  // @@protoc_insertion_point(field_get:aip.processor.v2.Inference.polygon)
  return _internal_polygon();
}
inline ::aip::processor::v2::BoundingPolygon* Inference::unsafe_arena_release_polygon() {
  // @@protoc_insertion_point(field_unsafe_arena_release:aip.processor.v2.Inference.polygon)
  if (_internal_has_polygon()) {
    clear_has_inference();
    ::aip::processor::v2::BoundingPolygon* temp = inference_.polygon_;
    inference_.polygon_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Inference::unsafe_arena_set_allocated_polygon(::aip::processor::v2::BoundingPolygon* polygon) {
  clear_inference();
  if (polygon) {
    set_has_polygon();
    inference_.polygon_ = polygon;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:aip.processor.v2.Inference.polygon)
}
inline ::aip::processor::v2::BoundingPolygon* Inference::_internal_mutable_polygon() {
  if (!_internal_has_polygon()) {
    clear_inference();
    set_has_polygon();
    inference_.polygon_ = CreateMaybeMessage< ::aip::processor::v2::BoundingPolygon >(GetArena());
  }
  return inference_.polygon_;
}
inline ::aip::processor::v2::BoundingPolygon* Inference::mutable_polygon() {
  // @@protoc_insertion_point(field_mutable:aip.processor.v2.Inference.polygon)
  return _internal_mutable_polygon();
}

// .aip.processor.v2.GeoBoundingBox geo_box = 5;
inline bool Inference::_internal_has_geo_box() const {
  return inference_case() == kGeoBox;
}
inline bool Inference::has_geo_box() const {
  return _internal_has_geo_box();
}
inline void Inference::set_has_geo_box() {
  _oneof_case_[0] = kGeoBox;
}
inline void Inference::clear_geo_box() {
  if (_internal_has_geo_box()) {
    if (GetArena() == nullptr) {
      delete inference_.geo_box_;
    }
    clear_has_inference();
  }
}
inline ::aip::processor::v2::GeoBoundingBox* Inference::release_geo_box() {
  // @@protoc_insertion_point(field_release:aip.processor.v2.Inference.geo_box)
  if (_internal_has_geo_box()) {
    clear_has_inference();
      ::aip::processor::v2::GeoBoundingBox* temp = inference_.geo_box_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    inference_.geo_box_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::aip::processor::v2::GeoBoundingBox& Inference::_internal_geo_box() const {
  return _internal_has_geo_box()
      ? *inference_.geo_box_
      : *reinterpret_cast< ::aip::processor::v2::GeoBoundingBox*>(&::aip::processor::v2::_GeoBoundingBox_default_instance_);
}
inline const ::aip::processor::v2::GeoBoundingBox& Inference::geo_box() const {
  // @@protoc_insertion_point(field_get:aip.processor.v2.Inference.geo_box)
  return _internal_geo_box();
}
inline ::aip::processor::v2::GeoBoundingBox* Inference::unsafe_arena_release_geo_box() {
  // @@protoc_insertion_point(field_unsafe_arena_release:aip.processor.v2.Inference.geo_box)
  if (_internal_has_geo_box()) {
    clear_has_inference();
    ::aip::processor::v2::GeoBoundingBox* temp = inference_.geo_box_;
    inference_.geo_box_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Inference::unsafe_arena_set_allocated_geo_box(::aip::processor::v2::GeoBoundingBox* geo_box) {
  clear_inference();
  if (geo_box) {
    set_has_geo_box();
    inference_.geo_box_ = geo_box;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:aip.processor.v2.Inference.geo_box)
}
inline ::aip::processor::v2::GeoBoundingBox* Inference::_internal_mutable_geo_box() {
  if (!_internal_has_geo_box()) {
    clear_inference();
    set_has_geo_box();
    inference_.geo_box_ = CreateMaybeMessage< ::aip::processor::v2::GeoBoundingBox >(GetArena());
  }
  return inference_.geo_box_;
}
inline ::aip::processor::v2::GeoBoundingBox* Inference::mutable_geo_box() {
  // @@protoc_insertion_point(field_mutable:aip.processor.v2.Inference.geo_box)
  return _internal_mutable_geo_box();
}

// .aip.processor.v2.GeoBoundingPolygon geo_polygon = 6;
inline bool Inference::_internal_has_geo_polygon() const {
  return inference_case() == kGeoPolygon;
}
inline bool Inference::has_geo_polygon() const {
  return _internal_has_geo_polygon();
}
inline void Inference::set_has_geo_polygon() {
  _oneof_case_[0] = kGeoPolygon;
}
inline void Inference::clear_geo_polygon() {
  if (_internal_has_geo_polygon()) {
    if (GetArena() == nullptr) {
      delete inference_.geo_polygon_;
    }
    clear_has_inference();
  }
}
inline ::aip::processor::v2::GeoBoundingPolygon* Inference::release_geo_polygon() {
  // @@protoc_insertion_point(field_release:aip.processor.v2.Inference.geo_polygon)
  if (_internal_has_geo_polygon()) {
    clear_has_inference();
      ::aip::processor::v2::GeoBoundingPolygon* temp = inference_.geo_polygon_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    inference_.geo_polygon_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::aip::processor::v2::GeoBoundingPolygon& Inference::_internal_geo_polygon() const {
  return _internal_has_geo_polygon()
      ? *inference_.geo_polygon_
      : *reinterpret_cast< ::aip::processor::v2::GeoBoundingPolygon*>(&::aip::processor::v2::_GeoBoundingPolygon_default_instance_);
}
inline const ::aip::processor::v2::GeoBoundingPolygon& Inference::geo_polygon() const {
  // @@protoc_insertion_point(field_get:aip.processor.v2.Inference.geo_polygon)
  return _internal_geo_polygon();
}
inline ::aip::processor::v2::GeoBoundingPolygon* Inference::unsafe_arena_release_geo_polygon() {
  // @@protoc_insertion_point(field_unsafe_arena_release:aip.processor.v2.Inference.geo_polygon)
  if (_internal_has_geo_polygon()) {
    clear_has_inference();
    ::aip::processor::v2::GeoBoundingPolygon* temp = inference_.geo_polygon_;
    inference_.geo_polygon_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Inference::unsafe_arena_set_allocated_geo_polygon(::aip::processor::v2::GeoBoundingPolygon* geo_polygon) {
  clear_inference();
  if (geo_polygon) {
    set_has_geo_polygon();
    inference_.geo_polygon_ = geo_polygon;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:aip.processor.v2.Inference.geo_polygon)
}
inline ::aip::processor::v2::GeoBoundingPolygon* Inference::_internal_mutable_geo_polygon() {
  if (!_internal_has_geo_polygon()) {
    clear_inference();
    set_has_geo_polygon();
    inference_.geo_polygon_ = CreateMaybeMessage< ::aip::processor::v2::GeoBoundingPolygon >(GetArena());
  }
  return inference_.geo_polygon_;
}
inline ::aip::processor::v2::GeoBoundingPolygon* Inference::mutable_geo_polygon() {
  // @@protoc_insertion_point(field_mutable:aip.processor.v2.Inference.geo_polygon)
  return _internal_mutable_geo_polygon();
}

// .aip.processor.v2.Velocity velocity = 4;
inline bool Inference::_internal_has_velocity() const {
  return this != internal_default_instance() && velocity_ != nullptr;
}
inline bool Inference::has_velocity() const {
  return _internal_has_velocity();
}
inline void Inference::clear_velocity() {
  if (GetArena() == nullptr && velocity_ != nullptr) {
    delete velocity_;
  }
  velocity_ = nullptr;
}
inline const ::aip::processor::v2::Velocity& Inference::_internal_velocity() const {
  const ::aip::processor::v2::Velocity* p = velocity_;
  return p != nullptr ? *p : *reinterpret_cast<const ::aip::processor::v2::Velocity*>(
      &::aip::processor::v2::_Velocity_default_instance_);
}
inline const ::aip::processor::v2::Velocity& Inference::velocity() const {
  // @@protoc_insertion_point(field_get:aip.processor.v2.Inference.velocity)
  return _internal_velocity();
}
inline void Inference::unsafe_arena_set_allocated_velocity(
    ::aip::processor::v2::Velocity* velocity) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(velocity_);
  }
  velocity_ = velocity;
  if (velocity) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:aip.processor.v2.Inference.velocity)
}
inline ::aip::processor::v2::Velocity* Inference::release_velocity() {
  
  ::aip::processor::v2::Velocity* temp = velocity_;
  velocity_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::aip::processor::v2::Velocity* Inference::unsafe_arena_release_velocity() {
  // @@protoc_insertion_point(field_release:aip.processor.v2.Inference.velocity)
  
  ::aip::processor::v2::Velocity* temp = velocity_;
  velocity_ = nullptr;
  return temp;
}
inline ::aip::processor::v2::Velocity* Inference::_internal_mutable_velocity() {
  
  if (velocity_ == nullptr) {
    auto* p = CreateMaybeMessage<::aip::processor::v2::Velocity>(GetArena());
    velocity_ = p;
  }
  return velocity_;
}
inline ::aip::processor::v2::Velocity* Inference::mutable_velocity() {
  // @@protoc_insertion_point(field_mutable:aip.processor.v2.Inference.velocity)
  return _internal_mutable_velocity();
}
inline void Inference::set_allocated_velocity(::aip::processor::v2::Velocity* velocity) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete velocity_;
  }
  if (velocity) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(velocity);
    if (message_arena != submessage_arena) {
      velocity = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, velocity, submessage_arena);
    }
    
  } else {
    
  }
  velocity_ = velocity;
  // @@protoc_insertion_point(field_set_allocated:aip.processor.v2.Inference.velocity)
}

inline bool Inference::has_inference() const {
  return inference_case() != INFERENCE_NOT_SET;
}
inline void Inference::clear_has_inference() {
  _oneof_case_[0] = INFERENCE_NOT_SET;
}
inline Inference::InferenceCase Inference::inference_case() const {
  return Inference::InferenceCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// GeoCoordinate

// double latitude = 1;
inline void GeoCoordinate::clear_latitude() {
  latitude_ = 0;
}
inline double GeoCoordinate::_internal_latitude() const {
  return latitude_;
}
inline double GeoCoordinate::latitude() const {
  // @@protoc_insertion_point(field_get:aip.processor.v2.GeoCoordinate.latitude)
  return _internal_latitude();
}
inline void GeoCoordinate::_internal_set_latitude(double value) {
  
  latitude_ = value;
}
inline void GeoCoordinate::set_latitude(double value) {
  _internal_set_latitude(value);
  // @@protoc_insertion_point(field_set:aip.processor.v2.GeoCoordinate.latitude)
}

// double longitude = 2;
inline void GeoCoordinate::clear_longitude() {
  longitude_ = 0;
}
inline double GeoCoordinate::_internal_longitude() const {
  return longitude_;
}
inline double GeoCoordinate::longitude() const {
  // @@protoc_insertion_point(field_get:aip.processor.v2.GeoCoordinate.longitude)
  return _internal_longitude();
}
inline void GeoCoordinate::_internal_set_longitude(double value) {
  
  longitude_ = value;
}
inline void GeoCoordinate::set_longitude(double value) {
  _internal_set_longitude(value);
  // @@protoc_insertion_point(field_set:aip.processor.v2.GeoCoordinate.longitude)
}

// -------------------------------------------------------------------

// BoundingBox

// .aip.processor.v2.UnitCoordinate c0 = 1;
inline bool BoundingBox::_internal_has_c0() const {
  return this != internal_default_instance() && c0_ != nullptr;
}
inline bool BoundingBox::has_c0() const {
  return _internal_has_c0();
}
inline void BoundingBox::clear_c0() {
  if (GetArena() == nullptr && c0_ != nullptr) {
    delete c0_;
  }
  c0_ = nullptr;
}
inline const ::aip::processor::v2::UnitCoordinate& BoundingBox::_internal_c0() const {
  const ::aip::processor::v2::UnitCoordinate* p = c0_;
  return p != nullptr ? *p : *reinterpret_cast<const ::aip::processor::v2::UnitCoordinate*>(
      &::aip::processor::v2::_UnitCoordinate_default_instance_);
}
inline const ::aip::processor::v2::UnitCoordinate& BoundingBox::c0() const {
  // @@protoc_insertion_point(field_get:aip.processor.v2.BoundingBox.c0)
  return _internal_c0();
}
inline void BoundingBox::unsafe_arena_set_allocated_c0(
    ::aip::processor::v2::UnitCoordinate* c0) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(c0_);
  }
  c0_ = c0;
  if (c0) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:aip.processor.v2.BoundingBox.c0)
}
inline ::aip::processor::v2::UnitCoordinate* BoundingBox::release_c0() {
  
  ::aip::processor::v2::UnitCoordinate* temp = c0_;
  c0_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::aip::processor::v2::UnitCoordinate* BoundingBox::unsafe_arena_release_c0() {
  // @@protoc_insertion_point(field_release:aip.processor.v2.BoundingBox.c0)
  
  ::aip::processor::v2::UnitCoordinate* temp = c0_;
  c0_ = nullptr;
  return temp;
}
inline ::aip::processor::v2::UnitCoordinate* BoundingBox::_internal_mutable_c0() {
  
  if (c0_ == nullptr) {
    auto* p = CreateMaybeMessage<::aip::processor::v2::UnitCoordinate>(GetArena());
    c0_ = p;
  }
  return c0_;
}
inline ::aip::processor::v2::UnitCoordinate* BoundingBox::mutable_c0() {
  // @@protoc_insertion_point(field_mutable:aip.processor.v2.BoundingBox.c0)
  return _internal_mutable_c0();
}
inline void BoundingBox::set_allocated_c0(::aip::processor::v2::UnitCoordinate* c0) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete c0_;
  }
  if (c0) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(c0);
    if (message_arena != submessage_arena) {
      c0 = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, c0, submessage_arena);
    }
    
  } else {
    
  }
  c0_ = c0;
  // @@protoc_insertion_point(field_set_allocated:aip.processor.v2.BoundingBox.c0)
}

// .aip.processor.v2.UnitCoordinate c1 = 2;
inline bool BoundingBox::_internal_has_c1() const {
  return this != internal_default_instance() && c1_ != nullptr;
}
inline bool BoundingBox::has_c1() const {
  return _internal_has_c1();
}
inline void BoundingBox::clear_c1() {
  if (GetArena() == nullptr && c1_ != nullptr) {
    delete c1_;
  }
  c1_ = nullptr;
}
inline const ::aip::processor::v2::UnitCoordinate& BoundingBox::_internal_c1() const {
  const ::aip::processor::v2::UnitCoordinate* p = c1_;
  return p != nullptr ? *p : *reinterpret_cast<const ::aip::processor::v2::UnitCoordinate*>(
      &::aip::processor::v2::_UnitCoordinate_default_instance_);
}
inline const ::aip::processor::v2::UnitCoordinate& BoundingBox::c1() const {
  // @@protoc_insertion_point(field_get:aip.processor.v2.BoundingBox.c1)
  return _internal_c1();
}
inline void BoundingBox::unsafe_arena_set_allocated_c1(
    ::aip::processor::v2::UnitCoordinate* c1) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(c1_);
  }
  c1_ = c1;
  if (c1) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:aip.processor.v2.BoundingBox.c1)
}
inline ::aip::processor::v2::UnitCoordinate* BoundingBox::release_c1() {
  
  ::aip::processor::v2::UnitCoordinate* temp = c1_;
  c1_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::aip::processor::v2::UnitCoordinate* BoundingBox::unsafe_arena_release_c1() {
  // @@protoc_insertion_point(field_release:aip.processor.v2.BoundingBox.c1)
  
  ::aip::processor::v2::UnitCoordinate* temp = c1_;
  c1_ = nullptr;
  return temp;
}
inline ::aip::processor::v2::UnitCoordinate* BoundingBox::_internal_mutable_c1() {
  
  if (c1_ == nullptr) {
    auto* p = CreateMaybeMessage<::aip::processor::v2::UnitCoordinate>(GetArena());
    c1_ = p;
  }
  return c1_;
}
inline ::aip::processor::v2::UnitCoordinate* BoundingBox::mutable_c1() {
  // @@protoc_insertion_point(field_mutable:aip.processor.v2.BoundingBox.c1)
  return _internal_mutable_c1();
}
inline void BoundingBox::set_allocated_c1(::aip::processor::v2::UnitCoordinate* c1) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete c1_;
  }
  if (c1) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(c1);
    if (message_arena != submessage_arena) {
      c1 = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, c1, submessage_arena);
    }
    
  } else {
    
  }
  c1_ = c1;
  // @@protoc_insertion_point(field_set_allocated:aip.processor.v2.BoundingBox.c1)
}

// repeated .aip.processor.v2.Classification classifications = 3;
inline int BoundingBox::_internal_classifications_size() const {
  return classifications_.size();
}
inline int BoundingBox::classifications_size() const {
  return _internal_classifications_size();
}
inline void BoundingBox::clear_classifications() {
  classifications_.Clear();
}
inline ::aip::processor::v2::Classification* BoundingBox::mutable_classifications(int index) {
  // @@protoc_insertion_point(field_mutable:aip.processor.v2.BoundingBox.classifications)
  return classifications_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::aip::processor::v2::Classification >*
BoundingBox::mutable_classifications() {
  // @@protoc_insertion_point(field_mutable_list:aip.processor.v2.BoundingBox.classifications)
  return &classifications_;
}
inline const ::aip::processor::v2::Classification& BoundingBox::_internal_classifications(int index) const {
  return classifications_.Get(index);
}
inline const ::aip::processor::v2::Classification& BoundingBox::classifications(int index) const {
  // @@protoc_insertion_point(field_get:aip.processor.v2.BoundingBox.classifications)
  return _internal_classifications(index);
}
inline ::aip::processor::v2::Classification* BoundingBox::_internal_add_classifications() {
  return classifications_.Add();
}
inline ::aip::processor::v2::Classification* BoundingBox::add_classifications() {
  // @@protoc_insertion_point(field_add:aip.processor.v2.BoundingBox.classifications)
  return _internal_add_classifications();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::aip::processor::v2::Classification >&
BoundingBox::classifications() const {
  // @@protoc_insertion_point(field_list:aip.processor.v2.BoundingBox.classifications)
  return classifications_;
}

// -------------------------------------------------------------------

// GeoBoundingBox

// .aip.processor.v2.GeoCoordinate c0 = 1;
inline bool GeoBoundingBox::_internal_has_c0() const {
  return this != internal_default_instance() && c0_ != nullptr;
}
inline bool GeoBoundingBox::has_c0() const {
  return _internal_has_c0();
}
inline void GeoBoundingBox::clear_c0() {
  if (GetArena() == nullptr && c0_ != nullptr) {
    delete c0_;
  }
  c0_ = nullptr;
}
inline const ::aip::processor::v2::GeoCoordinate& GeoBoundingBox::_internal_c0() const {
  const ::aip::processor::v2::GeoCoordinate* p = c0_;
  return p != nullptr ? *p : *reinterpret_cast<const ::aip::processor::v2::GeoCoordinate*>(
      &::aip::processor::v2::_GeoCoordinate_default_instance_);
}
inline const ::aip::processor::v2::GeoCoordinate& GeoBoundingBox::c0() const {
  // @@protoc_insertion_point(field_get:aip.processor.v2.GeoBoundingBox.c0)
  return _internal_c0();
}
inline void GeoBoundingBox::unsafe_arena_set_allocated_c0(
    ::aip::processor::v2::GeoCoordinate* c0) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(c0_);
  }
  c0_ = c0;
  if (c0) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:aip.processor.v2.GeoBoundingBox.c0)
}
inline ::aip::processor::v2::GeoCoordinate* GeoBoundingBox::release_c0() {
  
  ::aip::processor::v2::GeoCoordinate* temp = c0_;
  c0_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::aip::processor::v2::GeoCoordinate* GeoBoundingBox::unsafe_arena_release_c0() {
  // @@protoc_insertion_point(field_release:aip.processor.v2.GeoBoundingBox.c0)
  
  ::aip::processor::v2::GeoCoordinate* temp = c0_;
  c0_ = nullptr;
  return temp;
}
inline ::aip::processor::v2::GeoCoordinate* GeoBoundingBox::_internal_mutable_c0() {
  
  if (c0_ == nullptr) {
    auto* p = CreateMaybeMessage<::aip::processor::v2::GeoCoordinate>(GetArena());
    c0_ = p;
  }
  return c0_;
}
inline ::aip::processor::v2::GeoCoordinate* GeoBoundingBox::mutable_c0() {
  // @@protoc_insertion_point(field_mutable:aip.processor.v2.GeoBoundingBox.c0)
  return _internal_mutable_c0();
}
inline void GeoBoundingBox::set_allocated_c0(::aip::processor::v2::GeoCoordinate* c0) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete c0_;
  }
  if (c0) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(c0);
    if (message_arena != submessage_arena) {
      c0 = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, c0, submessage_arena);
    }
    
  } else {
    
  }
  c0_ = c0;
  // @@protoc_insertion_point(field_set_allocated:aip.processor.v2.GeoBoundingBox.c0)
}

// .aip.processor.v2.GeoCoordinate c1 = 2;
inline bool GeoBoundingBox::_internal_has_c1() const {
  return this != internal_default_instance() && c1_ != nullptr;
}
inline bool GeoBoundingBox::has_c1() const {
  return _internal_has_c1();
}
inline void GeoBoundingBox::clear_c1() {
  if (GetArena() == nullptr && c1_ != nullptr) {
    delete c1_;
  }
  c1_ = nullptr;
}
inline const ::aip::processor::v2::GeoCoordinate& GeoBoundingBox::_internal_c1() const {
  const ::aip::processor::v2::GeoCoordinate* p = c1_;
  return p != nullptr ? *p : *reinterpret_cast<const ::aip::processor::v2::GeoCoordinate*>(
      &::aip::processor::v2::_GeoCoordinate_default_instance_);
}
inline const ::aip::processor::v2::GeoCoordinate& GeoBoundingBox::c1() const {
  // @@protoc_insertion_point(field_get:aip.processor.v2.GeoBoundingBox.c1)
  return _internal_c1();
}
inline void GeoBoundingBox::unsafe_arena_set_allocated_c1(
    ::aip::processor::v2::GeoCoordinate* c1) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(c1_);
  }
  c1_ = c1;
  if (c1) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:aip.processor.v2.GeoBoundingBox.c1)
}
inline ::aip::processor::v2::GeoCoordinate* GeoBoundingBox::release_c1() {
  
  ::aip::processor::v2::GeoCoordinate* temp = c1_;
  c1_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::aip::processor::v2::GeoCoordinate* GeoBoundingBox::unsafe_arena_release_c1() {
  // @@protoc_insertion_point(field_release:aip.processor.v2.GeoBoundingBox.c1)
  
  ::aip::processor::v2::GeoCoordinate* temp = c1_;
  c1_ = nullptr;
  return temp;
}
inline ::aip::processor::v2::GeoCoordinate* GeoBoundingBox::_internal_mutable_c1() {
  
  if (c1_ == nullptr) {
    auto* p = CreateMaybeMessage<::aip::processor::v2::GeoCoordinate>(GetArena());
    c1_ = p;
  }
  return c1_;
}
inline ::aip::processor::v2::GeoCoordinate* GeoBoundingBox::mutable_c1() {
  // @@protoc_insertion_point(field_mutable:aip.processor.v2.GeoBoundingBox.c1)
  return _internal_mutable_c1();
}
inline void GeoBoundingBox::set_allocated_c1(::aip::processor::v2::GeoCoordinate* c1) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete c1_;
  }
  if (c1) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(c1);
    if (message_arena != submessage_arena) {
      c1 = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, c1, submessage_arena);
    }
    
  } else {
    
  }
  c1_ = c1;
  // @@protoc_insertion_point(field_set_allocated:aip.processor.v2.GeoBoundingBox.c1)
}

// repeated .aip.processor.v2.Classification classifications = 3;
inline int GeoBoundingBox::_internal_classifications_size() const {
  return classifications_.size();
}
inline int GeoBoundingBox::classifications_size() const {
  return _internal_classifications_size();
}
inline void GeoBoundingBox::clear_classifications() {
  classifications_.Clear();
}
inline ::aip::processor::v2::Classification* GeoBoundingBox::mutable_classifications(int index) {
  // @@protoc_insertion_point(field_mutable:aip.processor.v2.GeoBoundingBox.classifications)
  return classifications_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::aip::processor::v2::Classification >*
GeoBoundingBox::mutable_classifications() {
  // @@protoc_insertion_point(field_mutable_list:aip.processor.v2.GeoBoundingBox.classifications)
  return &classifications_;
}
inline const ::aip::processor::v2::Classification& GeoBoundingBox::_internal_classifications(int index) const {
  return classifications_.Get(index);
}
inline const ::aip::processor::v2::Classification& GeoBoundingBox::classifications(int index) const {
  // @@protoc_insertion_point(field_get:aip.processor.v2.GeoBoundingBox.classifications)
  return _internal_classifications(index);
}
inline ::aip::processor::v2::Classification* GeoBoundingBox::_internal_add_classifications() {
  return classifications_.Add();
}
inline ::aip::processor::v2::Classification* GeoBoundingBox::add_classifications() {
  // @@protoc_insertion_point(field_add:aip.processor.v2.GeoBoundingBox.classifications)
  return _internal_add_classifications();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::aip::processor::v2::Classification >&
GeoBoundingBox::classifications() const {
  // @@protoc_insertion_point(field_list:aip.processor.v2.GeoBoundingBox.classifications)
  return classifications_;
}

// -------------------------------------------------------------------

// BoundingPolygon

// .aip.processor.v2.Polygon polygon = 1;
inline bool BoundingPolygon::_internal_has_polygon() const {
  return this != internal_default_instance() && polygon_ != nullptr;
}
inline bool BoundingPolygon::has_polygon() const {
  return _internal_has_polygon();
}
inline void BoundingPolygon::clear_polygon() {
  if (GetArena() == nullptr && polygon_ != nullptr) {
    delete polygon_;
  }
  polygon_ = nullptr;
}
inline const ::aip::processor::v2::Polygon& BoundingPolygon::_internal_polygon() const {
  const ::aip::processor::v2::Polygon* p = polygon_;
  return p != nullptr ? *p : *reinterpret_cast<const ::aip::processor::v2::Polygon*>(
      &::aip::processor::v2::_Polygon_default_instance_);
}
inline const ::aip::processor::v2::Polygon& BoundingPolygon::polygon() const {
  // @@protoc_insertion_point(field_get:aip.processor.v2.BoundingPolygon.polygon)
  return _internal_polygon();
}
inline void BoundingPolygon::unsafe_arena_set_allocated_polygon(
    ::aip::processor::v2::Polygon* polygon) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(polygon_);
  }
  polygon_ = polygon;
  if (polygon) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:aip.processor.v2.BoundingPolygon.polygon)
}
inline ::aip::processor::v2::Polygon* BoundingPolygon::release_polygon() {
  
  ::aip::processor::v2::Polygon* temp = polygon_;
  polygon_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::aip::processor::v2::Polygon* BoundingPolygon::unsafe_arena_release_polygon() {
  // @@protoc_insertion_point(field_release:aip.processor.v2.BoundingPolygon.polygon)
  
  ::aip::processor::v2::Polygon* temp = polygon_;
  polygon_ = nullptr;
  return temp;
}
inline ::aip::processor::v2::Polygon* BoundingPolygon::_internal_mutable_polygon() {
  
  if (polygon_ == nullptr) {
    auto* p = CreateMaybeMessage<::aip::processor::v2::Polygon>(GetArena());
    polygon_ = p;
  }
  return polygon_;
}
inline ::aip::processor::v2::Polygon* BoundingPolygon::mutable_polygon() {
  // @@protoc_insertion_point(field_mutable:aip.processor.v2.BoundingPolygon.polygon)
  return _internal_mutable_polygon();
}
inline void BoundingPolygon::set_allocated_polygon(::aip::processor::v2::Polygon* polygon) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete polygon_;
  }
  if (polygon) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(polygon);
    if (message_arena != submessage_arena) {
      polygon = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, polygon, submessage_arena);
    }
    
  } else {
    
  }
  polygon_ = polygon;
  // @@protoc_insertion_point(field_set_allocated:aip.processor.v2.BoundingPolygon.polygon)
}

// repeated .aip.processor.v2.Classification classifications = 2;
inline int BoundingPolygon::_internal_classifications_size() const {
  return classifications_.size();
}
inline int BoundingPolygon::classifications_size() const {
  return _internal_classifications_size();
}
inline void BoundingPolygon::clear_classifications() {
  classifications_.Clear();
}
inline ::aip::processor::v2::Classification* BoundingPolygon::mutable_classifications(int index) {
  // @@protoc_insertion_point(field_mutable:aip.processor.v2.BoundingPolygon.classifications)
  return classifications_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::aip::processor::v2::Classification >*
BoundingPolygon::mutable_classifications() {
  // @@protoc_insertion_point(field_mutable_list:aip.processor.v2.BoundingPolygon.classifications)
  return &classifications_;
}
inline const ::aip::processor::v2::Classification& BoundingPolygon::_internal_classifications(int index) const {
  return classifications_.Get(index);
}
inline const ::aip::processor::v2::Classification& BoundingPolygon::classifications(int index) const {
  // @@protoc_insertion_point(field_get:aip.processor.v2.BoundingPolygon.classifications)
  return _internal_classifications(index);
}
inline ::aip::processor::v2::Classification* BoundingPolygon::_internal_add_classifications() {
  return classifications_.Add();
}
inline ::aip::processor::v2::Classification* BoundingPolygon::add_classifications() {
  // @@protoc_insertion_point(field_add:aip.processor.v2.BoundingPolygon.classifications)
  return _internal_add_classifications();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::aip::processor::v2::Classification >&
BoundingPolygon::classifications() const {
  // @@protoc_insertion_point(field_list:aip.processor.v2.BoundingPolygon.classifications)
  return classifications_;
}

// -------------------------------------------------------------------

// GeoBoundingPolygon

// .aip.processor.v2.GeoPolygon polygon = 1;
inline bool GeoBoundingPolygon::_internal_has_polygon() const {
  return this != internal_default_instance() && polygon_ != nullptr;
}
inline bool GeoBoundingPolygon::has_polygon() const {
  return _internal_has_polygon();
}
inline void GeoBoundingPolygon::clear_polygon() {
  if (GetArena() == nullptr && polygon_ != nullptr) {
    delete polygon_;
  }
  polygon_ = nullptr;
}
inline const ::aip::processor::v2::GeoPolygon& GeoBoundingPolygon::_internal_polygon() const {
  const ::aip::processor::v2::GeoPolygon* p = polygon_;
  return p != nullptr ? *p : *reinterpret_cast<const ::aip::processor::v2::GeoPolygon*>(
      &::aip::processor::v2::_GeoPolygon_default_instance_);
}
inline const ::aip::processor::v2::GeoPolygon& GeoBoundingPolygon::polygon() const {
  // @@protoc_insertion_point(field_get:aip.processor.v2.GeoBoundingPolygon.polygon)
  return _internal_polygon();
}
inline void GeoBoundingPolygon::unsafe_arena_set_allocated_polygon(
    ::aip::processor::v2::GeoPolygon* polygon) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(polygon_);
  }
  polygon_ = polygon;
  if (polygon) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:aip.processor.v2.GeoBoundingPolygon.polygon)
}
inline ::aip::processor::v2::GeoPolygon* GeoBoundingPolygon::release_polygon() {
  
  ::aip::processor::v2::GeoPolygon* temp = polygon_;
  polygon_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::aip::processor::v2::GeoPolygon* GeoBoundingPolygon::unsafe_arena_release_polygon() {
  // @@protoc_insertion_point(field_release:aip.processor.v2.GeoBoundingPolygon.polygon)
  
  ::aip::processor::v2::GeoPolygon* temp = polygon_;
  polygon_ = nullptr;
  return temp;
}
inline ::aip::processor::v2::GeoPolygon* GeoBoundingPolygon::_internal_mutable_polygon() {
  
  if (polygon_ == nullptr) {
    auto* p = CreateMaybeMessage<::aip::processor::v2::GeoPolygon>(GetArena());
    polygon_ = p;
  }
  return polygon_;
}
inline ::aip::processor::v2::GeoPolygon* GeoBoundingPolygon::mutable_polygon() {
  // @@protoc_insertion_point(field_mutable:aip.processor.v2.GeoBoundingPolygon.polygon)
  return _internal_mutable_polygon();
}
inline void GeoBoundingPolygon::set_allocated_polygon(::aip::processor::v2::GeoPolygon* polygon) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete polygon_;
  }
  if (polygon) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(polygon);
    if (message_arena != submessage_arena) {
      polygon = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, polygon, submessage_arena);
    }
    
  } else {
    
  }
  polygon_ = polygon;
  // @@protoc_insertion_point(field_set_allocated:aip.processor.v2.GeoBoundingPolygon.polygon)
}

// repeated .aip.processor.v2.Classification classifications = 2;
inline int GeoBoundingPolygon::_internal_classifications_size() const {
  return classifications_.size();
}
inline int GeoBoundingPolygon::classifications_size() const {
  return _internal_classifications_size();
}
inline void GeoBoundingPolygon::clear_classifications() {
  classifications_.Clear();
}
inline ::aip::processor::v2::Classification* GeoBoundingPolygon::mutable_classifications(int index) {
  // @@protoc_insertion_point(field_mutable:aip.processor.v2.GeoBoundingPolygon.classifications)
  return classifications_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::aip::processor::v2::Classification >*
GeoBoundingPolygon::mutable_classifications() {
  // @@protoc_insertion_point(field_mutable_list:aip.processor.v2.GeoBoundingPolygon.classifications)
  return &classifications_;
}
inline const ::aip::processor::v2::Classification& GeoBoundingPolygon::_internal_classifications(int index) const {
  return classifications_.Get(index);
}
inline const ::aip::processor::v2::Classification& GeoBoundingPolygon::classifications(int index) const {
  // @@protoc_insertion_point(field_get:aip.processor.v2.GeoBoundingPolygon.classifications)
  return _internal_classifications(index);
}
inline ::aip::processor::v2::Classification* GeoBoundingPolygon::_internal_add_classifications() {
  return classifications_.Add();
}
inline ::aip::processor::v2::Classification* GeoBoundingPolygon::add_classifications() {
  // @@protoc_insertion_point(field_add:aip.processor.v2.GeoBoundingPolygon.classifications)
  return _internal_add_classifications();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::aip::processor::v2::Classification >&
GeoBoundingPolygon::classifications() const {
  // @@protoc_insertion_point(field_list:aip.processor.v2.GeoBoundingPolygon.classifications)
  return classifications_;
}

// -------------------------------------------------------------------

// Polygon

// repeated .aip.processor.v2.UnitCoordinate vertices = 1;
inline int Polygon::_internal_vertices_size() const {
  return vertices_.size();
}
inline int Polygon::vertices_size() const {
  return _internal_vertices_size();
}
inline void Polygon::clear_vertices() {
  vertices_.Clear();
}
inline ::aip::processor::v2::UnitCoordinate* Polygon::mutable_vertices(int index) {
  // @@protoc_insertion_point(field_mutable:aip.processor.v2.Polygon.vertices)
  return vertices_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::aip::processor::v2::UnitCoordinate >*
Polygon::mutable_vertices() {
  // @@protoc_insertion_point(field_mutable_list:aip.processor.v2.Polygon.vertices)
  return &vertices_;
}
inline const ::aip::processor::v2::UnitCoordinate& Polygon::_internal_vertices(int index) const {
  return vertices_.Get(index);
}
inline const ::aip::processor::v2::UnitCoordinate& Polygon::vertices(int index) const {
  // @@protoc_insertion_point(field_get:aip.processor.v2.Polygon.vertices)
  return _internal_vertices(index);
}
inline ::aip::processor::v2::UnitCoordinate* Polygon::_internal_add_vertices() {
  return vertices_.Add();
}
inline ::aip::processor::v2::UnitCoordinate* Polygon::add_vertices() {
  // @@protoc_insertion_point(field_add:aip.processor.v2.Polygon.vertices)
  return _internal_add_vertices();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::aip::processor::v2::UnitCoordinate >&
Polygon::vertices() const {
  // @@protoc_insertion_point(field_list:aip.processor.v2.Polygon.vertices)
  return vertices_;
}

// -------------------------------------------------------------------

// GeoPolygon

// repeated .aip.processor.v2.GeoCoordinate vertices = 1;
inline int GeoPolygon::_internal_vertices_size() const {
  return vertices_.size();
}
inline int GeoPolygon::vertices_size() const {
  return _internal_vertices_size();
}
inline void GeoPolygon::clear_vertices() {
  vertices_.Clear();
}
inline ::aip::processor::v2::GeoCoordinate* GeoPolygon::mutable_vertices(int index) {
  // @@protoc_insertion_point(field_mutable:aip.processor.v2.GeoPolygon.vertices)
  return vertices_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::aip::processor::v2::GeoCoordinate >*
GeoPolygon::mutable_vertices() {
  // @@protoc_insertion_point(field_mutable_list:aip.processor.v2.GeoPolygon.vertices)
  return &vertices_;
}
inline const ::aip::processor::v2::GeoCoordinate& GeoPolygon::_internal_vertices(int index) const {
  return vertices_.Get(index);
}
inline const ::aip::processor::v2::GeoCoordinate& GeoPolygon::vertices(int index) const {
  // @@protoc_insertion_point(field_get:aip.processor.v2.GeoPolygon.vertices)
  return _internal_vertices(index);
}
inline ::aip::processor::v2::GeoCoordinate* GeoPolygon::_internal_add_vertices() {
  return vertices_.Add();
}
inline ::aip::processor::v2::GeoCoordinate* GeoPolygon::add_vertices() {
  // @@protoc_insertion_point(field_add:aip.processor.v2.GeoPolygon.vertices)
  return _internal_add_vertices();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::aip::processor::v2::GeoCoordinate >&
GeoPolygon::vertices() const {
  // @@protoc_insertion_point(field_list:aip.processor.v2.GeoPolygon.vertices)
  return vertices_;
}

// -------------------------------------------------------------------

// UnitCoordinate

// double row = 1;
inline void UnitCoordinate::clear_row() {
  row_ = 0;
}
inline double UnitCoordinate::_internal_row() const {
  return row_;
}
inline double UnitCoordinate::row() const {
  // @@protoc_insertion_point(field_get:aip.processor.v2.UnitCoordinate.row)
  return _internal_row();
}
inline void UnitCoordinate::_internal_set_row(double value) {
  
  row_ = value;
}
inline void UnitCoordinate::set_row(double value) {
  _internal_set_row(value);
  // @@protoc_insertion_point(field_set:aip.processor.v2.UnitCoordinate.row)
}

// double col = 2;
inline void UnitCoordinate::clear_col() {
  col_ = 0;
}
inline double UnitCoordinate::_internal_col() const {
  return col_;
}
inline double UnitCoordinate::col() const {
  // @@protoc_insertion_point(field_get:aip.processor.v2.UnitCoordinate.col)
  return _internal_col();
}
inline void UnitCoordinate::_internal_set_col(double value) {
  
  col_ = value;
}
inline void UnitCoordinate::set_col(double value) {
  _internal_set_col(value);
  // @@protoc_insertion_point(field_set:aip.processor.v2.UnitCoordinate.col)
}

// -------------------------------------------------------------------

// Classification

// string type = 1;
inline void Classification::clear_type() {
  type_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& Classification::type() const {
  // @@protoc_insertion_point(field_get:aip.processor.v2.Classification.type)
  return _internal_type();
}
inline void Classification::set_type(const std::string& value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:aip.processor.v2.Classification.type)
}
inline std::string* Classification::mutable_type() {
  // @@protoc_insertion_point(field_mutable:aip.processor.v2.Classification.type)
  return _internal_mutable_type();
}
inline const std::string& Classification::_internal_type() const {
  return type_.Get();
}
inline void Classification::_internal_set_type(const std::string& value) {
  
  type_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void Classification::set_type(std::string&& value) {
  
  type_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:aip.processor.v2.Classification.type)
}
inline void Classification::set_type(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  type_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:aip.processor.v2.Classification.type)
}
inline void Classification::set_type(const char* value,
    size_t size) {
  
  type_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:aip.processor.v2.Classification.type)
}
inline std::string* Classification::_internal_mutable_type() {
  
  return type_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* Classification::release_type() {
  // @@protoc_insertion_point(field_release:aip.processor.v2.Classification.type)
  return type_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void Classification::set_allocated_type(std::string* type) {
  if (type != nullptr) {
    
  } else {
    
  }
  type_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), type,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:aip.processor.v2.Classification.type)
}

// double confidence = 2;
inline void Classification::clear_confidence() {
  confidence_ = 0;
}
inline double Classification::_internal_confidence() const {
  return confidence_;
}
inline double Classification::confidence() const {
  // @@protoc_insertion_point(field_get:aip.processor.v2.Classification.confidence)
  return _internal_confidence();
}
inline void Classification::_internal_set_confidence(double value) {
  
  confidence_ = value;
}
inline void Classification::set_confidence(double value) {
  _internal_set_confidence(value);
  // @@protoc_insertion_point(field_set:aip.processor.v2.Classification.confidence)
}

// -------------------------------------------------------------------

// Lattice_Point

// .aip.processor.v2.UnitCoordinate coordinate = 1;
inline bool Lattice_Point::_internal_has_coordinate() const {
  return this != internal_default_instance() && coordinate_ != nullptr;
}
inline bool Lattice_Point::has_coordinate() const {
  return _internal_has_coordinate();
}
inline void Lattice_Point::clear_coordinate() {
  if (GetArena() == nullptr && coordinate_ != nullptr) {
    delete coordinate_;
  }
  coordinate_ = nullptr;
}
inline const ::aip::processor::v2::UnitCoordinate& Lattice_Point::_internal_coordinate() const {
  const ::aip::processor::v2::UnitCoordinate* p = coordinate_;
  return p != nullptr ? *p : *reinterpret_cast<const ::aip::processor::v2::UnitCoordinate*>(
      &::aip::processor::v2::_UnitCoordinate_default_instance_);
}
inline const ::aip::processor::v2::UnitCoordinate& Lattice_Point::coordinate() const {
  // @@protoc_insertion_point(field_get:aip.processor.v2.Lattice.Point.coordinate)
  return _internal_coordinate();
}
inline void Lattice_Point::unsafe_arena_set_allocated_coordinate(
    ::aip::processor::v2::UnitCoordinate* coordinate) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(coordinate_);
  }
  coordinate_ = coordinate;
  if (coordinate) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:aip.processor.v2.Lattice.Point.coordinate)
}
inline ::aip::processor::v2::UnitCoordinate* Lattice_Point::release_coordinate() {
  
  ::aip::processor::v2::UnitCoordinate* temp = coordinate_;
  coordinate_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::aip::processor::v2::UnitCoordinate* Lattice_Point::unsafe_arena_release_coordinate() {
  // @@protoc_insertion_point(field_release:aip.processor.v2.Lattice.Point.coordinate)
  
  ::aip::processor::v2::UnitCoordinate* temp = coordinate_;
  coordinate_ = nullptr;
  return temp;
}
inline ::aip::processor::v2::UnitCoordinate* Lattice_Point::_internal_mutable_coordinate() {
  
  if (coordinate_ == nullptr) {
    auto* p = CreateMaybeMessage<::aip::processor::v2::UnitCoordinate>(GetArena());
    coordinate_ = p;
  }
  return coordinate_;
}
inline ::aip::processor::v2::UnitCoordinate* Lattice_Point::mutable_coordinate() {
  // @@protoc_insertion_point(field_mutable:aip.processor.v2.Lattice.Point.coordinate)
  return _internal_mutable_coordinate();
}
inline void Lattice_Point::set_allocated_coordinate(::aip::processor::v2::UnitCoordinate* coordinate) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete coordinate_;
  }
  if (coordinate) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(coordinate);
    if (message_arena != submessage_arena) {
      coordinate = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, coordinate, submessage_arena);
    }
    
  } else {
    
  }
  coordinate_ = coordinate;
  // @@protoc_insertion_point(field_set_allocated:aip.processor.v2.Lattice.Point.coordinate)
}

// double latitude = 2;
inline void Lattice_Point::clear_latitude() {
  latitude_ = 0;
}
inline double Lattice_Point::_internal_latitude() const {
  return latitude_;
}
inline double Lattice_Point::latitude() const {
  // @@protoc_insertion_point(field_get:aip.processor.v2.Lattice.Point.latitude)
  return _internal_latitude();
}
inline void Lattice_Point::_internal_set_latitude(double value) {
  
  latitude_ = value;
}
inline void Lattice_Point::set_latitude(double value) {
  _internal_set_latitude(value);
  // @@protoc_insertion_point(field_set:aip.processor.v2.Lattice.Point.latitude)
}

// double longitude = 3;
inline void Lattice_Point::clear_longitude() {
  longitude_ = 0;
}
inline double Lattice_Point::_internal_longitude() const {
  return longitude_;
}
inline double Lattice_Point::longitude() const {
  // @@protoc_insertion_point(field_get:aip.processor.v2.Lattice.Point.longitude)
  return _internal_longitude();
}
inline void Lattice_Point::_internal_set_longitude(double value) {
  
  longitude_ = value;
}
inline void Lattice_Point::set_longitude(double value) {
  _internal_set_longitude(value);
  // @@protoc_insertion_point(field_set:aip.processor.v2.Lattice.Point.longitude)
}

// double elevation = 4;
inline void Lattice_Point::clear_elevation() {
  elevation_ = 0;
}
inline double Lattice_Point::_internal_elevation() const {
  return elevation_;
}
inline double Lattice_Point::elevation() const {
  // @@protoc_insertion_point(field_get:aip.processor.v2.Lattice.Point.elevation)
  return _internal_elevation();
}
inline void Lattice_Point::_internal_set_elevation(double value) {
  
  elevation_ = value;
}
inline void Lattice_Point::set_elevation(double value) {
  _internal_set_elevation(value);
  // @@protoc_insertion_point(field_set:aip.processor.v2.Lattice.Point.elevation)
}

// -------------------------------------------------------------------

// Lattice

// repeated .aip.processor.v2.Lattice.Point earth_intersection = 1;
inline int Lattice::_internal_earth_intersection_size() const {
  return earth_intersection_.size();
}
inline int Lattice::earth_intersection_size() const {
  return _internal_earth_intersection_size();
}
inline void Lattice::clear_earth_intersection() {
  earth_intersection_.Clear();
}
inline ::aip::processor::v2::Lattice_Point* Lattice::mutable_earth_intersection(int index) {
  // @@protoc_insertion_point(field_mutable:aip.processor.v2.Lattice.earth_intersection)
  return earth_intersection_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::aip::processor::v2::Lattice_Point >*
Lattice::mutable_earth_intersection() {
  // @@protoc_insertion_point(field_mutable_list:aip.processor.v2.Lattice.earth_intersection)
  return &earth_intersection_;
}
inline const ::aip::processor::v2::Lattice_Point& Lattice::_internal_earth_intersection(int index) const {
  return earth_intersection_.Get(index);
}
inline const ::aip::processor::v2::Lattice_Point& Lattice::earth_intersection(int index) const {
  // @@protoc_insertion_point(field_get:aip.processor.v2.Lattice.earth_intersection)
  return _internal_earth_intersection(index);
}
inline ::aip::processor::v2::Lattice_Point* Lattice::_internal_add_earth_intersection() {
  return earth_intersection_.Add();
}
inline ::aip::processor::v2::Lattice_Point* Lattice::add_earth_intersection() {
  // @@protoc_insertion_point(field_add:aip.processor.v2.Lattice.earth_intersection)
  return _internal_add_earth_intersection();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::aip::processor::v2::Lattice_Point >&
Lattice::earth_intersection() const {
  // @@protoc_insertion_point(field_list:aip.processor.v2.Lattice.earth_intersection)
  return earth_intersection_;
}

// -------------------------------------------------------------------

// Velocity

// .aip.processor.v2.PixelVelocityVector pixel = 4;
inline bool Velocity::_internal_has_pixel() const {
  return velocity_case() == kPixel;
}
inline bool Velocity::has_pixel() const {
  return _internal_has_pixel();
}
inline void Velocity::set_has_pixel() {
  _oneof_case_[0] = kPixel;
}
inline void Velocity::clear_pixel() {
  if (_internal_has_pixel()) {
    if (GetArena() == nullptr) {
      delete velocity_.pixel_;
    }
    clear_has_velocity();
  }
}
inline ::aip::processor::v2::PixelVelocityVector* Velocity::release_pixel() {
  // @@protoc_insertion_point(field_release:aip.processor.v2.Velocity.pixel)
  if (_internal_has_pixel()) {
    clear_has_velocity();
      ::aip::processor::v2::PixelVelocityVector* temp = velocity_.pixel_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    velocity_.pixel_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::aip::processor::v2::PixelVelocityVector& Velocity::_internal_pixel() const {
  return _internal_has_pixel()
      ? *velocity_.pixel_
      : *reinterpret_cast< ::aip::processor::v2::PixelVelocityVector*>(&::aip::processor::v2::_PixelVelocityVector_default_instance_);
}
inline const ::aip::processor::v2::PixelVelocityVector& Velocity::pixel() const {
  // @@protoc_insertion_point(field_get:aip.processor.v2.Velocity.pixel)
  return _internal_pixel();
}
inline ::aip::processor::v2::PixelVelocityVector* Velocity::unsafe_arena_release_pixel() {
  // @@protoc_insertion_point(field_unsafe_arena_release:aip.processor.v2.Velocity.pixel)
  if (_internal_has_pixel()) {
    clear_has_velocity();
    ::aip::processor::v2::PixelVelocityVector* temp = velocity_.pixel_;
    velocity_.pixel_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Velocity::unsafe_arena_set_allocated_pixel(::aip::processor::v2::PixelVelocityVector* pixel) {
  clear_velocity();
  if (pixel) {
    set_has_pixel();
    velocity_.pixel_ = pixel;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:aip.processor.v2.Velocity.pixel)
}
inline ::aip::processor::v2::PixelVelocityVector* Velocity::_internal_mutable_pixel() {
  if (!_internal_has_pixel()) {
    clear_velocity();
    set_has_pixel();
    velocity_.pixel_ = CreateMaybeMessage< ::aip::processor::v2::PixelVelocityVector >(GetArena());
  }
  return velocity_.pixel_;
}
inline ::aip::processor::v2::PixelVelocityVector* Velocity::mutable_pixel() {
  // @@protoc_insertion_point(field_mutable:aip.processor.v2.Velocity.pixel)
  return _internal_mutable_pixel();
}

inline bool Velocity::has_velocity() const {
  return velocity_case() != VELOCITY_NOT_SET;
}
inline void Velocity::clear_has_velocity() {
  _oneof_case_[0] = VELOCITY_NOT_SET;
}
inline Velocity::VelocityCase Velocity::velocity_case() const {
  return Velocity::VelocityCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// PixelVelocityVector

// double x = 1;
inline void PixelVelocityVector::clear_x() {
  x_ = 0;
}
inline double PixelVelocityVector::_internal_x() const {
  return x_;
}
inline double PixelVelocityVector::x() const {
  // @@protoc_insertion_point(field_get:aip.processor.v2.PixelVelocityVector.x)
  return _internal_x();
}
inline void PixelVelocityVector::_internal_set_x(double value) {
  
  x_ = value;
}
inline void PixelVelocityVector::set_x(double value) {
  _internal_set_x(value);
  // @@protoc_insertion_point(field_set:aip.processor.v2.PixelVelocityVector.x)
}

// double y = 2;
inline void PixelVelocityVector::clear_y() {
  y_ = 0;
}
inline double PixelVelocityVector::_internal_y() const {
  return y_;
}
inline double PixelVelocityVector::y() const {
  // @@protoc_insertion_point(field_get:aip.processor.v2.PixelVelocityVector.y)
  return _internal_y();
}
inline void PixelVelocityVector::_internal_set_y(double value) {
  
  y_ = value;
}
inline void PixelVelocityVector::set_y(double value) {
  _internal_set_y(value);
  // @@protoc_insertion_point(field_set:aip.processor.v2.PixelVelocityVector.y)
}

// -------------------------------------------------------------------

// Frame

// .aip.processor.v2.Image image = 1;
inline bool Frame::_internal_has_image() const {
  return this != internal_default_instance() && image_ != nullptr;
}
inline bool Frame::has_image() const {
  return _internal_has_image();
}
inline void Frame::clear_image() {
  if (GetArena() == nullptr && image_ != nullptr) {
    delete image_;
  }
  image_ = nullptr;
}
inline const ::aip::processor::v2::Image& Frame::_internal_image() const {
  const ::aip::processor::v2::Image* p = image_;
  return p != nullptr ? *p : *reinterpret_cast<const ::aip::processor::v2::Image*>(
      &::aip::processor::v2::_Image_default_instance_);
}
inline const ::aip::processor::v2::Image& Frame::image() const {
  // @@protoc_insertion_point(field_get:aip.processor.v2.Frame.image)
  return _internal_image();
}
inline void Frame::unsafe_arena_set_allocated_image(
    ::aip::processor::v2::Image* image) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(image_);
  }
  image_ = image;
  if (image) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:aip.processor.v2.Frame.image)
}
inline ::aip::processor::v2::Image* Frame::release_image() {
  
  ::aip::processor::v2::Image* temp = image_;
  image_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::aip::processor::v2::Image* Frame::unsafe_arena_release_image() {
  // @@protoc_insertion_point(field_release:aip.processor.v2.Frame.image)
  
  ::aip::processor::v2::Image* temp = image_;
  image_ = nullptr;
  return temp;
}
inline ::aip::processor::v2::Image* Frame::_internal_mutable_image() {
  
  if (image_ == nullptr) {
    auto* p = CreateMaybeMessage<::aip::processor::v2::Image>(GetArena());
    image_ = p;
  }
  return image_;
}
inline ::aip::processor::v2::Image* Frame::mutable_image() {
  // @@protoc_insertion_point(field_mutable:aip.processor.v2.Frame.image)
  return _internal_mutable_image();
}
inline void Frame::set_allocated_image(::aip::processor::v2::Image* image) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete image_;
  }
  if (image) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(image);
    if (message_arena != submessage_arena) {
      image = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, image, submessage_arena);
    }
    
  } else {
    
  }
  image_ = image;
  // @@protoc_insertion_point(field_set_allocated:aip.processor.v2.Frame.image)
}

// .aip.processor.v2.UasMetadata uas_metadata = 2;
inline bool Frame::_internal_has_uas_metadata() const {
  return this != internal_default_instance() && uas_metadata_ != nullptr;
}
inline bool Frame::has_uas_metadata() const {
  return _internal_has_uas_metadata();
}
inline void Frame::clear_uas_metadata() {
  if (GetArena() == nullptr && uas_metadata_ != nullptr) {
    delete uas_metadata_;
  }
  uas_metadata_ = nullptr;
}
inline const ::aip::processor::v2::UasMetadata& Frame::_internal_uas_metadata() const {
  const ::aip::processor::v2::UasMetadata* p = uas_metadata_;
  return p != nullptr ? *p : *reinterpret_cast<const ::aip::processor::v2::UasMetadata*>(
      &::aip::processor::v2::_UasMetadata_default_instance_);
}
inline const ::aip::processor::v2::UasMetadata& Frame::uas_metadata() const {
  // @@protoc_insertion_point(field_get:aip.processor.v2.Frame.uas_metadata)
  return _internal_uas_metadata();
}
inline void Frame::unsafe_arena_set_allocated_uas_metadata(
    ::aip::processor::v2::UasMetadata* uas_metadata) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(uas_metadata_);
  }
  uas_metadata_ = uas_metadata;
  if (uas_metadata) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:aip.processor.v2.Frame.uas_metadata)
}
inline ::aip::processor::v2::UasMetadata* Frame::release_uas_metadata() {
  
  ::aip::processor::v2::UasMetadata* temp = uas_metadata_;
  uas_metadata_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::aip::processor::v2::UasMetadata* Frame::unsafe_arena_release_uas_metadata() {
  // @@protoc_insertion_point(field_release:aip.processor.v2.Frame.uas_metadata)
  
  ::aip::processor::v2::UasMetadata* temp = uas_metadata_;
  uas_metadata_ = nullptr;
  return temp;
}
inline ::aip::processor::v2::UasMetadata* Frame::_internal_mutable_uas_metadata() {
  
  if (uas_metadata_ == nullptr) {
    auto* p = CreateMaybeMessage<::aip::processor::v2::UasMetadata>(GetArena());
    uas_metadata_ = p;
  }
  return uas_metadata_;
}
inline ::aip::processor::v2::UasMetadata* Frame::mutable_uas_metadata() {
  // @@protoc_insertion_point(field_mutable:aip.processor.v2.Frame.uas_metadata)
  return _internal_mutable_uas_metadata();
}
inline void Frame::set_allocated_uas_metadata(::aip::processor::v2::UasMetadata* uas_metadata) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete uas_metadata_;
  }
  if (uas_metadata) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(uas_metadata);
    if (message_arena != submessage_arena) {
      uas_metadata = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, uas_metadata, submessage_arena);
    }
    
  } else {
    
  }
  uas_metadata_ = uas_metadata;
  // @@protoc_insertion_point(field_set_allocated:aip.processor.v2.Frame.uas_metadata)
}

// -------------------------------------------------------------------

// Image

// .aip.processor.v2.Rgb888Image rgb_image = 1;
inline bool Image::_internal_has_rgb_image() const {
  return image_case() == kRgbImage;
}
inline bool Image::has_rgb_image() const {
  return _internal_has_rgb_image();
}
inline void Image::set_has_rgb_image() {
  _oneof_case_[0] = kRgbImage;
}
inline void Image::clear_rgb_image() {
  if (_internal_has_rgb_image()) {
    if (GetArena() == nullptr) {
      delete image_.rgb_image_;
    }
    clear_has_image();
  }
}
inline ::aip::processor::v2::Rgb888Image* Image::release_rgb_image() {
  // @@protoc_insertion_point(field_release:aip.processor.v2.Image.rgb_image)
  if (_internal_has_rgb_image()) {
    clear_has_image();
      ::aip::processor::v2::Rgb888Image* temp = image_.rgb_image_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    image_.rgb_image_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::aip::processor::v2::Rgb888Image& Image::_internal_rgb_image() const {
  return _internal_has_rgb_image()
      ? *image_.rgb_image_
      : *reinterpret_cast< ::aip::processor::v2::Rgb888Image*>(&::aip::processor::v2::_Rgb888Image_default_instance_);
}
inline const ::aip::processor::v2::Rgb888Image& Image::rgb_image() const {
  // @@protoc_insertion_point(field_get:aip.processor.v2.Image.rgb_image)
  return _internal_rgb_image();
}
inline ::aip::processor::v2::Rgb888Image* Image::unsafe_arena_release_rgb_image() {
  // @@protoc_insertion_point(field_unsafe_arena_release:aip.processor.v2.Image.rgb_image)
  if (_internal_has_rgb_image()) {
    clear_has_image();
    ::aip::processor::v2::Rgb888Image* temp = image_.rgb_image_;
    image_.rgb_image_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Image::unsafe_arena_set_allocated_rgb_image(::aip::processor::v2::Rgb888Image* rgb_image) {
  clear_image();
  if (rgb_image) {
    set_has_rgb_image();
    image_.rgb_image_ = rgb_image;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:aip.processor.v2.Image.rgb_image)
}
inline ::aip::processor::v2::Rgb888Image* Image::_internal_mutable_rgb_image() {
  if (!_internal_has_rgb_image()) {
    clear_image();
    set_has_rgb_image();
    image_.rgb_image_ = CreateMaybeMessage< ::aip::processor::v2::Rgb888Image >(GetArena());
  }
  return image_.rgb_image_;
}
inline ::aip::processor::v2::Rgb888Image* Image::mutable_rgb_image() {
  // @@protoc_insertion_point(field_mutable:aip.processor.v2.Image.rgb_image)
  return _internal_mutable_rgb_image();
}

// .aip.processor.v2.PngImage png_image = 2;
inline bool Image::_internal_has_png_image() const {
  return image_case() == kPngImage;
}
inline bool Image::has_png_image() const {
  return _internal_has_png_image();
}
inline void Image::set_has_png_image() {
  _oneof_case_[0] = kPngImage;
}
inline void Image::clear_png_image() {
  if (_internal_has_png_image()) {
    if (GetArena() == nullptr) {
      delete image_.png_image_;
    }
    clear_has_image();
  }
}
inline ::aip::processor::v2::PngImage* Image::release_png_image() {
  // @@protoc_insertion_point(field_release:aip.processor.v2.Image.png_image)
  if (_internal_has_png_image()) {
    clear_has_image();
      ::aip::processor::v2::PngImage* temp = image_.png_image_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    image_.png_image_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::aip::processor::v2::PngImage& Image::_internal_png_image() const {
  return _internal_has_png_image()
      ? *image_.png_image_
      : *reinterpret_cast< ::aip::processor::v2::PngImage*>(&::aip::processor::v2::_PngImage_default_instance_);
}
inline const ::aip::processor::v2::PngImage& Image::png_image() const {
  // @@protoc_insertion_point(field_get:aip.processor.v2.Image.png_image)
  return _internal_png_image();
}
inline ::aip::processor::v2::PngImage* Image::unsafe_arena_release_png_image() {
  // @@protoc_insertion_point(field_unsafe_arena_release:aip.processor.v2.Image.png_image)
  if (_internal_has_png_image()) {
    clear_has_image();
    ::aip::processor::v2::PngImage* temp = image_.png_image_;
    image_.png_image_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Image::unsafe_arena_set_allocated_png_image(::aip::processor::v2::PngImage* png_image) {
  clear_image();
  if (png_image) {
    set_has_png_image();
    image_.png_image_ = png_image;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:aip.processor.v2.Image.png_image)
}
inline ::aip::processor::v2::PngImage* Image::_internal_mutable_png_image() {
  if (!_internal_has_png_image()) {
    clear_image();
    set_has_png_image();
    image_.png_image_ = CreateMaybeMessage< ::aip::processor::v2::PngImage >(GetArena());
  }
  return image_.png_image_;
}
inline ::aip::processor::v2::PngImage* Image::mutable_png_image() {
  // @@protoc_insertion_point(field_mutable:aip.processor.v2.Image.png_image)
  return _internal_mutable_png_image();
}

// .aip.processor.v2.TiffImage tiff_image = 3;
inline bool Image::_internal_has_tiff_image() const {
  return image_case() == kTiffImage;
}
inline bool Image::has_tiff_image() const {
  return _internal_has_tiff_image();
}
inline void Image::set_has_tiff_image() {
  _oneof_case_[0] = kTiffImage;
}
inline void Image::clear_tiff_image() {
  if (_internal_has_tiff_image()) {
    if (GetArena() == nullptr) {
      delete image_.tiff_image_;
    }
    clear_has_image();
  }
}
inline ::aip::processor::v2::TiffImage* Image::release_tiff_image() {
  // @@protoc_insertion_point(field_release:aip.processor.v2.Image.tiff_image)
  if (_internal_has_tiff_image()) {
    clear_has_image();
      ::aip::processor::v2::TiffImage* temp = image_.tiff_image_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    image_.tiff_image_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::aip::processor::v2::TiffImage& Image::_internal_tiff_image() const {
  return _internal_has_tiff_image()
      ? *image_.tiff_image_
      : *reinterpret_cast< ::aip::processor::v2::TiffImage*>(&::aip::processor::v2::_TiffImage_default_instance_);
}
inline const ::aip::processor::v2::TiffImage& Image::tiff_image() const {
  // @@protoc_insertion_point(field_get:aip.processor.v2.Image.tiff_image)
  return _internal_tiff_image();
}
inline ::aip::processor::v2::TiffImage* Image::unsafe_arena_release_tiff_image() {
  // @@protoc_insertion_point(field_unsafe_arena_release:aip.processor.v2.Image.tiff_image)
  if (_internal_has_tiff_image()) {
    clear_has_image();
    ::aip::processor::v2::TiffImage* temp = image_.tiff_image_;
    image_.tiff_image_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Image::unsafe_arena_set_allocated_tiff_image(::aip::processor::v2::TiffImage* tiff_image) {
  clear_image();
  if (tiff_image) {
    set_has_tiff_image();
    image_.tiff_image_ = tiff_image;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:aip.processor.v2.Image.tiff_image)
}
inline ::aip::processor::v2::TiffImage* Image::_internal_mutable_tiff_image() {
  if (!_internal_has_tiff_image()) {
    clear_image();
    set_has_tiff_image();
    image_.tiff_image_ = CreateMaybeMessage< ::aip::processor::v2::TiffImage >(GetArena());
  }
  return image_.tiff_image_;
}
inline ::aip::processor::v2::TiffImage* Image::mutable_tiff_image() {
  // @@protoc_insertion_point(field_mutable:aip.processor.v2.Image.tiff_image)
  return _internal_mutable_tiff_image();
}

// .aip.processor.v2.Bgr888Image bgr_image = 4;
inline bool Image::_internal_has_bgr_image() const {
  return image_case() == kBgrImage;
}
inline bool Image::has_bgr_image() const {
  return _internal_has_bgr_image();
}
inline void Image::set_has_bgr_image() {
  _oneof_case_[0] = kBgrImage;
}
inline void Image::clear_bgr_image() {
  if (_internal_has_bgr_image()) {
    if (GetArena() == nullptr) {
      delete image_.bgr_image_;
    }
    clear_has_image();
  }
}
inline ::aip::processor::v2::Bgr888Image* Image::release_bgr_image() {
  // @@protoc_insertion_point(field_release:aip.processor.v2.Image.bgr_image)
  if (_internal_has_bgr_image()) {
    clear_has_image();
      ::aip::processor::v2::Bgr888Image* temp = image_.bgr_image_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    image_.bgr_image_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::aip::processor::v2::Bgr888Image& Image::_internal_bgr_image() const {
  return _internal_has_bgr_image()
      ? *image_.bgr_image_
      : *reinterpret_cast< ::aip::processor::v2::Bgr888Image*>(&::aip::processor::v2::_Bgr888Image_default_instance_);
}
inline const ::aip::processor::v2::Bgr888Image& Image::bgr_image() const {
  // @@protoc_insertion_point(field_get:aip.processor.v2.Image.bgr_image)
  return _internal_bgr_image();
}
inline ::aip::processor::v2::Bgr888Image* Image::unsafe_arena_release_bgr_image() {
  // @@protoc_insertion_point(field_unsafe_arena_release:aip.processor.v2.Image.bgr_image)
  if (_internal_has_bgr_image()) {
    clear_has_image();
    ::aip::processor::v2::Bgr888Image* temp = image_.bgr_image_;
    image_.bgr_image_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Image::unsafe_arena_set_allocated_bgr_image(::aip::processor::v2::Bgr888Image* bgr_image) {
  clear_image();
  if (bgr_image) {
    set_has_bgr_image();
    image_.bgr_image_ = bgr_image;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:aip.processor.v2.Image.bgr_image)
}
inline ::aip::processor::v2::Bgr888Image* Image::_internal_mutable_bgr_image() {
  if (!_internal_has_bgr_image()) {
    clear_image();
    set_has_bgr_image();
    image_.bgr_image_ = CreateMaybeMessage< ::aip::processor::v2::Bgr888Image >(GetArena());
  }
  return image_.bgr_image_;
}
inline ::aip::processor::v2::Bgr888Image* Image::mutable_bgr_image() {
  // @@protoc_insertion_point(field_mutable:aip.processor.v2.Image.bgr_image)
  return _internal_mutable_bgr_image();
}

// .aip.processor.v2.Nitf21Image nitf21_image = 5;
inline bool Image::_internal_has_nitf21_image() const {
  return image_case() == kNitf21Image;
}
inline bool Image::has_nitf21_image() const {
  return _internal_has_nitf21_image();
}
inline void Image::set_has_nitf21_image() {
  _oneof_case_[0] = kNitf21Image;
}
inline void Image::clear_nitf21_image() {
  if (_internal_has_nitf21_image()) {
    if (GetArena() == nullptr) {
      delete image_.nitf21_image_;
    }
    clear_has_image();
  }
}
inline ::aip::processor::v2::Nitf21Image* Image::release_nitf21_image() {
  // @@protoc_insertion_point(field_release:aip.processor.v2.Image.nitf21_image)
  if (_internal_has_nitf21_image()) {
    clear_has_image();
      ::aip::processor::v2::Nitf21Image* temp = image_.nitf21_image_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    image_.nitf21_image_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::aip::processor::v2::Nitf21Image& Image::_internal_nitf21_image() const {
  return _internal_has_nitf21_image()
      ? *image_.nitf21_image_
      : *reinterpret_cast< ::aip::processor::v2::Nitf21Image*>(&::aip::processor::v2::_Nitf21Image_default_instance_);
}
inline const ::aip::processor::v2::Nitf21Image& Image::nitf21_image() const {
  // @@protoc_insertion_point(field_get:aip.processor.v2.Image.nitf21_image)
  return _internal_nitf21_image();
}
inline ::aip::processor::v2::Nitf21Image* Image::unsafe_arena_release_nitf21_image() {
  // @@protoc_insertion_point(field_unsafe_arena_release:aip.processor.v2.Image.nitf21_image)
  if (_internal_has_nitf21_image()) {
    clear_has_image();
    ::aip::processor::v2::Nitf21Image* temp = image_.nitf21_image_;
    image_.nitf21_image_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Image::unsafe_arena_set_allocated_nitf21_image(::aip::processor::v2::Nitf21Image* nitf21_image) {
  clear_image();
  if (nitf21_image) {
    set_has_nitf21_image();
    image_.nitf21_image_ = nitf21_image;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:aip.processor.v2.Image.nitf21_image)
}
inline ::aip::processor::v2::Nitf21Image* Image::_internal_mutable_nitf21_image() {
  if (!_internal_has_nitf21_image()) {
    clear_image();
    set_has_nitf21_image();
    image_.nitf21_image_ = CreateMaybeMessage< ::aip::processor::v2::Nitf21Image >(GetArena());
  }
  return image_.nitf21_image_;
}
inline ::aip::processor::v2::Nitf21Image* Image::mutable_nitf21_image() {
  // @@protoc_insertion_point(field_mutable:aip.processor.v2.Image.nitf21_image)
  return _internal_mutable_nitf21_image();
}

inline bool Image::has_image() const {
  return image_case() != IMAGE_NOT_SET;
}
inline void Image::clear_has_image() {
  _oneof_case_[0] = IMAGE_NOT_SET;
}
inline Image::ImageCase Image::image_case() const {
  return Image::ImageCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// Rgb888Image

// int32 width = 1;
inline void Rgb888Image::clear_width() {
  width_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Rgb888Image::_internal_width() const {
  return width_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Rgb888Image::width() const {
  // @@protoc_insertion_point(field_get:aip.processor.v2.Rgb888Image.width)
  return _internal_width();
}
inline void Rgb888Image::_internal_set_width(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  width_ = value;
}
inline void Rgb888Image::set_width(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_width(value);
  // @@protoc_insertion_point(field_set:aip.processor.v2.Rgb888Image.width)
}

// int32 height = 2;
inline void Rgb888Image::clear_height() {
  height_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Rgb888Image::_internal_height() const {
  return height_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Rgb888Image::height() const {
  // @@protoc_insertion_point(field_get:aip.processor.v2.Rgb888Image.height)
  return _internal_height();
}
inline void Rgb888Image::_internal_set_height(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  height_ = value;
}
inline void Rgb888Image::set_height(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_height(value);
  // @@protoc_insertion_point(field_set:aip.processor.v2.Rgb888Image.height)
}

// string path = 3;
inline void Rgb888Image::clear_path() {
  path_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& Rgb888Image::path() const {
  // @@protoc_insertion_point(field_get:aip.processor.v2.Rgb888Image.path)
  return _internal_path();
}
inline void Rgb888Image::set_path(const std::string& value) {
  _internal_set_path(value);
  // @@protoc_insertion_point(field_set:aip.processor.v2.Rgb888Image.path)
}
inline std::string* Rgb888Image::mutable_path() {
  // @@protoc_insertion_point(field_mutable:aip.processor.v2.Rgb888Image.path)
  return _internal_mutable_path();
}
inline const std::string& Rgb888Image::_internal_path() const {
  return path_.Get();
}
inline void Rgb888Image::_internal_set_path(const std::string& value) {
  
  path_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void Rgb888Image::set_path(std::string&& value) {
  
  path_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:aip.processor.v2.Rgb888Image.path)
}
inline void Rgb888Image::set_path(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  path_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:aip.processor.v2.Rgb888Image.path)
}
inline void Rgb888Image::set_path(const char* value,
    size_t size) {
  
  path_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:aip.processor.v2.Rgb888Image.path)
}
inline std::string* Rgb888Image::_internal_mutable_path() {
  
  return path_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* Rgb888Image::release_path() {
  // @@protoc_insertion_point(field_release:aip.processor.v2.Rgb888Image.path)
  return path_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void Rgb888Image::set_allocated_path(std::string* path) {
  if (path != nullptr) {
    
  } else {
    
  }
  path_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), path,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:aip.processor.v2.Rgb888Image.path)
}

// -------------------------------------------------------------------

// Bgr888Image

// int32 width = 1;
inline void Bgr888Image::clear_width() {
  width_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Bgr888Image::_internal_width() const {
  return width_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Bgr888Image::width() const {
  // @@protoc_insertion_point(field_get:aip.processor.v2.Bgr888Image.width)
  return _internal_width();
}
inline void Bgr888Image::_internal_set_width(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  width_ = value;
}
inline void Bgr888Image::set_width(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_width(value);
  // @@protoc_insertion_point(field_set:aip.processor.v2.Bgr888Image.width)
}

// int32 height = 2;
inline void Bgr888Image::clear_height() {
  height_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Bgr888Image::_internal_height() const {
  return height_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Bgr888Image::height() const {
  // @@protoc_insertion_point(field_get:aip.processor.v2.Bgr888Image.height)
  return _internal_height();
}
inline void Bgr888Image::_internal_set_height(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  height_ = value;
}
inline void Bgr888Image::set_height(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_height(value);
  // @@protoc_insertion_point(field_set:aip.processor.v2.Bgr888Image.height)
}

// string path = 3;
inline void Bgr888Image::clear_path() {
  path_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& Bgr888Image::path() const {
  // @@protoc_insertion_point(field_get:aip.processor.v2.Bgr888Image.path)
  return _internal_path();
}
inline void Bgr888Image::set_path(const std::string& value) {
  _internal_set_path(value);
  // @@protoc_insertion_point(field_set:aip.processor.v2.Bgr888Image.path)
}
inline std::string* Bgr888Image::mutable_path() {
  // @@protoc_insertion_point(field_mutable:aip.processor.v2.Bgr888Image.path)
  return _internal_mutable_path();
}
inline const std::string& Bgr888Image::_internal_path() const {
  return path_.Get();
}
inline void Bgr888Image::_internal_set_path(const std::string& value) {
  
  path_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void Bgr888Image::set_path(std::string&& value) {
  
  path_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:aip.processor.v2.Bgr888Image.path)
}
inline void Bgr888Image::set_path(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  path_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:aip.processor.v2.Bgr888Image.path)
}
inline void Bgr888Image::set_path(const char* value,
    size_t size) {
  
  path_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:aip.processor.v2.Bgr888Image.path)
}
inline std::string* Bgr888Image::_internal_mutable_path() {
  
  return path_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* Bgr888Image::release_path() {
  // @@protoc_insertion_point(field_release:aip.processor.v2.Bgr888Image.path)
  return path_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void Bgr888Image::set_allocated_path(std::string* path) {
  if (path != nullptr) {
    
  } else {
    
  }
  path_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), path,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:aip.processor.v2.Bgr888Image.path)
}

// -------------------------------------------------------------------

// PngImage

// int32 width = 1;
inline void PngImage::clear_width() {
  width_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 PngImage::_internal_width() const {
  return width_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 PngImage::width() const {
  // @@protoc_insertion_point(field_get:aip.processor.v2.PngImage.width)
  return _internal_width();
}
inline void PngImage::_internal_set_width(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  width_ = value;
}
inline void PngImage::set_width(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_width(value);
  // @@protoc_insertion_point(field_set:aip.processor.v2.PngImage.width)
}

// int32 height = 2;
inline void PngImage::clear_height() {
  height_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 PngImage::_internal_height() const {
  return height_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 PngImage::height() const {
  // @@protoc_insertion_point(field_get:aip.processor.v2.PngImage.height)
  return _internal_height();
}
inline void PngImage::_internal_set_height(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  height_ = value;
}
inline void PngImage::set_height(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_height(value);
  // @@protoc_insertion_point(field_set:aip.processor.v2.PngImage.height)
}

// string path = 3;
inline void PngImage::clear_path() {
  path_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& PngImage::path() const {
  // @@protoc_insertion_point(field_get:aip.processor.v2.PngImage.path)
  return _internal_path();
}
inline void PngImage::set_path(const std::string& value) {
  _internal_set_path(value);
  // @@protoc_insertion_point(field_set:aip.processor.v2.PngImage.path)
}
inline std::string* PngImage::mutable_path() {
  // @@protoc_insertion_point(field_mutable:aip.processor.v2.PngImage.path)
  return _internal_mutable_path();
}
inline const std::string& PngImage::_internal_path() const {
  return path_.Get();
}
inline void PngImage::_internal_set_path(const std::string& value) {
  
  path_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void PngImage::set_path(std::string&& value) {
  
  path_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:aip.processor.v2.PngImage.path)
}
inline void PngImage::set_path(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  path_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:aip.processor.v2.PngImage.path)
}
inline void PngImage::set_path(const char* value,
    size_t size) {
  
  path_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:aip.processor.v2.PngImage.path)
}
inline std::string* PngImage::_internal_mutable_path() {
  
  return path_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* PngImage::release_path() {
  // @@protoc_insertion_point(field_release:aip.processor.v2.PngImage.path)
  return path_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void PngImage::set_allocated_path(std::string* path) {
  if (path != nullptr) {
    
  } else {
    
  }
  path_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), path,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:aip.processor.v2.PngImage.path)
}

// -------------------------------------------------------------------

// TiffImage

// int32 width = 1;
inline void TiffImage::clear_width() {
  width_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 TiffImage::_internal_width() const {
  return width_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 TiffImage::width() const {
  // @@protoc_insertion_point(field_get:aip.processor.v2.TiffImage.width)
  return _internal_width();
}
inline void TiffImage::_internal_set_width(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  width_ = value;
}
inline void TiffImage::set_width(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_width(value);
  // @@protoc_insertion_point(field_set:aip.processor.v2.TiffImage.width)
}

// int32 height = 2;
inline void TiffImage::clear_height() {
  height_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 TiffImage::_internal_height() const {
  return height_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 TiffImage::height() const {
  // @@protoc_insertion_point(field_get:aip.processor.v2.TiffImage.height)
  return _internal_height();
}
inline void TiffImage::_internal_set_height(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  height_ = value;
}
inline void TiffImage::set_height(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_height(value);
  // @@protoc_insertion_point(field_set:aip.processor.v2.TiffImage.height)
}

// string path = 3;
inline void TiffImage::clear_path() {
  path_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& TiffImage::path() const {
  // @@protoc_insertion_point(field_get:aip.processor.v2.TiffImage.path)
  return _internal_path();
}
inline void TiffImage::set_path(const std::string& value) {
  _internal_set_path(value);
  // @@protoc_insertion_point(field_set:aip.processor.v2.TiffImage.path)
}
inline std::string* TiffImage::mutable_path() {
  // @@protoc_insertion_point(field_mutable:aip.processor.v2.TiffImage.path)
  return _internal_mutable_path();
}
inline const std::string& TiffImage::_internal_path() const {
  return path_.Get();
}
inline void TiffImage::_internal_set_path(const std::string& value) {
  
  path_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void TiffImage::set_path(std::string&& value) {
  
  path_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:aip.processor.v2.TiffImage.path)
}
inline void TiffImage::set_path(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  path_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:aip.processor.v2.TiffImage.path)
}
inline void TiffImage::set_path(const char* value,
    size_t size) {
  
  path_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:aip.processor.v2.TiffImage.path)
}
inline std::string* TiffImage::_internal_mutable_path() {
  
  return path_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* TiffImage::release_path() {
  // @@protoc_insertion_point(field_release:aip.processor.v2.TiffImage.path)
  return path_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void TiffImage::set_allocated_path(std::string* path) {
  if (path != nullptr) {
    
  } else {
    
  }
  path_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), path,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:aip.processor.v2.TiffImage.path)
}

// -------------------------------------------------------------------

// Nitf21Image

// string path = 1;
inline void Nitf21Image::clear_path() {
  path_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& Nitf21Image::path() const {
  // @@protoc_insertion_point(field_get:aip.processor.v2.Nitf21Image.path)
  return _internal_path();
}
inline void Nitf21Image::set_path(const std::string& value) {
  _internal_set_path(value);
  // @@protoc_insertion_point(field_set:aip.processor.v2.Nitf21Image.path)
}
inline std::string* Nitf21Image::mutable_path() {
  // @@protoc_insertion_point(field_mutable:aip.processor.v2.Nitf21Image.path)
  return _internal_mutable_path();
}
inline const std::string& Nitf21Image::_internal_path() const {
  return path_.Get();
}
inline void Nitf21Image::_internal_set_path(const std::string& value) {
  
  path_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void Nitf21Image::set_path(std::string&& value) {
  
  path_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:aip.processor.v2.Nitf21Image.path)
}
inline void Nitf21Image::set_path(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  path_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:aip.processor.v2.Nitf21Image.path)
}
inline void Nitf21Image::set_path(const char* value,
    size_t size) {
  
  path_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:aip.processor.v2.Nitf21Image.path)
}
inline std::string* Nitf21Image::_internal_mutable_path() {
  
  return path_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* Nitf21Image::release_path() {
  // @@protoc_insertion_point(field_release:aip.processor.v2.Nitf21Image.path)
  return path_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void Nitf21Image::set_allocated_path(std::string* path) {
  if (path != nullptr) {
    
  } else {
    
  }
  path_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), path,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:aip.processor.v2.Nitf21Image.path)
}

// -------------------------------------------------------------------

// DigitalGlobeMetadata

// string feature_id = 1;
inline void DigitalGlobeMetadata::clear_feature_id() {
  feature_id_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& DigitalGlobeMetadata::feature_id() const {
  // @@protoc_insertion_point(field_get:aip.processor.v2.DigitalGlobeMetadata.feature_id)
  return _internal_feature_id();
}
inline void DigitalGlobeMetadata::set_feature_id(const std::string& value) {
  _internal_set_feature_id(value);
  // @@protoc_insertion_point(field_set:aip.processor.v2.DigitalGlobeMetadata.feature_id)
}
inline std::string* DigitalGlobeMetadata::mutable_feature_id() {
  // @@protoc_insertion_point(field_mutable:aip.processor.v2.DigitalGlobeMetadata.feature_id)
  return _internal_mutable_feature_id();
}
inline const std::string& DigitalGlobeMetadata::_internal_feature_id() const {
  return feature_id_.Get();
}
inline void DigitalGlobeMetadata::_internal_set_feature_id(const std::string& value) {
  
  feature_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void DigitalGlobeMetadata::set_feature_id(std::string&& value) {
  
  feature_id_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:aip.processor.v2.DigitalGlobeMetadata.feature_id)
}
inline void DigitalGlobeMetadata::set_feature_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  feature_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:aip.processor.v2.DigitalGlobeMetadata.feature_id)
}
inline void DigitalGlobeMetadata::set_feature_id(const char* value,
    size_t size) {
  
  feature_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:aip.processor.v2.DigitalGlobeMetadata.feature_id)
}
inline std::string* DigitalGlobeMetadata::_internal_mutable_feature_id() {
  
  return feature_id_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* DigitalGlobeMetadata::release_feature_id() {
  // @@protoc_insertion_point(field_release:aip.processor.v2.DigitalGlobeMetadata.feature_id)
  return feature_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void DigitalGlobeMetadata::set_allocated_feature_id(std::string* feature_id) {
  if (feature_id != nullptr) {
    
  } else {
    
  }
  feature_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), feature_id,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:aip.processor.v2.DigitalGlobeMetadata.feature_id)
}

// string source = 3;
inline void DigitalGlobeMetadata::clear_source() {
  source_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& DigitalGlobeMetadata::source() const {
  // @@protoc_insertion_point(field_get:aip.processor.v2.DigitalGlobeMetadata.source)
  return _internal_source();
}
inline void DigitalGlobeMetadata::set_source(const std::string& value) {
  _internal_set_source(value);
  // @@protoc_insertion_point(field_set:aip.processor.v2.DigitalGlobeMetadata.source)
}
inline std::string* DigitalGlobeMetadata::mutable_source() {
  // @@protoc_insertion_point(field_mutable:aip.processor.v2.DigitalGlobeMetadata.source)
  return _internal_mutable_source();
}
inline const std::string& DigitalGlobeMetadata::_internal_source() const {
  return source_.Get();
}
inline void DigitalGlobeMetadata::_internal_set_source(const std::string& value) {
  
  source_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void DigitalGlobeMetadata::set_source(std::string&& value) {
  
  source_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:aip.processor.v2.DigitalGlobeMetadata.source)
}
inline void DigitalGlobeMetadata::set_source(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  source_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:aip.processor.v2.DigitalGlobeMetadata.source)
}
inline void DigitalGlobeMetadata::set_source(const char* value,
    size_t size) {
  
  source_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:aip.processor.v2.DigitalGlobeMetadata.source)
}
inline std::string* DigitalGlobeMetadata::_internal_mutable_source() {
  
  return source_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* DigitalGlobeMetadata::release_source() {
  // @@protoc_insertion_point(field_release:aip.processor.v2.DigitalGlobeMetadata.source)
  return source_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void DigitalGlobeMetadata::set_allocated_source(std::string* source) {
  if (source != nullptr) {
    
  } else {
    
  }
  source_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), source,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:aip.processor.v2.DigitalGlobeMetadata.source)
}

// uint32 niirs = 4;
inline void DigitalGlobeMetadata::clear_niirs() {
  niirs_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 DigitalGlobeMetadata::_internal_niirs() const {
  return niirs_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 DigitalGlobeMetadata::niirs() const {
  // @@protoc_insertion_point(field_get:aip.processor.v2.DigitalGlobeMetadata.niirs)
  return _internal_niirs();
}
inline void DigitalGlobeMetadata::_internal_set_niirs(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  niirs_ = value;
}
inline void DigitalGlobeMetadata::set_niirs(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_niirs(value);
  // @@protoc_insertion_point(field_set:aip.processor.v2.DigitalGlobeMetadata.niirs)
}

// string product_type = 6;
inline void DigitalGlobeMetadata::clear_product_type() {
  product_type_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& DigitalGlobeMetadata::product_type() const {
  // @@protoc_insertion_point(field_get:aip.processor.v2.DigitalGlobeMetadata.product_type)
  return _internal_product_type();
}
inline void DigitalGlobeMetadata::set_product_type(const std::string& value) {
  _internal_set_product_type(value);
  // @@protoc_insertion_point(field_set:aip.processor.v2.DigitalGlobeMetadata.product_type)
}
inline std::string* DigitalGlobeMetadata::mutable_product_type() {
  // @@protoc_insertion_point(field_mutable:aip.processor.v2.DigitalGlobeMetadata.product_type)
  return _internal_mutable_product_type();
}
inline const std::string& DigitalGlobeMetadata::_internal_product_type() const {
  return product_type_.Get();
}
inline void DigitalGlobeMetadata::_internal_set_product_type(const std::string& value) {
  
  product_type_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void DigitalGlobeMetadata::set_product_type(std::string&& value) {
  
  product_type_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:aip.processor.v2.DigitalGlobeMetadata.product_type)
}
inline void DigitalGlobeMetadata::set_product_type(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  product_type_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:aip.processor.v2.DigitalGlobeMetadata.product_type)
}
inline void DigitalGlobeMetadata::set_product_type(const char* value,
    size_t size) {
  
  product_type_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:aip.processor.v2.DigitalGlobeMetadata.product_type)
}
inline std::string* DigitalGlobeMetadata::_internal_mutable_product_type() {
  
  return product_type_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* DigitalGlobeMetadata::release_product_type() {
  // @@protoc_insertion_point(field_release:aip.processor.v2.DigitalGlobeMetadata.product_type)
  return product_type_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void DigitalGlobeMetadata::set_allocated_product_type(std::string* product_type) {
  if (product_type != nullptr) {
    
  } else {
    
  }
  product_type_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), product_type,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:aip.processor.v2.DigitalGlobeMetadata.product_type)
}

// double off_nadir_degrees = 7;
inline void DigitalGlobeMetadata::clear_off_nadir_degrees() {
  off_nadir_degrees_ = 0;
}
inline double DigitalGlobeMetadata::_internal_off_nadir_degrees() const {
  return off_nadir_degrees_;
}
inline double DigitalGlobeMetadata::off_nadir_degrees() const {
  // @@protoc_insertion_point(field_get:aip.processor.v2.DigitalGlobeMetadata.off_nadir_degrees)
  return _internal_off_nadir_degrees();
}
inline void DigitalGlobeMetadata::_internal_set_off_nadir_degrees(double value) {
  
  off_nadir_degrees_ = value;
}
inline void DigitalGlobeMetadata::set_off_nadir_degrees(double value) {
  _internal_set_off_nadir_degrees(value);
  // @@protoc_insertion_point(field_set:aip.processor.v2.DigitalGlobeMetadata.off_nadir_degrees)
}

// double sun_elevation_degrees = 8;
inline void DigitalGlobeMetadata::clear_sun_elevation_degrees() {
  sun_elevation_degrees_ = 0;
}
inline double DigitalGlobeMetadata::_internal_sun_elevation_degrees() const {
  return sun_elevation_degrees_;
}
inline double DigitalGlobeMetadata::sun_elevation_degrees() const {
  // @@protoc_insertion_point(field_get:aip.processor.v2.DigitalGlobeMetadata.sun_elevation_degrees)
  return _internal_sun_elevation_degrees();
}
inline void DigitalGlobeMetadata::_internal_set_sun_elevation_degrees(double value) {
  
  sun_elevation_degrees_ = value;
}
inline void DigitalGlobeMetadata::set_sun_elevation_degrees(double value) {
  _internal_set_sun_elevation_degrees(value);
  // @@protoc_insertion_point(field_set:aip.processor.v2.DigitalGlobeMetadata.sun_elevation_degrees)
}

// double sun_azimuth_degrees = 9;
inline void DigitalGlobeMetadata::clear_sun_azimuth_degrees() {
  sun_azimuth_degrees_ = 0;
}
inline double DigitalGlobeMetadata::_internal_sun_azimuth_degrees() const {
  return sun_azimuth_degrees_;
}
inline double DigitalGlobeMetadata::sun_azimuth_degrees() const {
  // @@protoc_insertion_point(field_get:aip.processor.v2.DigitalGlobeMetadata.sun_azimuth_degrees)
  return _internal_sun_azimuth_degrees();
}
inline void DigitalGlobeMetadata::_internal_set_sun_azimuth_degrees(double value) {
  
  sun_azimuth_degrees_ = value;
}
inline void DigitalGlobeMetadata::set_sun_azimuth_degrees(double value) {
  _internal_set_sun_azimuth_degrees(value);
  // @@protoc_insertion_point(field_set:aip.processor.v2.DigitalGlobeMetadata.sun_azimuth_degrees)
}

// uint64 ground_sample_distance_centimeters = 10;
inline void DigitalGlobeMetadata::clear_ground_sample_distance_centimeters() {
  ground_sample_distance_centimeters_ = PROTOBUF_ULONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 DigitalGlobeMetadata::_internal_ground_sample_distance_centimeters() const {
  return ground_sample_distance_centimeters_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 DigitalGlobeMetadata::ground_sample_distance_centimeters() const {
  // @@protoc_insertion_point(field_get:aip.processor.v2.DigitalGlobeMetadata.ground_sample_distance_centimeters)
  return _internal_ground_sample_distance_centimeters();
}
inline void DigitalGlobeMetadata::_internal_set_ground_sample_distance_centimeters(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  ground_sample_distance_centimeters_ = value;
}
inline void DigitalGlobeMetadata::set_ground_sample_distance_centimeters(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_ground_sample_distance_centimeters(value);
  // @@protoc_insertion_point(field_set:aip.processor.v2.DigitalGlobeMetadata.ground_sample_distance_centimeters)
}

// .aip.processor.v2.GeoCoordinate top_left = 11;
inline bool DigitalGlobeMetadata::_internal_has_top_left() const {
  return this != internal_default_instance() && top_left_ != nullptr;
}
inline bool DigitalGlobeMetadata::has_top_left() const {
  return _internal_has_top_left();
}
inline void DigitalGlobeMetadata::clear_top_left() {
  if (GetArena() == nullptr && top_left_ != nullptr) {
    delete top_left_;
  }
  top_left_ = nullptr;
}
inline const ::aip::processor::v2::GeoCoordinate& DigitalGlobeMetadata::_internal_top_left() const {
  const ::aip::processor::v2::GeoCoordinate* p = top_left_;
  return p != nullptr ? *p : *reinterpret_cast<const ::aip::processor::v2::GeoCoordinate*>(
      &::aip::processor::v2::_GeoCoordinate_default_instance_);
}
inline const ::aip::processor::v2::GeoCoordinate& DigitalGlobeMetadata::top_left() const {
  // @@protoc_insertion_point(field_get:aip.processor.v2.DigitalGlobeMetadata.top_left)
  return _internal_top_left();
}
inline void DigitalGlobeMetadata::unsafe_arena_set_allocated_top_left(
    ::aip::processor::v2::GeoCoordinate* top_left) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(top_left_);
  }
  top_left_ = top_left;
  if (top_left) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:aip.processor.v2.DigitalGlobeMetadata.top_left)
}
inline ::aip::processor::v2::GeoCoordinate* DigitalGlobeMetadata::release_top_left() {
  
  ::aip::processor::v2::GeoCoordinate* temp = top_left_;
  top_left_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::aip::processor::v2::GeoCoordinate* DigitalGlobeMetadata::unsafe_arena_release_top_left() {
  // @@protoc_insertion_point(field_release:aip.processor.v2.DigitalGlobeMetadata.top_left)
  
  ::aip::processor::v2::GeoCoordinate* temp = top_left_;
  top_left_ = nullptr;
  return temp;
}
inline ::aip::processor::v2::GeoCoordinate* DigitalGlobeMetadata::_internal_mutable_top_left() {
  
  if (top_left_ == nullptr) {
    auto* p = CreateMaybeMessage<::aip::processor::v2::GeoCoordinate>(GetArena());
    top_left_ = p;
  }
  return top_left_;
}
inline ::aip::processor::v2::GeoCoordinate* DigitalGlobeMetadata::mutable_top_left() {
  // @@protoc_insertion_point(field_mutable:aip.processor.v2.DigitalGlobeMetadata.top_left)
  return _internal_mutable_top_left();
}
inline void DigitalGlobeMetadata::set_allocated_top_left(::aip::processor::v2::GeoCoordinate* top_left) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete top_left_;
  }
  if (top_left) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(top_left);
    if (message_arena != submessage_arena) {
      top_left = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, top_left, submessage_arena);
    }
    
  } else {
    
  }
  top_left_ = top_left;
  // @@protoc_insertion_point(field_set_allocated:aip.processor.v2.DigitalGlobeMetadata.top_left)
}

// .aip.processor.v2.GeoCoordinate top_right = 12;
inline bool DigitalGlobeMetadata::_internal_has_top_right() const {
  return this != internal_default_instance() && top_right_ != nullptr;
}
inline bool DigitalGlobeMetadata::has_top_right() const {
  return _internal_has_top_right();
}
inline void DigitalGlobeMetadata::clear_top_right() {
  if (GetArena() == nullptr && top_right_ != nullptr) {
    delete top_right_;
  }
  top_right_ = nullptr;
}
inline const ::aip::processor::v2::GeoCoordinate& DigitalGlobeMetadata::_internal_top_right() const {
  const ::aip::processor::v2::GeoCoordinate* p = top_right_;
  return p != nullptr ? *p : *reinterpret_cast<const ::aip::processor::v2::GeoCoordinate*>(
      &::aip::processor::v2::_GeoCoordinate_default_instance_);
}
inline const ::aip::processor::v2::GeoCoordinate& DigitalGlobeMetadata::top_right() const {
  // @@protoc_insertion_point(field_get:aip.processor.v2.DigitalGlobeMetadata.top_right)
  return _internal_top_right();
}
inline void DigitalGlobeMetadata::unsafe_arena_set_allocated_top_right(
    ::aip::processor::v2::GeoCoordinate* top_right) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(top_right_);
  }
  top_right_ = top_right;
  if (top_right) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:aip.processor.v2.DigitalGlobeMetadata.top_right)
}
inline ::aip::processor::v2::GeoCoordinate* DigitalGlobeMetadata::release_top_right() {
  
  ::aip::processor::v2::GeoCoordinate* temp = top_right_;
  top_right_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::aip::processor::v2::GeoCoordinate* DigitalGlobeMetadata::unsafe_arena_release_top_right() {
  // @@protoc_insertion_point(field_release:aip.processor.v2.DigitalGlobeMetadata.top_right)
  
  ::aip::processor::v2::GeoCoordinate* temp = top_right_;
  top_right_ = nullptr;
  return temp;
}
inline ::aip::processor::v2::GeoCoordinate* DigitalGlobeMetadata::_internal_mutable_top_right() {
  
  if (top_right_ == nullptr) {
    auto* p = CreateMaybeMessage<::aip::processor::v2::GeoCoordinate>(GetArena());
    top_right_ = p;
  }
  return top_right_;
}
inline ::aip::processor::v2::GeoCoordinate* DigitalGlobeMetadata::mutable_top_right() {
  // @@protoc_insertion_point(field_mutable:aip.processor.v2.DigitalGlobeMetadata.top_right)
  return _internal_mutable_top_right();
}
inline void DigitalGlobeMetadata::set_allocated_top_right(::aip::processor::v2::GeoCoordinate* top_right) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete top_right_;
  }
  if (top_right) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(top_right);
    if (message_arena != submessage_arena) {
      top_right = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, top_right, submessage_arena);
    }
    
  } else {
    
  }
  top_right_ = top_right;
  // @@protoc_insertion_point(field_set_allocated:aip.processor.v2.DigitalGlobeMetadata.top_right)
}

// .aip.processor.v2.GeoCoordinate bottom_right = 13;
inline bool DigitalGlobeMetadata::_internal_has_bottom_right() const {
  return this != internal_default_instance() && bottom_right_ != nullptr;
}
inline bool DigitalGlobeMetadata::has_bottom_right() const {
  return _internal_has_bottom_right();
}
inline void DigitalGlobeMetadata::clear_bottom_right() {
  if (GetArena() == nullptr && bottom_right_ != nullptr) {
    delete bottom_right_;
  }
  bottom_right_ = nullptr;
}
inline const ::aip::processor::v2::GeoCoordinate& DigitalGlobeMetadata::_internal_bottom_right() const {
  const ::aip::processor::v2::GeoCoordinate* p = bottom_right_;
  return p != nullptr ? *p : *reinterpret_cast<const ::aip::processor::v2::GeoCoordinate*>(
      &::aip::processor::v2::_GeoCoordinate_default_instance_);
}
inline const ::aip::processor::v2::GeoCoordinate& DigitalGlobeMetadata::bottom_right() const {
  // @@protoc_insertion_point(field_get:aip.processor.v2.DigitalGlobeMetadata.bottom_right)
  return _internal_bottom_right();
}
inline void DigitalGlobeMetadata::unsafe_arena_set_allocated_bottom_right(
    ::aip::processor::v2::GeoCoordinate* bottom_right) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(bottom_right_);
  }
  bottom_right_ = bottom_right;
  if (bottom_right) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:aip.processor.v2.DigitalGlobeMetadata.bottom_right)
}
inline ::aip::processor::v2::GeoCoordinate* DigitalGlobeMetadata::release_bottom_right() {
  
  ::aip::processor::v2::GeoCoordinate* temp = bottom_right_;
  bottom_right_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::aip::processor::v2::GeoCoordinate* DigitalGlobeMetadata::unsafe_arena_release_bottom_right() {
  // @@protoc_insertion_point(field_release:aip.processor.v2.DigitalGlobeMetadata.bottom_right)
  
  ::aip::processor::v2::GeoCoordinate* temp = bottom_right_;
  bottom_right_ = nullptr;
  return temp;
}
inline ::aip::processor::v2::GeoCoordinate* DigitalGlobeMetadata::_internal_mutable_bottom_right() {
  
  if (bottom_right_ == nullptr) {
    auto* p = CreateMaybeMessage<::aip::processor::v2::GeoCoordinate>(GetArena());
    bottom_right_ = p;
  }
  return bottom_right_;
}
inline ::aip::processor::v2::GeoCoordinate* DigitalGlobeMetadata::mutable_bottom_right() {
  // @@protoc_insertion_point(field_mutable:aip.processor.v2.DigitalGlobeMetadata.bottom_right)
  return _internal_mutable_bottom_right();
}
inline void DigitalGlobeMetadata::set_allocated_bottom_right(::aip::processor::v2::GeoCoordinate* bottom_right) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete bottom_right_;
  }
  if (bottom_right) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(bottom_right);
    if (message_arena != submessage_arena) {
      bottom_right = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, bottom_right, submessage_arena);
    }
    
  } else {
    
  }
  bottom_right_ = bottom_right;
  // @@protoc_insertion_point(field_set_allocated:aip.processor.v2.DigitalGlobeMetadata.bottom_right)
}

// .aip.processor.v2.GeoCoordinate bottom_left = 14;
inline bool DigitalGlobeMetadata::_internal_has_bottom_left() const {
  return this != internal_default_instance() && bottom_left_ != nullptr;
}
inline bool DigitalGlobeMetadata::has_bottom_left() const {
  return _internal_has_bottom_left();
}
inline void DigitalGlobeMetadata::clear_bottom_left() {
  if (GetArena() == nullptr && bottom_left_ != nullptr) {
    delete bottom_left_;
  }
  bottom_left_ = nullptr;
}
inline const ::aip::processor::v2::GeoCoordinate& DigitalGlobeMetadata::_internal_bottom_left() const {
  const ::aip::processor::v2::GeoCoordinate* p = bottom_left_;
  return p != nullptr ? *p : *reinterpret_cast<const ::aip::processor::v2::GeoCoordinate*>(
      &::aip::processor::v2::_GeoCoordinate_default_instance_);
}
inline const ::aip::processor::v2::GeoCoordinate& DigitalGlobeMetadata::bottom_left() const {
  // @@protoc_insertion_point(field_get:aip.processor.v2.DigitalGlobeMetadata.bottom_left)
  return _internal_bottom_left();
}
inline void DigitalGlobeMetadata::unsafe_arena_set_allocated_bottom_left(
    ::aip::processor::v2::GeoCoordinate* bottom_left) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(bottom_left_);
  }
  bottom_left_ = bottom_left;
  if (bottom_left) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:aip.processor.v2.DigitalGlobeMetadata.bottom_left)
}
inline ::aip::processor::v2::GeoCoordinate* DigitalGlobeMetadata::release_bottom_left() {
  
  ::aip::processor::v2::GeoCoordinate* temp = bottom_left_;
  bottom_left_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::aip::processor::v2::GeoCoordinate* DigitalGlobeMetadata::unsafe_arena_release_bottom_left() {
  // @@protoc_insertion_point(field_release:aip.processor.v2.DigitalGlobeMetadata.bottom_left)
  
  ::aip::processor::v2::GeoCoordinate* temp = bottom_left_;
  bottom_left_ = nullptr;
  return temp;
}
inline ::aip::processor::v2::GeoCoordinate* DigitalGlobeMetadata::_internal_mutable_bottom_left() {
  
  if (bottom_left_ == nullptr) {
    auto* p = CreateMaybeMessage<::aip::processor::v2::GeoCoordinate>(GetArena());
    bottom_left_ = p;
  }
  return bottom_left_;
}
inline ::aip::processor::v2::GeoCoordinate* DigitalGlobeMetadata::mutable_bottom_left() {
  // @@protoc_insertion_point(field_mutable:aip.processor.v2.DigitalGlobeMetadata.bottom_left)
  return _internal_mutable_bottom_left();
}
inline void DigitalGlobeMetadata::set_allocated_bottom_left(::aip::processor::v2::GeoCoordinate* bottom_left) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete bottom_left_;
  }
  if (bottom_left) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(bottom_left);
    if (message_arena != submessage_arena) {
      bottom_left = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, bottom_left, submessage_arena);
    }
    
  } else {
    
  }
  bottom_left_ = bottom_left;
  // @@protoc_insertion_point(field_set_allocated:aip.processor.v2.DigitalGlobeMetadata.bottom_left)
}

// -------------------------------------------------------------------

// ProviderMetadata

// .aip.processor.v2.DigitalGlobeMetadata digital_globe = 1;
inline bool ProviderMetadata::_internal_has_digital_globe() const {
  return metadata_case() == kDigitalGlobe;
}
inline bool ProviderMetadata::has_digital_globe() const {
  return _internal_has_digital_globe();
}
inline void ProviderMetadata::set_has_digital_globe() {
  _oneof_case_[0] = kDigitalGlobe;
}
inline void ProviderMetadata::clear_digital_globe() {
  if (_internal_has_digital_globe()) {
    if (GetArena() == nullptr) {
      delete metadata_.digital_globe_;
    }
    clear_has_metadata();
  }
}
inline ::aip::processor::v2::DigitalGlobeMetadata* ProviderMetadata::release_digital_globe() {
  // @@protoc_insertion_point(field_release:aip.processor.v2.ProviderMetadata.digital_globe)
  if (_internal_has_digital_globe()) {
    clear_has_metadata();
      ::aip::processor::v2::DigitalGlobeMetadata* temp = metadata_.digital_globe_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    metadata_.digital_globe_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::aip::processor::v2::DigitalGlobeMetadata& ProviderMetadata::_internal_digital_globe() const {
  return _internal_has_digital_globe()
      ? *metadata_.digital_globe_
      : *reinterpret_cast< ::aip::processor::v2::DigitalGlobeMetadata*>(&::aip::processor::v2::_DigitalGlobeMetadata_default_instance_);
}
inline const ::aip::processor::v2::DigitalGlobeMetadata& ProviderMetadata::digital_globe() const {
  // @@protoc_insertion_point(field_get:aip.processor.v2.ProviderMetadata.digital_globe)
  return _internal_digital_globe();
}
inline ::aip::processor::v2::DigitalGlobeMetadata* ProviderMetadata::unsafe_arena_release_digital_globe() {
  // @@protoc_insertion_point(field_unsafe_arena_release:aip.processor.v2.ProviderMetadata.digital_globe)
  if (_internal_has_digital_globe()) {
    clear_has_metadata();
    ::aip::processor::v2::DigitalGlobeMetadata* temp = metadata_.digital_globe_;
    metadata_.digital_globe_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ProviderMetadata::unsafe_arena_set_allocated_digital_globe(::aip::processor::v2::DigitalGlobeMetadata* digital_globe) {
  clear_metadata();
  if (digital_globe) {
    set_has_digital_globe();
    metadata_.digital_globe_ = digital_globe;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:aip.processor.v2.ProviderMetadata.digital_globe)
}
inline ::aip::processor::v2::DigitalGlobeMetadata* ProviderMetadata::_internal_mutable_digital_globe() {
  if (!_internal_has_digital_globe()) {
    clear_metadata();
    set_has_digital_globe();
    metadata_.digital_globe_ = CreateMaybeMessage< ::aip::processor::v2::DigitalGlobeMetadata >(GetArena());
  }
  return metadata_.digital_globe_;
}
inline ::aip::processor::v2::DigitalGlobeMetadata* ProviderMetadata::mutable_digital_globe() {
  // @@protoc_insertion_point(field_mutable:aip.processor.v2.ProviderMetadata.digital_globe)
  return _internal_mutable_digital_globe();
}

inline bool ProviderMetadata::has_metadata() const {
  return metadata_case() != METADATA_NOT_SET;
}
inline void ProviderMetadata::clear_has_metadata() {
  _oneof_case_[0] = METADATA_NOT_SET;
}
inline ProviderMetadata::MetadataCase ProviderMetadata::metadata_case() const {
  return ProviderMetadata::MetadataCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// UasMetadata

// float platform_heading_angle = 5;
inline void UasMetadata::clear_platform_heading_angle() {
  platform_heading_angle_ = 0;
}
inline float UasMetadata::_internal_platform_heading_angle() const {
  return platform_heading_angle_;
}
inline float UasMetadata::platform_heading_angle() const {
  // @@protoc_insertion_point(field_get:aip.processor.v2.UasMetadata.platform_heading_angle)
  return _internal_platform_heading_angle();
}
inline void UasMetadata::_internal_set_platform_heading_angle(float value) {
  
  platform_heading_angle_ = value;
}
inline void UasMetadata::set_platform_heading_angle(float value) {
  _internal_set_platform_heading_angle(value);
  // @@protoc_insertion_point(field_set:aip.processor.v2.UasMetadata.platform_heading_angle)
}

// float platform_pitch_angle = 6;
inline void UasMetadata::clear_platform_pitch_angle() {
  platform_pitch_angle_ = 0;
}
inline float UasMetadata::_internal_platform_pitch_angle() const {
  return platform_pitch_angle_;
}
inline float UasMetadata::platform_pitch_angle() const {
  // @@protoc_insertion_point(field_get:aip.processor.v2.UasMetadata.platform_pitch_angle)
  return _internal_platform_pitch_angle();
}
inline void UasMetadata::_internal_set_platform_pitch_angle(float value) {
  
  platform_pitch_angle_ = value;
}
inline void UasMetadata::set_platform_pitch_angle(float value) {
  _internal_set_platform_pitch_angle(value);
  // @@protoc_insertion_point(field_set:aip.processor.v2.UasMetadata.platform_pitch_angle)
}

// float platform_roll_angle = 7;
inline void UasMetadata::clear_platform_roll_angle() {
  platform_roll_angle_ = 0;
}
inline float UasMetadata::_internal_platform_roll_angle() const {
  return platform_roll_angle_;
}
inline float UasMetadata::platform_roll_angle() const {
  // @@protoc_insertion_point(field_get:aip.processor.v2.UasMetadata.platform_roll_angle)
  return _internal_platform_roll_angle();
}
inline void UasMetadata::_internal_set_platform_roll_angle(float value) {
  
  platform_roll_angle_ = value;
}
inline void UasMetadata::set_platform_roll_angle(float value) {
  _internal_set_platform_roll_angle(value);
  // @@protoc_insertion_point(field_set:aip.processor.v2.UasMetadata.platform_roll_angle)
}

// double sensor_latitude = 13;
inline void UasMetadata::clear_sensor_latitude() {
  sensor_latitude_ = 0;
}
inline double UasMetadata::_internal_sensor_latitude() const {
  return sensor_latitude_;
}
inline double UasMetadata::sensor_latitude() const {
  // @@protoc_insertion_point(field_get:aip.processor.v2.UasMetadata.sensor_latitude)
  return _internal_sensor_latitude();
}
inline void UasMetadata::_internal_set_sensor_latitude(double value) {
  
  sensor_latitude_ = value;
}
inline void UasMetadata::set_sensor_latitude(double value) {
  _internal_set_sensor_latitude(value);
  // @@protoc_insertion_point(field_set:aip.processor.v2.UasMetadata.sensor_latitude)
}

// double sensor_longitude = 14;
inline void UasMetadata::clear_sensor_longitude() {
  sensor_longitude_ = 0;
}
inline double UasMetadata::_internal_sensor_longitude() const {
  return sensor_longitude_;
}
inline double UasMetadata::sensor_longitude() const {
  // @@protoc_insertion_point(field_get:aip.processor.v2.UasMetadata.sensor_longitude)
  return _internal_sensor_longitude();
}
inline void UasMetadata::_internal_set_sensor_longitude(double value) {
  
  sensor_longitude_ = value;
}
inline void UasMetadata::set_sensor_longitude(double value) {
  _internal_set_sensor_longitude(value);
  // @@protoc_insertion_point(field_set:aip.processor.v2.UasMetadata.sensor_longitude)
}

// double sensor_true_altitude = 15;
inline void UasMetadata::clear_sensor_true_altitude() {
  sensor_true_altitude_ = 0;
}
inline double UasMetadata::_internal_sensor_true_altitude() const {
  return sensor_true_altitude_;
}
inline double UasMetadata::sensor_true_altitude() const {
  // @@protoc_insertion_point(field_get:aip.processor.v2.UasMetadata.sensor_true_altitude)
  return _internal_sensor_true_altitude();
}
inline void UasMetadata::_internal_set_sensor_true_altitude(double value) {
  
  sensor_true_altitude_ = value;
}
inline void UasMetadata::set_sensor_true_altitude(double value) {
  _internal_set_sensor_true_altitude(value);
  // @@protoc_insertion_point(field_set:aip.processor.v2.UasMetadata.sensor_true_altitude)
}

// float sensor_horizontal_fov = 16;
inline void UasMetadata::clear_sensor_horizontal_fov() {
  sensor_horizontal_fov_ = 0;
}
inline float UasMetadata::_internal_sensor_horizontal_fov() const {
  return sensor_horizontal_fov_;
}
inline float UasMetadata::sensor_horizontal_fov() const {
  // @@protoc_insertion_point(field_get:aip.processor.v2.UasMetadata.sensor_horizontal_fov)
  return _internal_sensor_horizontal_fov();
}
inline void UasMetadata::_internal_set_sensor_horizontal_fov(float value) {
  
  sensor_horizontal_fov_ = value;
}
inline void UasMetadata::set_sensor_horizontal_fov(float value) {
  _internal_set_sensor_horizontal_fov(value);
  // @@protoc_insertion_point(field_set:aip.processor.v2.UasMetadata.sensor_horizontal_fov)
}

// float sensor_vertical_fov = 17;
inline void UasMetadata::clear_sensor_vertical_fov() {
  sensor_vertical_fov_ = 0;
}
inline float UasMetadata::_internal_sensor_vertical_fov() const {
  return sensor_vertical_fov_;
}
inline float UasMetadata::sensor_vertical_fov() const {
  // @@protoc_insertion_point(field_get:aip.processor.v2.UasMetadata.sensor_vertical_fov)
  return _internal_sensor_vertical_fov();
}
inline void UasMetadata::_internal_set_sensor_vertical_fov(float value) {
  
  sensor_vertical_fov_ = value;
}
inline void UasMetadata::set_sensor_vertical_fov(float value) {
  _internal_set_sensor_vertical_fov(value);
  // @@protoc_insertion_point(field_set:aip.processor.v2.UasMetadata.sensor_vertical_fov)
}

// double sensor_relative_azimuth_angle = 18;
inline void UasMetadata::clear_sensor_relative_azimuth_angle() {
  sensor_relative_azimuth_angle_ = 0;
}
inline double UasMetadata::_internal_sensor_relative_azimuth_angle() const {
  return sensor_relative_azimuth_angle_;
}
inline double UasMetadata::sensor_relative_azimuth_angle() const {
  // @@protoc_insertion_point(field_get:aip.processor.v2.UasMetadata.sensor_relative_azimuth_angle)
  return _internal_sensor_relative_azimuth_angle();
}
inline void UasMetadata::_internal_set_sensor_relative_azimuth_angle(double value) {
  
  sensor_relative_azimuth_angle_ = value;
}
inline void UasMetadata::set_sensor_relative_azimuth_angle(double value) {
  _internal_set_sensor_relative_azimuth_angle(value);
  // @@protoc_insertion_point(field_set:aip.processor.v2.UasMetadata.sensor_relative_azimuth_angle)
}

// double sensor_relative_elevation_angle = 19;
inline void UasMetadata::clear_sensor_relative_elevation_angle() {
  sensor_relative_elevation_angle_ = 0;
}
inline double UasMetadata::_internal_sensor_relative_elevation_angle() const {
  return sensor_relative_elevation_angle_;
}
inline double UasMetadata::sensor_relative_elevation_angle() const {
  // @@protoc_insertion_point(field_get:aip.processor.v2.UasMetadata.sensor_relative_elevation_angle)
  return _internal_sensor_relative_elevation_angle();
}
inline void UasMetadata::_internal_set_sensor_relative_elevation_angle(double value) {
  
  sensor_relative_elevation_angle_ = value;
}
inline void UasMetadata::set_sensor_relative_elevation_angle(double value) {
  _internal_set_sensor_relative_elevation_angle(value);
  // @@protoc_insertion_point(field_set:aip.processor.v2.UasMetadata.sensor_relative_elevation_angle)
}

// double sensor_relative_roll_angle = 20;
inline void UasMetadata::clear_sensor_relative_roll_angle() {
  sensor_relative_roll_angle_ = 0;
}
inline double UasMetadata::_internal_sensor_relative_roll_angle() const {
  return sensor_relative_roll_angle_;
}
inline double UasMetadata::sensor_relative_roll_angle() const {
  // @@protoc_insertion_point(field_get:aip.processor.v2.UasMetadata.sensor_relative_roll_angle)
  return _internal_sensor_relative_roll_angle();
}
inline void UasMetadata::_internal_set_sensor_relative_roll_angle(double value) {
  
  sensor_relative_roll_angle_ = value;
}
inline void UasMetadata::set_sensor_relative_roll_angle(double value) {
  _internal_set_sensor_relative_roll_angle(value);
  // @@protoc_insertion_point(field_set:aip.processor.v2.UasMetadata.sensor_relative_roll_angle)
}

// string image_source_sensor = 21;
inline void UasMetadata::clear_image_source_sensor() {
  image_source_sensor_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& UasMetadata::image_source_sensor() const {
  // @@protoc_insertion_point(field_get:aip.processor.v2.UasMetadata.image_source_sensor)
  return _internal_image_source_sensor();
}
inline void UasMetadata::set_image_source_sensor(const std::string& value) {
  _internal_set_image_source_sensor(value);
  // @@protoc_insertion_point(field_set:aip.processor.v2.UasMetadata.image_source_sensor)
}
inline std::string* UasMetadata::mutable_image_source_sensor() {
  // @@protoc_insertion_point(field_mutable:aip.processor.v2.UasMetadata.image_source_sensor)
  return _internal_mutable_image_source_sensor();
}
inline const std::string& UasMetadata::_internal_image_source_sensor() const {
  return image_source_sensor_.Get();
}
inline void UasMetadata::_internal_set_image_source_sensor(const std::string& value) {
  
  image_source_sensor_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void UasMetadata::set_image_source_sensor(std::string&& value) {
  
  image_source_sensor_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:aip.processor.v2.UasMetadata.image_source_sensor)
}
inline void UasMetadata::set_image_source_sensor(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  image_source_sensor_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:aip.processor.v2.UasMetadata.image_source_sensor)
}
inline void UasMetadata::set_image_source_sensor(const char* value,
    size_t size) {
  
  image_source_sensor_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:aip.processor.v2.UasMetadata.image_source_sensor)
}
inline std::string* UasMetadata::_internal_mutable_image_source_sensor() {
  
  return image_source_sensor_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* UasMetadata::release_image_source_sensor() {
  // @@protoc_insertion_point(field_release:aip.processor.v2.UasMetadata.image_source_sensor)
  return image_source_sensor_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void UasMetadata::set_allocated_image_source_sensor(std::string* image_source_sensor) {
  if (image_source_sensor != nullptr) {
    
  } else {
    
  }
  image_source_sensor_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), image_source_sensor,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:aip.processor.v2.UasMetadata.image_source_sensor)
}

// .aip.processor.v2.ProviderMetadata provider_metadata = 22;
inline bool UasMetadata::_internal_has_provider_metadata() const {
  return this != internal_default_instance() && provider_metadata_ != nullptr;
}
inline bool UasMetadata::has_provider_metadata() const {
  return _internal_has_provider_metadata();
}
inline void UasMetadata::clear_provider_metadata() {
  if (GetArena() == nullptr && provider_metadata_ != nullptr) {
    delete provider_metadata_;
  }
  provider_metadata_ = nullptr;
}
inline const ::aip::processor::v2::ProviderMetadata& UasMetadata::_internal_provider_metadata() const {
  const ::aip::processor::v2::ProviderMetadata* p = provider_metadata_;
  return p != nullptr ? *p : *reinterpret_cast<const ::aip::processor::v2::ProviderMetadata*>(
      &::aip::processor::v2::_ProviderMetadata_default_instance_);
}
inline const ::aip::processor::v2::ProviderMetadata& UasMetadata::provider_metadata() const {
  // @@protoc_insertion_point(field_get:aip.processor.v2.UasMetadata.provider_metadata)
  return _internal_provider_metadata();
}
inline void UasMetadata::unsafe_arena_set_allocated_provider_metadata(
    ::aip::processor::v2::ProviderMetadata* provider_metadata) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(provider_metadata_);
  }
  provider_metadata_ = provider_metadata;
  if (provider_metadata) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:aip.processor.v2.UasMetadata.provider_metadata)
}
inline ::aip::processor::v2::ProviderMetadata* UasMetadata::release_provider_metadata() {
  
  ::aip::processor::v2::ProviderMetadata* temp = provider_metadata_;
  provider_metadata_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::aip::processor::v2::ProviderMetadata* UasMetadata::unsafe_arena_release_provider_metadata() {
  // @@protoc_insertion_point(field_release:aip.processor.v2.UasMetadata.provider_metadata)
  
  ::aip::processor::v2::ProviderMetadata* temp = provider_metadata_;
  provider_metadata_ = nullptr;
  return temp;
}
inline ::aip::processor::v2::ProviderMetadata* UasMetadata::_internal_mutable_provider_metadata() {
  
  if (provider_metadata_ == nullptr) {
    auto* p = CreateMaybeMessage<::aip::processor::v2::ProviderMetadata>(GetArena());
    provider_metadata_ = p;
  }
  return provider_metadata_;
}
inline ::aip::processor::v2::ProviderMetadata* UasMetadata::mutable_provider_metadata() {
  // @@protoc_insertion_point(field_mutable:aip.processor.v2.UasMetadata.provider_metadata)
  return _internal_mutable_provider_metadata();
}
inline void UasMetadata::set_allocated_provider_metadata(::aip::processor::v2::ProviderMetadata* provider_metadata) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete provider_metadata_;
  }
  if (provider_metadata) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(provider_metadata);
    if (message_arena != submessage_arena) {
      provider_metadata = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, provider_metadata, submessage_arena);
    }
    
  } else {
    
  }
  provider_metadata_ = provider_metadata;
  // @@protoc_insertion_point(field_set_allocated:aip.processor.v2.UasMetadata.provider_metadata)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace v2
}  // namespace processor
}  // namespace aip

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::aip::processor::v2::ProcessorV2Config_Capability> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::aip::processor::v2::ProcessorV2Config_Capability>() {
  return ::aip::processor::v2::ProcessorV2Config_Capability_descriptor();
}
template <> struct is_proto_enum< ::aip::processor::v2::ImageFormat> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::aip::processor::v2::ImageFormat>() {
  return ::aip::processor::v2::ImageFormat_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_proto_2fpalantir_2fprocessing_2dservice_2dv2_2eproto
